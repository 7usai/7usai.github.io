<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-09-08T15:12:50.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[CUMTOJ部分题解(更新中)]]></title>
        <id>https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/</id>
        <link href="https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/">
        </link>
        <updated>2020-09-08T15:09:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大白just大白">大白just大白</h2>
<h3 id="题目描述">题目描述</h3>
<p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p>
<p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p>
<p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p>
<p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p>
<p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p>
<p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p>
<h3 id="输入">输入</h3>
<p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p>
<p>接下来m行，每行一个关键字（字符串）</p>
<p>再接下来n行字符串。m和n都不大于20</p>
<p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p>
<h3 id="输出">输出</h3>
<p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>2 3
love
cumt
ACM
ILoveCUMTACM
cumtAACM
2 2
A
b
Ab
bA
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>ILoveCUMTACM
Ab
</code></pre>
<h3 id="代码">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	int max= 21;
    int n,m,i,j;
    string nn[max],mm[max];
    string nn2[max],mm2[max];
    while(cin&gt;&gt;n&gt;&gt;m)
    {
   		for(int i=0;i&lt;m;i++)
		{
			cin&gt;&gt;mm[i];
			mm2[i]=mm[i];
			for(int j = 0; mm[i][j] != '\0'; j++)
            {
                mm[i][j] = tolower(mm[i][j]);
            }
            //cout&lt;&lt;mm[i]&lt;&lt;mm2[i]; 
		}
		for(int i=0;i&lt;n;i++)
		{
			cin&gt;&gt;nn[i];
			nn2[i]=nn[i];
			for(int j = 0; nn[i][j] != '\0'; j++)
            {
                nn[i][j] = tolower(nn[i][j]);
            }
            //cout&lt;&lt;nn[i];
		}
        int p=-1,q=-1,k;
        for(i = 0; i &lt; n; i++)
        {
            k= 0;
            for(j = 0; j &lt; m; j++)
            {
                string::size_type temp = nn[i].find(mm[j]);
                if(temp!=string::npos)
				k++;
            }
            if(k&gt;p)
            {
                p=k;
                q=i;
            }
        }
        cout&lt;&lt;nn2[q]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="小雏鸟的计算">小雏鸟的计算</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p>
<p>考虑以下的算法：<br>
\1.     输入 n<br>
\2.     印出 n<br>
\3.     如果 n = 1 结束<br>
\4.     如果 n 是奇数 那么 n=3*n+1<br>
\5.     否则 n=n/2<br>
\6.     GOTO 2<br>
例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>
据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>
给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>
问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p>
<h3 id="输入-2">输入</h3>
<p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。</p>
<p>0&lt; i，j &lt; 1000000</p>
<h3 id="输出-2">输出</h3>
<p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p>
<h3 id="样例输入-2">样例输入</h3>
<pre><code>1 10
10 1
100 200
201 210
900 1000
</code></pre>
<h3 id="样例输出-2">样例输出</h3>
<pre><code>1 10 20
10 1 20
100 200 125
201 210 89
900 1000 174
</code></pre>
<h3 id="代码-2">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int a;
void f(int x)
{
    if(x == 1) 
	return;
    if(x % 2) 
	x = 3*x+1;
    else 
	x /= 2;
    f(x);
    a++;
}
int count(int x)
{
    a = 1;
    f(x);
    return a;
}
int main()
{
    int l,r,l2,r2,max_;
    while(cin&gt;&gt;l&gt;&gt;r)
    {
    	l2=l;
    	r2=r;
        if(l2 &gt; r2)
		swap(l2,r2);
        max_ = 0;
        for(int i = l2; i &lt;= r2; i++)
            max_ = max(max_,count(i));
        cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;max_&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="排列问题">排列问题</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h3 id="输入-3">输入</h3>
<p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h3 id="输出-3">输出</h3>
<p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h3 id="样例输入-3">样例输入</h3>
<pre><code>abc,
</code></pre>
<h3 id="样例输出-3">样例输出</h3>
<pre><code>abc acb bac bca cab cba
</code></pre>
<h3 id="代码-3">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	string s;
	cin&gt;&gt;s;
	s=s.substr(0,s.length()-1);
	sort(s.begin(),s.end());
	cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	while(next_permutation(s.begin(),s.end()))
	{
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	}
	return 0;
}
</code></pre>
<h2 id="快速幂">快速幂</h2>
<h3 id="题目描述-4">题目描述</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599577873521.png" alt="" loading="lazy"></figure>
<h3 id="输入-4">输入</h3>
<p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h3 id="输出-4">输出</h3>
<p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h3 id="样例输入-4">样例输入</h3>
<pre><code>3
4
5
</code></pre>
<h3 id="样例输出-4">样例输出</h3>
<pre><code>33
289
3414
</code></pre>
<h3 id="代码-4">代码</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
long long n=100000007;
long long poww(long long a, long long b)// return a ^ b
{
	long long ans = 1;
	while(b != 0)
	{
		if(b&amp;1 != 0) 
		ans = ans * a % n;
		a = a * a %n;
		b&gt;&gt;=1;
	}
return ans;
}
int main()
{
	int x;
	while(cin&gt;&gt;x)
	{
		long long y=0;
		for(int i=1;i&lt;=x;i++)
		y+=poww(i,i);
		cout&lt;&lt;(y+1)%n&lt;&lt;endl;
	}
	return 0;
} 
</code></pre>
<h2 id="求第k小">求第k小</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h3 id="输入-5">输入</h3>
<p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h3 id="输出-5">输出</h3>
<p>输出一行，输出第k小数。</p>
<h3 id="样例输入-5">样例输入</h3>
<pre><code>5 2
1 5 3 2 4
</code></pre>
<h3 id="样例输出-5">样例输出</h3>
<pre><code>2
</code></pre>
<h3 id="代码-5">代码</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int a[1000001];
void swap(int &amp;a, int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}
int partition(int arr[], int left, int right)  //找基准数 划分
{
    int i = left + 1 ;
    int j = right;
    int temp = arr[left];
 
    while(i &lt;= j)
    {
        while (arr[i] &lt; temp)
        {
            i++;
        }
        while (arr[j] &gt; temp )
        {
            j--;
        }
        if (i &lt; j)
            swap(arr[i++], arr[j--]);
        else i++;
   }
    swap(arr[j], arr[left]);
    return j; 
}
void quicksort(int a[],int left,int right)
{
	if(left &lt; right)
	{
		int j= partition(a, left, right);
	    quicksort(a, left, j - 1);
		quicksort(a, j + 1, right);	
	}
}
int main()
{
	int n, k;
	cin &gt;&gt; n;
	cin &gt;&gt; k; 
	for(int i = 0; i &lt; n; i++)
		cin &gt;&gt; a[i];
	quicksort(a, 0, n-1);
	cout &lt;&lt; a[k - 1] &lt;&lt; endl;
	return 0;	
}
</code></pre>
<h2 id="沙子的质量dp题">沙子的质量(dp题)</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h3 id="输入-6">输入</h3>
<p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h3 id="输出-6">输出</h3>
<p>合并的最小代价。</p>
<h3 id="样例输入-6">样例输入</h3>
<pre><code>4
1 3 5 2
</code></pre>
<h3 id="样例输出-6">样例输出</h3>
<pre><code>22
</code></pre>
<h3 id="代码-6">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int main()
{
	int dp[300][300];
    int n,i,j,k,a[300],sum[300] = {0};
   	//cout&lt;&lt;sizeof(dp);
	memset(dp,1,sizeof(dp));
    cin&gt;&gt;n;
    for(i = 1; i &lt;= n; i++)
    {
        cin&gt;&gt;a[i];
        sum[i] = sum[i-1]+a[i];
        dp[i][i] = 0;
    }
    for(i = 2; i &lt;= n; i++)
    {
        for(j = i; j &gt;= 1; j--)
        {
            for(k = j; k &lt;= i; k++)
                dp[j][i] = min(dp[j][i],dp[j][k]+dp[k+1][i]+sum[i]-sum[j-1]);
        }
    }
    cout&lt;&lt;dp[1][n];
    return 0;
}
</code></pre>
<h2 id="最长公共子序列dp题">最长公共子序列(dp题)</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad&quot; ,顺次选1，3，5个字符就构成子串&quot; cad&quot; ,现给定两个字符串，求它们的最长共公子串。</p>
<h3 id="输入-7">输入</h3>
<p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h3 id="输出-7">输出</h3>
<p>最长子串的长度。</p>
<h3 id="样例输入-7">样例输入</h3>
<pre><code>abccd aecd
</code></pre>
<h3 id="样例输出-7">样例输出</h3>
<pre><code>3
</code></pre>
<h3 id="代码-7">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int dp[2000][2000]; 
int main()
{
	int len1,len2,i,j;
    char a[2000],b[2000];
    cin&gt;&gt;a&gt;&gt;b;
    len1 = strlen(a);
	len2 = strlen(b);
    for( i = 1; i &lt;= len1; i++)
    {
        for( j = 1; j &lt;= len2; j++)
        {
            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout&lt;&lt;dp[len1][len2];
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RE学习]]></title>
        <id>https://7usai.github.io/post/re-xue-xi/</id>
        <link href="https://7usai.github.io/post/re-xue-xi/">
        </link>
        <updated>2020-09-02T11:44:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="逆向软件基础">逆向软件基础</h1>
<p>debug版本较大、带调试信息，release版本优化程序、程序更小</p>
<h2 id="od快捷键">OD快捷键</h2>
<pre><code>F2 下断点
F3 加载一个可执行程序
F4 程序执行到光标处
F5 缩小、还原当前窗口
F7 单步步入
F8 单步步过
F9 直接运行程序，遇到断点处，程序暂停
Ctrl + F2 重新运行程序到起始处
Ctrl + F9 执行到函数返回处，用于跳出函数实现
Ctrl + G 输入十六进制地址，快速定位到该地址处
Ctrl + N 应用程序的输入表
Alt + B 显示断点窗口
Alt + C 显示 CPU 窗口
Alt + F9 执行到用户代码处，用于快速跳出系统函数
Ctrl+j跳转main函数
</code></pre>
<h2 id="寻找main函数od">寻找main函数(OD)</h2>
<p>1.寻找参考字符串<br>
2.main函数特点：3个push、1个call,F7进入。<br>
3.API寻找<br>
4.IDA</p>
<h2 id="修改内存中的数据">修改内存中的数据</h2>
<p>1.OD:右键-&gt;二进制-&gt;编辑<br>
2.修改PUSH的地址以及该地址中的数据</p>
<h2 id="修改跳转">修改跳转</h2>
<p>1.修改关键跳转<br>
2.修改对比值</p>
<h2 id="滑板指令">滑板指令</h2>
<p>nop/90； 作用：把自己过掉执行下一句</p>
<h2 id="初级破解">初级破解</h2>
<h3 id="找到main函数所在位置">找到main函数所在位置</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599047100466.png" alt="" loading="lazy"></figure>
<h3 id="整体main函数">整体main函数</h3>
<pre><code>00181080  /$  55            push ebp
00181081  |.  8BEC          mov ebp,esp
00181083  |.  83EC 38       sub esp,0x38
00181086  |.  A1 04F01900   mov eax,dword ptr ds:[0x19F004]
0018108B  |.  33C5          xor eax,ebp
0018108D  |.  8945 FC       mov [local.1],eax
00181090  |.  68 A8D61900   push 05.0019D6A8
00181095  |.  E8 86FFFFFF   call 05.00181020
0018109A  |.  6A 32         push 0x32
0018109C  |.  8D45 C8       lea eax,[local.14]
0018109F  |.  6A 00         push 0x0
001810A1  |.  50            push eax
001810A2  |.  E8 790D0000   call 05.00181E20
001810A7  |.  8D45 C8       lea eax,[local.14]
001810AA  |.  50            push eax
001810AB  |.  68 B8D61900   push 05.0019D6B8                         ;  &quot;%s&quot;
001810B0  |.  E8 9BFFFFFF   call 05.00181050
001810B5  |.  8B45 C8       mov eax,[local.14]
001810B8  |.  33D2          xor edx,edx
001810BA  |.  83C4 18       add esp,0x18
001810BD  |.  3C 72         cmp al,0x72
001810BF  |.  0F94C2        sete dl
001810C2  |.  80FC 6B       cmp ah,0x6B
001810C5  |.  8D4A 01       lea ecx,dword ptr ds:[edx+0x1]
001810C8  |.  0F45CA        cmovne ecx,edx
001810CB  |.  807D CA 76    cmp byte ptr ss:[ebp-0x36],0x76
001810CF  |.  8D41 01       lea eax,dword ptr ds:[ecx+0x1]
001810D2  |.  0F45C1        cmovne eax,ecx
001810D5  |.  807D CB 69    cmp byte ptr ss:[ebp-0x35],0x69
001810D9  |.  8D48 01       lea ecx,dword ptr ds:[eax+0x1]
001810DC  |.  0F45C8        cmovne ecx,eax
001810DF  |.  807D CC 72    cmp byte ptr ss:[ebp-0x34],0x72
001810E3  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]
001810E6  |.  0F45D1        cmovne edx,ecx
001810E9  |.  807D CD 00    cmp byte ptr ss:[ebp-0x33],0x0
001810ED  |.  8D42 01       lea eax,dword ptr ds:[edx+0x1]
001810F0  |.  0F45C2        cmovne eax,edx
001810F3  |.  83F8 05       cmp eax,0x5
001810F6  |.  76 07         jbe short 05.001810FF
001810F8  |.  68 BCD61900   push 05.0019D6BC                         ;  ASCII 6C,&quot;ogin sucess!\n&quot;
001810FD  |.  EB 05         jmp short 05.00181104
001810FF  |&gt;  68 CCD61900   push 05.0019D6CC                         ;  ASCII 6C,&quot;ogin failed!\n&quot;
00181104  |&gt;  E8 17FFFFFF   call 05.00181020
00181109  |.  83C4 04       add esp,0x4
0018110C  |.  68 DCD61900   push 05.0019D6DC                         ;  ASCII 70,&quot;ause&quot;
00181111  |.  E8 892A0000   call 05.00183B9F
00181116  |.  8B4D FC       mov ecx,[local.1]
00181119  |.  83C4 04       add esp,0x4
0018111C  |.  33CD          xor ecx,ebp
0018111E  |.  33C0          xor eax,eax
00181120  |.  E8 04000000   call 05.00181129
00181125  |.  8BE5          mov esp,ebp
00181127  |.  5D            pop ebp                                  ;  05.001812F1
00181128  \.  C3            retn

</code></pre>
<p>单步调试一遍</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599047110988.png" alt="" loading="lazy"></figure>
<p>到这个位置显示请输入密码，随便敲一串字符继续调试</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599047118404.png" alt="" loading="lazy"></figure>
<p>调试到此处显示登录失败</p>
<h3 id="破解方法">破解方法</h3>
<h4 id="方法1修改跳转">方法1：修改跳转</h4>
<p>经过初次调试可知00181020为printf，并添加各行作用注释</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599047124421.png" alt="" loading="lazy"></figure>
<p>意思为eax&gt;5时，即上述对比字符串都相同时登录成功输出login success；<br>
过程：eax&gt;5，不执行jbe跳转，将login success压栈，跳转到call print函数位置；</p>
<p><img src="https://7usai.github.io/post-images/1599047131428.png" alt="" loading="lazy"><br>
修改后我们让它直接跳转到压栈位置。</p>
<h4 id="方法2修改关键字">方法2：修改关键字</h4>
<p>这里我们可知关键值时为eax，eax与5比较，大于5时才输出login success</p>
<p><img src="https://7usai.github.io/post-images/1599047137396.png" alt="" loading="lazy"><br>
我们在这里将eax值修改为大于5的数</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599047146195.png" alt="" loading="lazy"></figure>
<h4 id="方法3分析得password">方法3：分析得password</h4>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599047156075.png" alt="" loading="lazy"></figure>
<p>我们在这里可知，与0x72,0x6B,0x76,0x69,0x72,0x0做了对比相同则登录成功，于是密码为</p>
<p>思路：push eax 将输入的值存入了eax，ecx,edx两个中间值辅助eax+1.<br>
<img src="https://7usai.github.io/post-images/1599047162183.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599047167384.png" alt="" loading="lazy"></figure>
<p>得到密码rkvir，成功</p>
<h4 id="方法4修改对比值">方法4：修改对比值</h4>
<p>即修改0x72,0x6B,0x76,0x69,0x72，让其与我们输入的值相同，即将我们输入的值变成password。</p>
<p>假如我们输入7usai就要改成0x37,0x75,0x73,0x61,0x69</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599047173916.png" alt="" loading="lazy"></figure>
<p>登录成功</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599047179674.png" alt="" loading="lazy"></figure>
<h2 id="mfc破解初试">MFC破解初试</h2>
<h3 id="初始界面">初始界面</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599295190085.png" alt="" loading="lazy"></figure>
<h3 id="修改跳转-2">修改跳转</h3>
<p><img src="https://7usai.github.io/post-images/1599295199199.png" alt="" loading="lazy"><br>
rkvir为密码已经可以看出，双击紫色行进入<br>
<img src="https://7usai.github.io/post-images/1599295206191.png" alt="" loading="lazy"><br>
修改跳转<br>
<img src="https://7usai.github.io/post-images/1599295211864.png" alt="" loading="lazy"></p>
<h3 id="修改密码">修改密码</h3>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599295219313.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599295225417.png" alt="" loading="lazy"></figure>
<h2 id="初试破解crakeme">初试破解CrakeMe</h2>
<p><img src="https://7usai.github.io/post-images/1599295232305.png" alt="" loading="lazy"><br>
需要弹出下面的消息框</p>
<h3 id="改跳转">改跳转</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1599295239334.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1599295245091.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web学习]]></title>
        <id>https://7usai.github.io/post/web-xue-xi/</id>
        <link href="https://7usai.github.io/post/web-xue-xi/">
        </link>
        <updated>2020-08-30T07:16:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="web学习">web学习</h1>
<h2 id="web常见术语">web常见术语</h2>
<h3 id="渗透测试">渗透测试</h3>
<p>渗透测试：是为了证明网络防御按照预期计划正常运行而提供的一种机制。不妨假设，你的公司定期更新安全策略和程序，时时给系统打补丁，并采用了漏洞扫描器等工具，以确保所有补丁都已打上。如果你早已做到了这些，为什么还要请外方进行审查或渗透测试呢？因为，渗透测试能够独立地检查你的网络策略，换句话说，就是给你的系统安了一双眼睛。而且，进行这类测试的，都是寻找网络系统安全漏洞的专业人士。</p>
<p>参考资料：https://baike.baidu.com/item/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95</p>
<h3 id="网站">网站</h3>
<p>网站：(Website)是指在因特网上根据一定的规则，使用HTML（标准通用标记语言）等工具制作的用于展示特定内容相关网页的集合。简单地说，网站是一种沟通工具，人们可以通过网站来发布自己想要公开的资讯，或者利用网站来提供相关的网络服务。人们可以通过网页浏览器来访问网站，获取自己需要的资讯或者享受网络服务。<br>
网站是在互联网上拥有域名或地址并提供一定网络服务的主机，是存储文件的空间，以服务器为载体。人们可通过浏览器等进行访问、查找文件，也可通过远程文件传输(FTP)方式上传、下载网站文件。</p>
<p>参考资料：https://baike.baidu.com/item/%E7%BD%91%E7%AB%99/155722</p>
<h3 id="网站分类">网站分类</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1598772667836.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th><strong>静态网站</strong></th>
<th><strong>动态网站</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>每次加载页面时，预建内容都是相同的。</td>
<td>内容快速生成并定期更改。</td>
</tr>
<tr>
<td>它使用HTML代码开发。</td>
<td>它使用诸如PHP，JSP和ASP.NET等服务器端语言来开发网站。</td>
</tr>
<tr>
<td>它为每个请求发送完全相同的响应。</td>
<td>它可能会为每个请求生成不同的HTML。</td>
</tr>
<tr>
<td>仅当有人发布和更新文件(将其发送到Web服务器)时，内容才会更改。</td>
<td>页面包含“服务器端”代码，代码允许服务器在加载页面时生成唯一内容。</td>
</tr>
<tr>
<td>灵活性是静态网站的主要优势。</td>
<td>内容管理系统(CMS)是动态网站的主要优势。</td>
</tr>
</tbody>
</table>
<h3 id="cms">CMS</h3>
<p>CMS:就是模板</p>
<h3 id="脚本语言">脚本语言</h3>
<p>脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</p>
<p>常见的脚本语言：<br>
PHP<br>
JavaScript</p>
<p>数据库</p>
<p>数据库：是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。</p>
<p>常见的数据库：<br>
mysql 、SQL Server、Oracle、DB2、ACCESS</p>
<h3 id="http请求">HTTP请求</h3>
<p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：（1）请求方法URI协议/版本（2）　请求头(Request Header)（3）　请求正文</p>
<h3 id="html">html</h3>
<p>HTML：称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。</p>
<h3 id="javascript">JavaScript</h3>
<p>JavaScript：（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<p>注意：<br>
java和javascript外形字母非常像，但是二者是完全不同的二种语言。形象说，二者关系就和雷锋和雷峰塔关系一样。</p>
<p>参考资料：<br>
https://baike.baidu.com/item/javascript</p>
<h3 id="php">PHP</h3>
<p>PHP：“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。</p>
<h2 id="web组件">web组件</h2>
<p>Web组件是指对 Web 的数据和方法进行封装实体，可以包含 JavaBean 组件，从而方便地进行业务逻辑的处理<br>
https://python.freelycode.com/contribution/detail/1506</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1598772682704.png" alt="" loading="lazy"></figure>
<h3 id="自定义元素">自定义元素</h3>
<pre><code>自定义元素是HTML元素，像&lt;div&gt;, &lt;section&gt; 或&lt;article&gt;，但是我们可以自己对通过浏览器API定义的元素进行命名。自定义元素就像那些标准的HTML元素一样——名称用尖括号括起来——只不过它们总是有一个破折号，比如&lt;news-slider&gt; 或 &lt;bacon-cheeseburger&gt;。展望未来，浏览器厂商已承诺不再创建新的包含一个破折号的内置元素，以防止冲突。
自定义元素包含自己的语义、行为、标记，可以跨框架和浏览器共享。
</code></pre>
<h3 id="影子dom">影子DOM</h3>
<pre><code>影子DOM是DOM的一个封装版本。这允许作者有效地将DOM片段彼此隔离，包括可以用作CSS选择器的任何东西以及与它们关联的样式。通常，文档范围内的任何内容都称为 light DOM，影子根内的任何内容都称为影子DOM。
使用light DOM时，可以使用document.querySelector('selector')来选择元素，也可以使用element. queryselector ('selector')来选择任何元素的子元素；同样，可以通过调用shadowRoot.querySelector来锁定影子根的子节点,其中shadowRoot是对文档片段的引用——不同之处在于，影子根的子元素不能从light DOM中选择。例如，如果我们有一个包含&lt;button&gt;的影子根，调用shadowRoot.querySelector('button')将返回我们的按钮，但是没有一个文档查询选择器（document’s query selector）的调用会返回该元素，因为它属于另一个不同的DocumentOrShadowRoot实例。样式选择器也以同样的方式工作。
在这方面，影子DOM的工作方式有点像 &lt;iframe&gt;，它里边的内容会与文档的其他内容切割开；但是，当我们创建一个阴影根时，我们仍然可以完全控制页面的这一部分，但是范围仅限于上下文。这就是我们所说的封装。
如果你曾经编写过重用相同id，或者依赖于CSS-in- js工具或CSS命名策略(如BEM) 的组件，那么影子DOM有可能改善你的开发体验。
</code></pre>
<h3 id="html模板">HTML模板</h3>
<pre><code>HTML&lt;template&gt;元素允许我们在一个正常的HTML流中剔除可重用的代码模板，这些模板不会立即渲染，但是可以在稍后使用。

HTML导入：将HTML文档导入其他文档的声明方法
</code></pre>
<h2 id="html-2">HTML</h2>
<pre><code>&lt;!DOCTYPE HTML&gt;	声明该代码是由html5编写
&lt;html&gt;

&lt;head&gt;
&lt;title&gt;标题&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
主体
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;

&lt;head&gt;
&lt;title&gt;第一个程序&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
hello world!
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="常用的几个标签">常用的几个标签</h3>
<pre><code>&lt;h1&gt;一级大标题&lt;/h1&gt;
&lt;p&gt;用于存放一段文字&lt;/p&gt;
&lt;b&gt;加粗文字&lt;/b&gt;
&lt;i&gt;斜体文字&lt;/i&gt;
&lt;br /&gt;换行
&lt;a href=”https://www.baidu.com/”&gt;百度&lt;/a&gt;超级链接
&lt;img src=”1.jpg”&gt;包含图片

&lt;form method=&quot;get&quot;&gt;声明传入方式
  Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  Password: &lt;input type=&quot;passwod&quot; name=&quot;password&quot; /&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h2 id="javascript-2">JavaScript</h2>
<h3 id="javascript-和-html-以及-css的区别">JavaScript 和 HTML 以及 CSS的区别</h3>
<p>HTML：提供网页的结构，提供网页中的内容<br>
CSS: 用来美化网页<br>
JavaScript: 可以用来控制网页内容，给网页增加动态的效果</p>
<p>参考资料：<br>
https://www.w3school.com.cn/js/index.asp</p>
<h3 id="javascript组成">JavaScript组成</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1598772698026.png" alt="" loading="lazy"></figure>
<h3 id="ecmascript核心">ECMAScript（核心）</h3>
<p>定义了JavaScript的语法规范<br>
是JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p>
<h3 id="bom浏览器对象模型">BOM（浏览器对象模型）</h3>
<p>一套操作浏览器功能的API<br>
通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p>
<h3 id="dom文档对象模型">DOM（文档对象模型）</h3>
<p>一套操作页面元素的API<br>
DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p>
<h3 id="javascript-的书写格式">JavaScript 的书写格式</h3>
<pre><code>第一种，例如：
&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert('Hello World')&quot; /&gt;

第二种，例如：
  &lt;script&gt;
    alert('Hello World!');
  &lt;/script&gt;

第三种，例如：
&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
注意：引用外部js文件的script标签中不可以写JavaScript代码
</code></pre>
<h3 id="输出">输出</h3>
<p>javascript 没有任何打印或输出的函数<br>
可以通过不同的方式输出数据</p>
<p>使用window.alert() 弹出警告框<br>
使用document.write()方法将内容写到html文档中<br>
使用document.getElementById(&quot;&quot;).innerHtml=&quot;需要写入的值&quot;; 写入到HTML元素<br>
使用console.log()写入到浏览器的控制台</p>
<h3 id="输出四种方法示例">输出四种方法示例：</h3>
<pre><code>&lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt;
&lt;script&gt;
	var a=1;
	var b=2;
	if(a&gt;b){
		window.alert(a);
		document.write(a);
		console.log(a);
		document.getElementById(&quot;demo&quot;).innerHTML=a;
	}else{
		console.log(b);
		document.write(b);
		window.alert(b);
		document.getElementById(&quot;demo&quot;).innerHTML=b;
	}
	//alert(a);
	&lt;/script&gt;

</code></pre>
<h3 id="基本语法变量">基本语法：变量</h3>
<p>使用var声明变量，例如：</p>
<pre><code>&lt;script&gt;
	var a=1;
	alert(a);
&lt;/script&gt;

</code></pre>
<p>命名规范：<br>
由字母、数字、下划线、$符号组成，不能以数字开头<br>
不能是关键字和保留字，例如：for、while。<br>
区分大小写</p>
<h3 id="if语句">if语句</h3>
<pre><code>&lt;script&gt;
	var a=1;
	var b=2;
	if(a&gt;b){
		alert(a);
	}else{
		alert(b);
	}
&lt;/script&gt;
</code></pre>
<h3 id="for语句">for语句</h3>
<pre><code>for (初始化表达式1; 判断表达式2; 自增表达式3) {
  // 循环体4
}


for(var i=1;i&lt;10;i++){
		document.write(i);
}

</code></pre>
<h2 id="sql">SQL</h2>
<h3 id="information_schema">information_schema</h3>
<p>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息</p>
<p>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。<br>
TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个数据库中所有表的信息。<br>
COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。</p>
<h3 id="mysql">MYSQL</h3>
<p>user表是存放该mysql数据库中所有用户名跟密码的表</p>
<h3 id="select">select</h3>
<p>select语句是查询语句。<br>
例如：<br>
1.查询test数据库中users表中所有的数据。<br>
select * from test.users;<br>
2.查询test数据库中users表中username列中的数据。<br>
select username from test.users;<br>
3.查询test数据库中users表中id为1的数据。<br>
select * from test.users where id=1;<br>
4.查询test数据库中users表中address为china而且username为zhangsan的数据。<br>
select * from test.users where address='china' and username='zhangsan';</p>
<h3 id="order-by">order by</h3>
<p>排序功能<br>
例如：<br>
1.查询test数据库中users表中所有的数据并按照第一列进行排序。<br>
select * from test.users order by 1;<br>
2.查询test数据库中users表中所有的数据并按照第二列进行排序。<br>
select * from test.users order by 2;<br>
3.查询test数据库中users表中所有的数据并按照第三列进行排序。<br>
select * from test.users order by 3;</p>
<h3 id="union">union</h3>
<p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。<br>
例如：<br>
1.查询test数据库中users中username列的数据并查询person表中username列中的数据。<br>
select username from test.users union select username from test.person;</p>
<h3 id="insert语句">insert语句</h3>
<p>INSERT INTO SQL语句来插入数据</p>
<p>例如：在test数据库person表中插入一条数据：username是lisi，money是100<br>
insert into person (username,money) values ('lisi','100')</p>
<h2 id="php-2">PHP</h2>
<h3 id="第一个程序hello-world">第一个程序：hello world！</h3>
<pre><code>&lt;?php
echo ‘Hello world!’;
php&gt;

</code></pre>
<h3 id="变量的命名">变量的命名</h3>
<p>变量以 $ 符号开头，其后是变量的名称<br>
变量名称必须以字母或下划线开头<br>
变量名称不能以数字开头<br>
变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）可以有汉字<br>
变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</p>
<h3 id="运算符">运算符</h3>
<pre><code>+-*/
&gt;
&lt;
=
&lt;=
&gt;=
!=
==
</code></pre>
<h3 id="if">if</h3>
<pre><code>$sex = '男'
if ($sex == '男'){
echo '哥们';
}else{
echo '姐们';
}
</code></pre>
<h3 id="while">while</h3>
<pre><code>while($id &lt;= 10){
echo '不够';
$id = $id+1;
}
</code></pre>
<h3 id="for">for</h3>
<pre><code>for($id=1;$id&lt;=10;$id++){
echo '不够';
}
</code></pre>
<h3 id="打印1-100">打印1-100</h3>
<pre><code>方法一：
$id = 1;
while($id &lt;= 100){
echo $id,'&lt;br /&gt;';
$id = $id+1;
}
方法二：
for ($id =1;$id &lt;= 100;$id++)
    echo $id,'&lt;br /&gt;';
</code></pre>
<h3 id="数组">数组</h3>
<pre><code>$arr = array('1' =&gt; '张三' , '2' =&gt; '李四');
print_r($arr);
echo '&lt;hr /&gt;';
echo $arr[1];
</code></pre>
<h3 id="_get">$_GET</h3>
<pre><code>header(&quot;Content-type: text/html; charset=utf-8&quot;);
$id = $_GET['id'];
echo '我是第'.$id.'号程序员';
</code></pre>
<h3 id="_post">$_POST</h3>
<pre><code>header(&quot;Content-type: text/html; charset=utf-8&quot;);
$id = $_POST['id'];
echo '我是第'.$id.'号程序员';
</code></pre>
<h3 id="mysqli_connect">Mysqli_connect()</h3>
<pre><code>$conn = mysqli_connect('127.0.0.1','root','root','test');
</code></pre>
<h3 id="mysqli_query">Mysqli_query</h3>
<pre><code>mysqli_query() 函数执行一条 MySQL 查询。
$result = mysqli_query($con,$sql);
</code></pre>
<h3 id="mysqli_fetch_array">Mysqli_fetch_array</h3>
<pre><code>mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有
返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

$row = mysqli_fetch_array($result)
</code></pre>
<h2 id="whois查询">whois查询</h2>
<p>whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。</p>
<h3 id="查询途径">查询途径</h3>
<p>1.爱站工具网（https://whois.aizhan.com/）<br>
2.站长之家（http://whois.chinaz.com）<br>
3.VirusTotal（ https://www.virustotal.com ）</p>
<p>根据ICANN公布的《通用顶级域名注册数据临时政策细则》和欧盟通用数据保护条例合规要求，全面调整 WHOIS 公开显示的信息。</p>
<p>即：注册商提供WHOIS查询公开信息中将不再显示域名注册人、管理联系人和技术联系人的个人数据，包括姓名、邮箱、电话、街道地址等，只会显示注册商及到期日期等。而且该调整已于2018年5月25日开始生效。</p>
<h2 id="备案信息查询">备案信息查询</h2>
<p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部 门申请的 备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经 营活动的发生</p>
<p>注意：主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案</p>
<h3 id="常用的查询网站">常用的查询网站</h3>
<p>ICP备案查询网：http://www.beianbeian.com/<br>
天眼查：https://beian.tianyancha.com/</p>
<p>站长工具：http://icp.chinaz.com/<br>
工业和信息化部：http://www.beian.miit.gov.cn/</p>
<h2 id="收集敏感信息">收集敏感信息</h2>
<h3 id="谷歌语法">谷歌语法</h3>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1598957444700.png" alt="" loading="lazy"></figure>
<h4 id="举例">举例</h4>
<p>学校网站的后台<br>
Site:edu.cn intext:后台管理</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1598957452119.png" alt="" loading="lazy"></figure>
<h3 id="burp查询服务器的某些信息">Burp查询服务器的某些信息</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1598957458913.png" alt="" loading="lazy"></figure>
<h3 id="ip地址">IP地址</h3>
<p>ping指令</p>
<h3 id="网站指纹识别">网站指纹识别</h3>
<p>BugScaner：http://whatweb.bugscaner.com/look/<br>
云悉指纹：http://www.yunsee.cn/finger.html<br>
WhatWeb：https://whatweb.net/</p>
<h3 id="网站容器">网站容器</h3>
<p>nmap, iis, apache, nginx</p>
<h3 id="脚本类型">脚本类型</h3>
<p>php, asp</p>
<h3 id="数据库类型">数据库类型</h3>
<p>常见搭配：<br>
ASP 和 ASPX：ACCESS、SQL Server<br>
PHP：MySQL、PostgreSQL<br>
JSP：Oracle、MySQL</p>
<h2 id="收集子域名信息">收集子域名信息</h2>
<h3 id="为什么要收集子域名">为什么要收集子域名</h3>
<p>子域名枚举可以发现更多评估范围相关的域名/子域名，以增加漏洞发现机率；<br>
探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞；</p>
<h3 id="方法">方法</h3>
<p>1.谷歌语法<br>
2.在线子域名爆破https://phpinfo.me/domain/<br>
3.Loyer<br>
4.Maltego(kali)</p>
<h2 id="收集常用端口信息">收集常用端口信息</h2>
<p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务，就可以对症下药，便于我们渗透目标服务器。</p>
<h3 id="常见的扫描端口工具">常见的扫描端口工具</h3>
<p>1.Nmap<br>
2.Masscan<br>
3.Zmap<br>
4.御剑高速TCP端口扫描工具</p>
<h3 id="nmap基础使用">Nmap基础使用</h3>
<p>默认扫描：nmap 106.52.110.188<br>
指定端口扫描：nmap –p 3306 106.52.110.188<br>
完整扫描到端口、服务及版本：nmap –v –sV 106.52.110.188</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1598957468921.png" alt="" loading="lazy"></figure>
<h3 id="补充其他端口扫描工具">补充：其他端口扫描工具</h3>
<p>Shodan:https://www.shodan.io/<br>
在线端口扫描：http://www.t1shopper.com/tools/port-scan/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言学习（持续更新）]]></title>
        <id>https://7usai.github.io/post/c-yu-yan-xue-xi-chi-xu-geng-xin/</id>
        <link href="https://7usai.github.io/post/c-yu-yan-xue-xi-chi-xu-geng-xin/">
        </link>
        <updated>2020-08-14T10:22:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c语言">C语言</h1>
<h2 id="输入函数">输入函数</h2>
<ul>
<li>scanf (&quot;%d&quot;,&amp;Num);</li>
<li>scanf_s(&quot;%d&quot;,&amp;Num,10); 10是字符长度</li>
</ul>
<p>int Num4 ;<br>
scanf (&quot;%d&quot;,&amp;Num4);<br>
<strong>//%d就相当于告诉程序，接受的参数是一个int类型</strong>,&amp; 取地址符<br>
<strong>//Num4告诉程序，接收到的数据，存储到Num4里面</strong></p>
<hr>
<h2 id="输出函数">输出函数</h2>
<ul>
<li>printf(&quot;%d&quot; , Num5);</li>
<li>printf(&quot;123\n&quot;):\n是换行的意思，输出123到屏幕后换行</li>
</ul>
<h3 id="例子">例子：</h3>
<ul>
<li>int age;<br>
printf (&quot;请输入您的年龄:&quot;);<br>
scanf (&quot;%d&quot;,&amp;age);<br>
printf(&quot;您的年龄是: %d&quot;,age);</li>
<li>printf (&quot;请输入一个数字:&quot;);<br>
scanf (&quot;%d&quot;,&amp;Num1);<br>
printf(&quot;请再输入一个数字:&quot;);<br>
scanf (&quot;%d&quot;,&amp;Num2);<br>
Num=Num1+Num2;<br>
printf(&quot;%d + %d = %d&quot;,Num1,Num2,Num)<br>
<img src="https://7usai.github.io/post-images/1597400597382.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h2 id="整数类型">整数类型</h2>
<p>进制</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">8进制</th>
<th style="text-align:center">10进制</th>
<th style="text-align:center">16进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">%o</td>
<td style="text-align:center">%d</td>
<td style="text-align:center">%x</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">%ho</td>
<td style="text-align:center">%hd</td>
<td style="text-align:center">%hx</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">%lo</td>
<td style="text-align:center">%ld</td>
<td style="text-align:center">%lx</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">%llo</td>
<td style="text-align:center">%lld</td>
<td style="text-align:center">%llx</td>
</tr>
</tbody>
</table>
<p>e.g</p>
<pre><code>int num=100;
printf(&quot;num的8进制显示:%o,num的10进制显示:%d,num的16进制显示:%x&quot;,num,num,num)

打印结果:
num的8进制显示:144,num的10进制显示:100,num的16进制显示:64
</code></pre>
<p>//int 32位<br>
//short int 16位    short 不长于int类型<br>
//long int 32位     long不短于int类型<br>
//long long int     long long 64位<br>
//unsigned无符号  unsigned int  &quot;%u&quot;</p>
<hr>
<h2 id="字符类型">字符类型</h2>
<h3 id="char">char</h3>
<p>//理论上占8位:-128~127，Ascii码 0~127<br>
//Unicode(万国码)，16位，甚至是32位；</p>
<h4 id="声明方式">声明方式</h4>
<ol>
<li>char name1='A';//只能为'A'，为A或者&quot;A&quot;都错误</li>
<li>char name2;<br>
name2='A';</li>
<li>scanf(&quot;%c&quot;,&amp;name);</li>
<li>char name=65;<br>
printf(&quot;%c&quot;,name);//这是一种正确的声明方式，但是不提倡这么做</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">&quot;A&quot;</th>
<th style="text-align:left">'A'</th>
<th style="text-align:left">A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left">字符</td>
<td style="text-align:left">变量</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>换行</th>
<th>回车</th>
<th>警报</th>
<th>打印\</th>
<th>打印'</th>
<th>打印&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>\r</td>
<td>\a</td>
<td>\\</td>
<td>\'</td>
<td>\&quot;</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="浮点类型">浮点类型</h2>
<p>float 单精度浮点型 32位<br>
double 双精度浮点型 64位<br>
long double 长双精度浮点型</p>
<pre><code>float num=1.1;
double num1= 12E-5;
printf(&quot;%f,%f&quot;,num,num1);
return 0;

打印结果:
1.100000,0.000120
</code></pre>
<hr>
<h2 id="_bool类型">_Bool类型</h2>
<p>c99的时候引入的</p>
<pre><code>_Bool flag=0;//0代表false 假,1代表true 真
</code></pre>
<hr>
<h2 id="基础类型">基础类型</h2>
<p>int,long ,short ,unsigned,char ,float ,double ,signed, _Bool, _Complex(复数), _Imaginary(虚数)</p>
<p>包含一个头文件：inttype.h后有uint64_t(无符号整型64位)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CTFD搭建（ubuntu18.04）]]></title>
        <id>https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/</id>
        <link href="https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/">
        </link>
        <updated>2020-07-31T14:37:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="更换ubuntu1804阿里源">更换ubuntu18.04阿里源</h2>
<p>vim /etc/apt/sources.list</p>
<p>sudo apt-get update</p>
<p>sudo apt-get upgrade</p>
<h2 id="安装pip3">安装pip3</h2>
<p>apt install python3-pip</p>
<p>如果异常可以升级pip</p>
<p>sudo python3 -m pip install --upgrade pip</p>
<h2 id="pip换源">pip换源</h2>
<pre><code>mkdir ~/.pip
cd ~/.pip
touch pip.conf
编辑pip.conf文件
sudo vim ~/.pip/pip.conf
打开pip.conf文件窗口,将以下内容复制到文件中:
[global] 
index-url = http://pypi.douban.com/simple 
[install] 
trusted-host=pypi.douban.com
</code></pre>
<h2 id="安装flask">安装Flask</h2>
<p>sudo pip3 install Flask</p>
<h2 id="下载ctfd">下载CTFd</h2>
<p>sudo git clone https://github.com/isislab/CTFd.git</p>
<p>如果不能成功下载就</p>
<p>sudo git clone https://gitee.com/ivenwings/CTFd.git</p>
<p>给予权限</p>
<p>chmod -R 755 CTFd/</p>
<h2 id="安装ctfd">安装CTFd</h2>
<p>1  cd CTFd/</p>
<p>2  ./prepare.sh</p>
<p>3  pip3 install -r -requirements.txt；这一步如果不行可以尝试python3 -m pip install -r -requirements.txt</p>
<p>4  python3 serve.py</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp（持续更新）]]></title>
        <id>https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/</id>
        <link href="https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/">
        </link>
        <updated>2020-07-31T14:12:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="buuctf-re部分wp">BUUCTF re部分wp</h1>
<h2 id="easyre">easyre</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1596204910229.png" alt="" loading="lazy"></figure>
<h2 id="reverse1">reverse1</h2>
<p>搜索flag字符串找到如下位置<br>
<img src="https://7usai.github.io/post-images/1596204953682.png" alt="" loading="lazy"></p>
<p>再按F5后再双击Str2<br>
<img src="https://7usai.github.io/post-images/1596204960649.png" alt="" loading="lazy"></p>
<p>将hello_world中的o换成0</p>
<p>得flag{hell0_w0rld}</p>
<h2 id="reverse2">reverse2</h2>
<p>找到main函数按下F5<br>
<img src="https://7usai.github.io/post-images/1596204969585.png" alt="" loading="lazy"></p>
<p>双击flag</p>
<p><img src="https://7usai.github.io/post-images/1596204975899.png" alt="" loading="lazy"><br>
输入发现不正确继续看</p>
<p>这里flag中存的是{hacking_for_fun}</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1596204985974.png" alt="" loading="lazy"></figure>
<p>在主函数的这里发生了转换，查ascii表得是将i和r转换成1</p>
<p>得flag{hack1ng_fo1_fun}</p>
<h2 id="新年快乐">新年快乐</h2>
<p>有UPX壳，脱壳后找</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1596204992819.png" alt="" loading="lazy"></figure>
<h2 id="内涵的软件">内涵的软件</h2>
<p>拖进IDA得flag,DBAPP换成flag<br>
<img src="https://7usai.github.io/post-images/1596205001874.png" alt="" loading="lazy"></p>
<h2 id="bjdctf-2ndguessgame">[BJDCTF 2nd]guessgame</h2>
<p>shift+F12得flag</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1596211165409.png" alt="" loading="lazy"></figure>
<h2 id="helloword">helloword</h2>
<p>得到一个APK文件</p>
<p>放入android killer里边得flag<br>
<img src="https://7usai.github.io/post-images/1596211279124.png" alt="" loading="lazy"></p>
<h2 id="xor">XOR</h2>
<p>看main函数应该是一个33位数异或<br>
<img src="https://7usai.github.io/post-images/1596211286748.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1596211291028.png" alt="" loading="lazy"></figure>
<p>这里有33位数</p>
<p>写异或算法</p>
<pre><code>l=[0x66,0x0a,0x6b,0x0c,0x77,0x26,0x4f,0x2e,0x40,0x11,0x78,0x0d,0x5a,0x3b,0x55,0x11,0x70,0x19,0x46,0x1f,0x76,0x22,0x4d,0x23,0x44,0x0e,0x67,0x06,0x68,0x0f,0x47,0x32,0x4f]
x='f'
for i in range(1,len(l)):
    x+=chr(l[i]^l[i-1])
    print (x)
</code></pre>
<p>得flag<br>
<img src="https://7usai.github.io/post-images/1596211295525.png" alt="" loading="lazy"></p>
<h2 id="reverse3">reverse3</h2>
<p>32位IDA打开 找到main函数为sub_4156E0</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1596231374547.png" alt="" loading="lazy"></figure>
<p>Dest与Str2比较，相等则为加密的flag。首先我们输入flag值，flag值经过变换后得Dest，即Str2。</p>
<p>flag先变为v1,再变为Dest1，再变为Dest（Str2）</p>
<p>找到v1转换函数</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1596231379288.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1596231383733.png" alt="" loading="lazy"></figure>
<p>可见是base64加密</p>
<p>又得到Str2的值</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1596231387805.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<pre><code>import base64
str2='e3nifIH9b_C@n@dH'
x=''
for i in range(0,len(str2)):
    x+=chr(ord(str2[i])-i)
print (x)
y=base64.b64decode(x)
print (y)
</code></pre>
<p>得flag</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1596231394662.png" alt="" loading="lazy"></figure>
<p>补充</p>
<p>ord()函数主要用来返回对应字符的ascii码，chr()主要用来表示ascii码对应的字符他的输入时数字（可十进制可十六进制），ord:字符转ascii码，chr:ascii码转字符。在此题计算中先转为ascii减数字，得到的新ascii再转为字符。</p>
<p>python中base64加密与解码，加密用encode解密用decode，如下例</p>
<p>&gt;&gt;&gt; import base64<br>
&gt;&gt;&gt; s = '我是字符串'<br>
&gt;&gt;&gt; a = base64.b64encode(s)<br>
&gt;&gt;&gt; print a<br>
ztLKx9fWt/u0rg==<br>
&gt;&gt;&gt; print base64.b64decode(a)<br>
我是字符串</p>
<h2 id="不一样的flag">不一样的flag</h2>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1596232291308.png" alt="" loading="lazy"></figure>
<p>点开程序是这样，放入IDA32位得主函数</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1596232295572.png" alt="" loading="lazy"></figure>
<p>又查到此字符串，猜测是个迷宫题</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1596232300989.png" alt="" loading="lazy"></figure>
<p>这里的意思时遇到1就退出，即不遇到1的情况下到达#<br>
<img src="https://7usai.github.io/post-images/1596232306563.png" alt="" loading="lazy"></p>
<p>*11110100001010000101111#可分为5行 *为起点#为重点</p>
<pre><code>*1111
01000
01010
00010
1111#
</code></pre>
<p>于是走一遍得</p>
<p>flag{222441144222}</p>
<h2 id="simplerev">SimpleRev</h2>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1597677451168.png" alt="" loading="lazy"></figure>
<p>这里表示得到v4，v4为d或者D时进入Decry函数，不为d或者D时判断是否为Q或者q，是的话退出，不是则输出错误。<br>
<img src="https://7usai.github.io/post-images/1597677458757.png" alt="" loading="lazy"></p>
<p>进入Decry得到text通过key3，v9和join函数得到，进入join函数</p>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1597677466006.png" alt="" loading="lazy"></figure>
<p>意思是a1与a2连接，返回值dest=a1+a2。<br>
回到Decry函数可知text=key3+v9。key=key1+src。</p>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1597677474689.png" alt="" loading="lazy"></figure>
<p>key3=kills,key1=ADSFK，因为是小端序存储，所以text=killshadow，key=ADSFKNDCLS</p>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1597677480466.png" alt="" loading="lazy"></figure>
<p>这一步是将大写字母变为小写字母，key=adsfkndcls</p>
<p><img src="https://7usai.github.io/post-images/1597677488135.png" alt="" loading="lazy"><br>
编写脚本</p>
<pre><code>key=&quot;adsfkndcls&quot;
text=&quot;killshadow&quot;
loop=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
flag=&quot;&quot;
for i in range(0,len(text)):
    for j in loop:
        if ord(text[i])==(ord(j)-39-ord(key[i])+97)%26+97:
            flag+=j
print(flag)
</code></pre>
<p>得到flag</p>
<p>KLDQCUDFZO</p>
<h2 id="刮开有奖">刮开有奖</h2>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1597677495395.png" alt="" loading="lazy"></figure>
<p>找到主函数DialogFunc并进入可知v7是数组的开头第一位，进入sub_4010F0</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1597677500492.png" alt="" loading="lazy"></figure>
<p>转为c语音代码得</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int f(char arr[], int a, int b)
{
    int result;
    int i;
    int v5;
    int v6;
    result = b;
    for (i = a; i &lt;= b; a = i)
    {
        v5 = i;
        v6 = arr[i];
        if (a &lt; result &amp;&amp; i &lt; result)
        {
            do
            {
                if (v6 &gt; arr[result])
                {
                    if (i &gt;= result)
                        break;
                    ++i;
                    arr[v5] = arr[result];
                    if (i &gt;= result)
                        break;
                    while (arr[i] &lt;= v6)
                    {
                        if (++i &gt;= result)
                            goto LABEL_13;
                    }
                    if (i&gt;=result)
                        break;
                    v5 = i;
                    arr[result] = arr[i];
                }
                --result;
            } while (i &lt; result);
        }
LABEL_13:
        arr[result] = v6;
        f(arr, a, i - 1);
        result = b;
        ++i;
    }
    return result;
}
int main()
{
    char arr[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};
    cout &lt;&lt; arr &lt;&lt; endl;
    f(arr,0,10);
    cout&lt;&lt;arr&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>运行一下得</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1597677510196.png" alt="" loading="lazy"></figure>
<p>进入401000函数可看出事base64</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1597677516740.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1597677522324.png" alt="" loading="lazy"></figure>
<p>这里第一位是U第二位J第三位开始通过ak1w,V1ax解码得jMp和WP1所以从第三位开始是WP1jMp</p>
<p>拼得flag{UJWP1jMp}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora快捷键]]></title>
        <id>https://7usai.github.io/post/typora-kuai-jie-jian/</id>
        <link href="https://7usai.github.io/post/typora-kuai-jie-jian/">
        </link>
        <updated>2020-07-24T03:45:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一菜单栏">一：菜单栏</h2>
<hr>
<ul>
<li>文件：alt+F</li>
<li>编辑：alt+E</li>
<li>段落：alt+P</li>
<li>格式：alt+O</li>
<li>视图：alt+V</li>
<li>主题：alt+T</li>
<li>帮助：alt+H</li>
</ul>
<h2 id="二文件">二：文件</h2>
<ul>
<li>新建：Ctrl+N</li>
<li>新建窗口：Ctrl+Shift+N</li>
<li>打开：Ctrl+O</li>
<li>快速打开：Ctrl+P</li>
<li>保存：Ctrl+S</li>
<li>另存为：Ctrl+Shift+S</li>
<li>偏好：Ctrl+,</li>
<li>关闭：Ctrl+W</li>
</ul>
<h2 id="三编辑">三：编辑</h2>
<ul>
<li>撤销：Ctrl+Z</li>
<li>重做：Ctrl+Y</li>
<li>剪切：Ctrl+X</li>
<li>复制：Ctrl+C</li>
<li>粘贴：Ctrl+V</li>
<li>复制为MarkDown：Ctrl+Shift+C</li>
<li>粘贴为纯文本：Ctrl+Shift+V</li>
<li>全选：Ctrl+A</li>
<li>选中当前行/句：Ctrl+L</li>
<li>选中当前格式文本：Ctrl+E</li>
<li>选中当前词：Ctrl+D</li>
<li>跳转到文首：Ctrl+Home</li>
<li>跳转到所选内容：Ctrl+J</li>
<li>跳转到文末：Ctrl+End</li>
<li>查找：Ctrl+F</li>
<li>查找下一个：F3</li>
<li>查找上一个：Shift+F3</li>
<li>替换：Ctrl+H</li>
</ul>
<h2 id="四段落">四：段落</h2>
<ul>
<li>标题：Ctrl+1/2/3/4/5</li>
<li>段落：Ctrl+0</li>
<li>增大标题级别：Ctrl+=</li>
<li>减少标题级别：Ctrl+-</li>
<li>表格：Ctrl+T</li>
<li>代码块：Ctrl+Shift+K</li>
<li>公式块：Ctrl+Shift+M</li>
<li>引用：Ctrl+Shift+Q</li>
<li>有序列表：Ctrl+Shift+[</li>
<li>无序列表：Ctrl+Shift+]</li>
<li>增加缩进：Ctrl+]</li>
<li>减少缩进：Ctrl+[</li>
</ul>
<h2 id="五格式">五：格式</h2>
<ul>
<li>加粗：Ctrl+B</li>
<li>斜体：Ctrl+I</li>
<li>下划线：Ctrl+U</li>
<li>代码：Ctrl+Shift+`</li>
<li>删除线：Alt+Shift+5</li>
<li>超链接：Ctrl+K</li>
<li>图像：Ctrl+Shift+I</li>
<li>清除样式：Ctrl+</li>
</ul>
<h2 id="六视图">六：视图</h2>
<ul>
<li>显示隐藏侧边栏：Ctrl+Shift+L</li>
<li>大纲视图：Ctrl+Shift+1</li>
<li>文档列表视图：Ctrl+Shift+2</li>
<li>文件树视图：Ctrl+Shift+3</li>
<li>源代码模式：Ctrl+/</li>
<li>专注模式：F8</li>
<li>打字机模式：F9</li>
<li>切换全屏：F11</li>
<li>实际大小：Ctrl+Shift+0</li>
<li>放大：Ctrl+Shift+=</li>
<li>缩小：Ctrl+Shift+-</li>
<li>应用内窗口切换：Ctrl+Tab</li>
<li>打开DevTools：Shift+F12</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编学习部分总结]]></title>
        <id>https://7usai.github.io/post/hui-bian-xue-xi-bu-fen-zong-jie/</id>
        <link href="https://7usai.github.io/post/hui-bian-xue-xi-bu-fen-zong-jie/">
        </link>
        <updated>2020-07-24T03:29:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="汇编">汇编</h1>
<h2 id="汇编代码">汇编代码</h2>
<p>.586  <em>:指令集</em><br>
.MODEL flat, stdcall :指定调用约定，flat：内存指令方式 stadcall：调用约定<br>
includelib user32.lib :lib 静态库 包含一下lib文件<br>
includelib kernel32.lib :<br>
ExitProcess PROTO, dwExitCode : DWORD<br>
MessageBoxA PROTO hWnd : DWORD, lText : BYTE, lpCaption : BYTE, uType: DWORD<br>
.data<br>
Number DWORD 0<br>
text db &quot;shellcode&quot;,0<br>
.code<br>
main proc<br>
mov eax,5<br>
mov ebx,6<br>
add eax,ebx<br>
add eax,Number<br>
push 0<br>
push offset text<br>
push offset text<br>
push 0<br>
call MessageBoxA<br>
add esp,16<br>
call ExitProcess<br>
main ENDP<br>
END main</p>
<h2 id="知识点">知识点</h2>
<p>ASCII码</p>
<p>UNICODE字符集：统一码、万国码、单一码</p>
<h2 id="mov">MOV</h2>
<p>mov a,b：寄存器，寄存器||寄存器，立即数||寄存器，存储器。</p>
<h2 id="add">ADD</h2>
<p>加法指令，操作数1+操作数2，结果放入操作数1中</p>
<h2 id="整数常量">整数常量</h2>
<p>0A3H,42Q,26(D)，01010010B</p>
<p>2 b, 8 o/q,16 h ,10 (d)</p>
<h2 id="实数常量">实数常量</h2>
<p>2， 3.0， +3.0， -44.E+5，  26.E5</p>
<h2 id="字符常量">字符常量</h2>
<p>'A'/&quot;A&quot; 单/双引号都可</p>
<h2 id="字符串常量">字符串常量</h2>
<p>&quot;hello&quot;/'hello'</p>
<h2 id="保留字">保留字</h2>
<p>指令： mov	lea	 add	sub	jcc……</p>
<p>寄存器</p>
<p>属性： db	dword……</p>
<p>运算符</p>
<h2 id="标识符">标识符</h2>
<p>第一个字符是有限制的	标识符不能与保留字相同</p>
<h2 id="伪指令">伪指令</h2>
<p>.data	.code	offest...</p>
<h2 id="指令">指令</h2>
<p>mov eax,123	：汇编语句</p>
<h2 id="内部数据类型">内部数据类型</h2>
<h3 id="整数">整数</h3>
<p>BYTE 8位 无符号		WORD 16位 无符号		DWORD 32位 无符号</p>
<p>SBYTE 8位 有符号		WORD 16位 有符号		SDWORD 32位 有符号</p>
<p>FWORD 48位 保护模式的远指针		QWORD 64位 整数		TBYTE 80位 整数</p>
<h3 id="实数">实数</h3>
<p>REAL4 32位 短实数 /4字节		REAL8 64位 长实数 /8字节		REAL10 80位 扩展实数 /10字节</p>
<h3 id="伪指令-2">伪指令</h3>
<p>db 8位整数 //相当于C语言里的char 可以保存ASCII码</p>
<p>dw 16位整数</p>
<p>db 32位整数或实数</p>
<p>dq 64位整数或实数</p>
<p>dt 80位整数</p>
<h2 id="数组">数组</h2>
<h3 id="初始化数组初值为0">初始化数组（初值为0）</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1595562002397.png" alt="" loading="lazy"></figure>
<h3 id="初始化数组不定义初值">初始化数组不定义初值</h3>
<img src="F:\markdown\Typora\SAVES\image-20200624193431916.png" alt="image-20200624193431916" style="zoom:80%;" />
<h2 id="一些疑问">一些疑问</h2>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1595562020942.png" alt="" loading="lazy"></figure>
<p>老师讲解：dword 8位二进制数；	 win32 	32➗8=4   	4字节   	单位为4</p>
<h2 id="大端序小端序">大端序小端序</h2>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1595562042953.png" alt="" loading="lazy"></figure>
<p>67 45 23 01小端序		12345678 大端序</p>
<h2 id="数据传送指令">数据传送指令</h2>
<h3 id="操作数类型">操作数类型</h3>
<p>立即数	寄存器操作数（eax,ebx...)	内存操作数</p>
<h3 id="reg通用寄存器">reg通用寄存器</h3>
<p>reg8 (8位) reg16 reg32</p>
<p>sreg 段寄存器</p>
<h3 id="imm-立即数">imm 立即数</h3>
<p>imm8 imm16 imm32</p>
<h3 id="mem内存">mem内存</h3>
<p>mem8 mem16 mem32</p>
<p>(8,16,32为位数)</p>
<h3 id="数据传送指令-2">数据传送指令</h3>
<h3 id="mov-2">mov</h3>
<p>mov 目的操作数，源操作数 （源操作数如果是地址，就把地址上的数给目的操作数；如果是立即数，就直接给。前后的位数要一致，两数不能同为内存操作数）//int a=15--&gt;mov a,15</p>
<p>能使用的5种情况：mov reg,reg	mov mem,reg	mov reg,mem	mov mem,imm	mov reg,imm</p>
<p>如何实现mov mem2,mem1：mov reg,mem1+++mov mem2,reg</p>
<p>mov reg32,reg16:(eax 32位 ax 16位 ah,al 8位)看下面例子</p>
<p>mov eax,cx：		mov eax,FFFFFFFFH+++mov ax,cx</p>
<h3 id="movzx">movzx</h3>
<p>movzx eax,cx</p>
<p>cx 1234H</p>
<p>eax=00001234H（填0扩展）</p>
<h3 id="movsx">movsx</h3>
<p>movsx eax,cx</p>
<p>填1扩展</p>
<h3 id="lahf">LAHF</h3>
<p>lahf ,（没有操作数的指令）将标志存储到ah里</p>
<p>mov flag,ah</p>
<h3 id="sahf">SAHF</h3>
<p>mov ah,flag</p>
<p>sahf，将ah中的值拷贝到efalgs标志位里（zf,sf.....）</p>
<h3 id="xchg">XCHG</h3>
<p>交换指令</p>
<p>xchg reg,reg		xchg reg,mem		xchg mem,reg</p>
<h2 id="加法与减法">加法与减法</h2>
<p>add</p>
<p>add eax,ecx</p>
<p>eax=1,ecx=2 	add后 eax=3,ecx=2</p>
<p>sub减法</p>
<p>sub eax,ecx</p>
<p>eax=2,ecx=1 	sub后 eax=1,ecx=1</p>
<p>inc 自增//i++</p>
<p>inc eax  		eax=5 inc后 eax=6</p>
<p>dec 自减</p>
<p>neg</p>
<p>非 ，将操作数转为二进制补码并将符号取反</p>
<p>neg reg/mem	补码：二进制数按位取反后+1</p>
<h2 id="数据相关的运算符与伪指令">数据相关的运算符与伪指令</h2>
<p>arrNum DWORD 0,1,2,3,4,5</p>
<p>mov eax offset arrNum + 4  	:将1的地址放在eax里</p>
<p>mov eax,[eax]  		:将eax中地址的值放在eax里（将1放入eax里）</p>
<p>num DWORD 5</p>
<p>mov ax,word ptr num 		：因为ax是16位，num是32位</p>
<p>mov eax,offset lengthof num   	:获取元素个数</p>
<p>var word 32 dup(0)</p>
<p>mov eax, sizeof var		:eax =40--&gt;64 十进制  ：32*2(字节数)=64</p>
<h2 id="间接寻址">间接寻址</h2>
<p>var byte 0,1,2,3,4,5,6,7,8</p>
<p>xor eax,eax ：异或操作将eax清零</p>
<p>mov eax,offset var ：eax中存的是var的偏移，（var 为1个字节）</p>
<p>mov bl,[eax]		；将eax中地址的值给bl（1个字节）</p>
<p>mov bl,[eax+1]   ;b1为1</p>
<p>mov bl,[eax+2]	;bi为2</p>
<p>var dword 0,1,2,3,4,5,6,7,8</p>
<p>mov esi,4		;esi为下标</p>
<p>mov eax,var[esi*4]		; *4 ,4为dword宽度 （4字节） 此时eax为4</p>
<p>pbyte typedef ptr byte声明pbyte为byte(定义在数据段之前)</p>
<h2 id="jmp和loop">JMP和loop</h2>
<p>jmp无条件跳转		loop跳转一次cx--一次</p>
<h2 id="堆栈操作">堆栈操作</h2>
<p>push 压栈 	pop 出栈</p>
<p>push eax;将eax中的值压入栈顶</p>
<p>pop eax;将栈顶的值压出到eax中</p>
<p>push   ;esp-4存入一个4字节的；栈顶地址减4</p>
<p>pop     ;esp+4取出一个4字节的</p>
<p>pushfd  把32位的eflags寄存器压栈(多用于保护环境)</p>
<p>popfd  把eflags弹出</p>
<p>pushad 压栈通用寄存器 	popad 出栈</p>
<p>按此顺序压入eax,ecx,edx,ebx,esp,ebp,esi,edi  		；pop时按反顺序压出</p>
<p>pusha    	popa  16位</p>
<h3 id="获取字符串长度">获取字符串长度</h3>
<p>source byte &quot;my name is wanghailin&quot;,0</p>
<p>sourcesize = ( $ - source) - 1</p>
<h3 id="loop">loop</h3>
<p>loopz loope 循环条件：ecx&gt;0 &amp;&amp; ZF=1 (loopz一边用加减法，loope用cmp对比，两操作数相等时ZF=1跳转)</p>
<p>loopnz loopne  循环条件：ecx&gt;0 &amp;&amp; ZF=0</p>
<h2 id="定义函数">定义函数</h2>
<p>xxxx proc</p>
<p>函数内容</p>
<p>ret</p>
<p>xxxx endp</p>
<h3 id="call">call</h3>
<p>call指令：1.将eip压栈 push eip 2. jmp到函数位置</p>
<p>eip指令指针：指向下一行要执行的指令(call的下一行)</p>
<p>jmp:jmp到函数位置</p>
<h3 id="ret">ret</h3>
<p>ret指令 1.pop eip(将call的下一行压出到eip)2.jmp eip(跳转到call的下一行)</p>
<p>xxxx proc uses eax,ebx</p>
<p>函数内容</p>
<p>xxxx endp</p>
<p>可直接调用eax,ebx用于函数</p>
<h2 id="布尔与比较指令">布尔与比较指令</h2>
<p>与and 	或or	 非not	 异或xor</p>
<h3 id="test">test</h3>
<p>(测试某一位是否为1)相当于and 但不修改寄存器值 只修改eflags</p>
<p>如：</p>
<p>mov eax,00000001</p>
<p>test eax,00000000 :eax值不变,ZF=1(结果为00000000)</p>
<p>test eax,00000001 :eax值不变,ZF=0(结果为00000001)</p>
<h3 id="cmp">cmp</h3>
<p>cmp o1,o2	:o1-o2</p>
<p>o1&lt;o2 	ZF 0	 CF 1 	SF != OF</p>
<p>o1&gt;o2	 ZF 0	 CF 0	 SF =OF</p>
<p>o1=o2 	ZF 1	 CF 0</p>
<p>ZF 0标志位</p>
<p>CF 进位标志位:进位时为1</p>
<p>SF 符号标志位</p>
<p>OF 溢出标志位</p>
<h2 id="条件跳转指令">条件跳转指令</h2>
<p>JCC指令</p>
<p><a href="https://blog.csdn.net/fengshh2301/article/details/53327195">相关blog</a></p>
<p>JZ/JE 	ZF为1时跳转</p>
<p>JNZ/JNE 	ZF为0时跳转</p>
<h2 id="条件结构">条件结构</h2>
<h3 id="顺序结构">顺序结构</h3>
<h3 id="选择结构">选择结构</h3>
<p>o1 dword 100</p>
<p>o2 dword 100</p>
<p>x dword ?</p>
<p>y dword ?</p>
<p>main proc</p>
<p>​	mov eax o1</p>
<p>​	cmp eax o2	:o1=o2,eax=0,ZF=1</p>
<p>​	jnz l1	:ZF=0时跳转</p>
<p>​	mov x,1</p>
<p>​	mov y,1</p>
<p>​	jmp l2</p>
<p>l1:mov x,0</p>
<p>​	mov y,0</p>
<p>l2:push 	:l2用于让执行完if中语句后不执行else的语句</p>
<p>​	call ExitProcess	:退出</p>
<p><strong>相当于</strong></p>
<p>if(o1=o2)</p>
<p>{</p>
<p>​			x=1;</p>
<p>​			y=1;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>​			x=0;</p>
<p>​			y=0;</p>
<p>}</p>
<h3 id="循环结构">循环结构</h3>
<p>i dword 0</p>
<p>main proc</p>
<p>​	mov eax,100</p>
<p>​	cmp eax,i</p>
<p>​	jle l1	:eax&lt;=i跳转</p>
<p>​	inc i</p>
<p>l1:</p>
<p>​	push 0</p>
<p>​	call ExitProcess	:退出</p>
<p><strong>相当于</strong></p>
<p>while(i&lt;100)</p>
<p>{</p>
<p>​			i++;</p>
<p>}</p>
<h2 id="条件控制流伪命令">条件控制流伪命令</h2>
<h3 id="if">if</h3>
<p>.data</p>
<p>i dword 100</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1595562117092.png" alt="" loading="lazy"></figure>
<p>可以使用的运算符 ==	!==	&gt;	&gt;=	&lt;	&lt;=	&amp;	|	!	CARRY?(有进位CF=1返回true)	overflow?(溢出OF=1返回true)</p>
<h3 id="while">while</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1595562126073.png" alt="" loading="lazy"></figure>
<h3 id="do-while">do while</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1595562138129.png" alt="" loading="lazy"></figure>
<h2 id="移位与循环移位指令">移位与循环移位指令</h2>
<h3 id="逻辑移位">逻辑移位</h3>
<p>11001111--&gt;01100111		:补0</p>
<p>移出的一位放入了CF标志位中</p>
<h3 id="算数移位">算数移位</h3>
<p>11001111--&gt;11100111 	:符号位为1，补充1(为0时补充0)</p>
<p>SHL左移	SHR右移	SAL算数左移	SAR算数右移	ROL循环左移	ROR循环右移	RCL带进位的循环左移	RCR带进位的循环右移	SHLD双精度左移	SHRD双精度右移</p>
<h3 id="rcl带进位的循环左移">RCL带进位的循环左移</h3>
<p>clc 	:cf=0</p>
<p>mov bl,88h	:bl=10001000</p>
<p>rcl bl,1	:bl=00010000 cf=1	:把最高位1放入cf里，把cf里的数放到最后</p>
<p>rcl bl,1	:bl=00100001 cf=0</p>
<h3 id="shld双精度左移">SHLD双精度左移</h3>
<p>o1=11100000</p>
<p>o2=10011101</p>
<p>o3=1</p>
<p>shld o1,o2,o3	:o3移动位数</p>
<p>移位后</p>
<p>o1最高位放入cf里 	:CF=1</p>
<p>o1=11000001:最后一位1用o2来补上</p>
<h2 id="乘法与除法指令">乘法与除法指令</h2>
<p>无符号 mul div</p>
<p>有符号 imul idiv</p>
<p>乘数 bl bx ebx</p>
<p>被乘数 al ax eax</p>
<p>xor eax,eax</p>
<p>mov al,5h</p>
<p>mov bl,10h</p>
<p>mul bl 	:乘后的数放入al</p>
<p>有符号 imul edx,eax,ebx 	:eax✖ebx---&gt;edx</p>
<p>div 除数 被除数 商 余数</p>
<p>div mem/reg(除数)</p>
<p>被除数ax,dx,ax,eax,edx</p>
<p>8位:商在al 余数在ah</p>
<p>16位:商在ax 余数在dx</p>
<p>32位:商在eax 余数在edx</p>
]]></content>
    </entry>
</feed>