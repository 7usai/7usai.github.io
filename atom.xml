<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-09-14T15:09:18.057Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_3星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-_re_3-xing-ti-_-bu-fen-wp/">
        </link>
        <updated>2020-09-14T15:05:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界_re_3星题__部分wp">攻防世界_re_3星题__部分wp</h1>
<h2 id="debug">debug</h2>
<h3 id="先用de4dot进行脱壳">先用de4dot进行脱壳</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600095989406.png" alt="" loading="lazy"></figure>
<h3 id="放入dnspy调试">放入dnSpy调试</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600095996901.png" alt="" loading="lazy"></figure>
<p>找到main函数所在位置，很简单，a相当于输入的数，b就是经过一系列加密后得到的flag,下入断点运行就得到了flag<br>
<img src="https://7usai.github.io/post-images/1600096004477.png" alt="" loading="lazy"></p>
<h2 id="hackme">hackme</h2>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600096012245.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600096022965.png" alt="" loading="lazy"></figure>
<h3 id="思路网上借鉴的">思路(网上借鉴的)</h3>
<p>sub_406D90为随机数生成函数，且seed为固定值</p>
<p>重点是要理解这个函数的逻辑是啥。。虽然这个判断只取了有输入字符串的10个字符，但是实际上需要输入的字符串是22位（也就是实际上flag有22个char）。。</p>
<p>之后程序会从这里面随机选择一个数字i，然后从byte_6B4270和输入的字符串中分别取出第i个字符v16和v15，将v15的内容和一个生成的大数进行异或运算与v16比较。</p>
<p>整体逻辑如上，而且我们发现，这个i具体是多少其实是不需要的，因为这个i是随机生成的用于检验得到的flag的（理解这点后题目就变得十分简单了），所以我们需要做的时按程序正向逻辑进行爆破或者逆向生成这flag即可。</p>
<p>需要注意的是，虽然很多时候这种类似 unsigned __int8 的信息会被我们忽略， 但是在本题中它是非常重要的， 它标表示这个数被转型为8个bit长（也就是只有一个字节，刚好是我们ascii表的范围），故脚本中我们需要与上一个0xff</p>
<h3 id="脚本">脚本</h3>
<pre><code>a=[0x5F ,0xF2 ,0x5E ,0x8B ,0x4E ,0x0E ,0xA3 ,0xAA ,0xC7 ,0x93 ,0x81 ,
   0x3D ,0x5F ,0x74 ,0xA3 ,0x09 ,0x91 ,0x2B, 0x49 ,0x28 ,0x93 ,0x67]
flag=''
for i in range(22):
    v14=i+1
    v18=0
    v19=0
    while v18&lt;v14:
        v18+=1
        v19=1828812941 * v19 + 12345
    flag+=chr((a[i]^v19)&amp;0xff)
print(flag)
</code></pre>
<h2 id="babyre">BABYRE</h2>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600096037348.png" alt="" loading="lazy"></figure>
<p>GDB还不会，等学会了再写</p>
<h2 id="crackme">crackme</h2>
<h3 id="脱壳">脱壳</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600096045818.png" alt="" loading="lazy"></figure>
<h3 id="主函数-2">主函数</h3>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600096054533.png" alt="" loading="lazy"></figure>
<p>很简单，异或一下就行</p>
<p>dword_402150值如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600096060907.png" alt="" loading="lazy"></figure>
<h3 id="脚本-2">脚本</h3>
<pre><code>a=[0x12,0x04,0x08,0x14,0x24,0x5C,0x4A,0x3D,0x56,0x0A,0x10,0x67,0x00,0x41,0x00,0x01,0x46,0x5A,0x44,0x42,0x6E,0x0C,0x44,0x72,0x0C,0x0D,0x40,0x3E,0x4B,0x5F,0x02,0x01,0x4C,0x5E,0x5B,0x17,0x6E,0x0C,0x16,0x68,0x5B,0x12]
flag=''
e='this_is_not_flag'
for i in range(42):
    flag+=chr(ord(e[i%16])^a[i])
print (flag)
</code></pre>
<h2 id="apk-逆向2">APK-逆向2</h2>
<h3 id="主函数-3">主函数</h3>
<p><img src="https://7usai.github.io/post-images/1600096069499.png" alt="" loading="lazy"><br>
大致意思是通过31337端口向主机发送flag</p>
<h3 id="python脚本">python脚本</h3>
<pre><code>import http.server

server_address = ('127.0.0.1', 31337)
handler_class = http.server.BaseHTTPRequestHandler
httpd = http.server.HTTPServer(server_address, handler_class)
httpd.serve_forever()
</code></pre>
<h3 id="结果">结果</h3>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600096078531.png" alt="" loading="lazy"></figure>
<h2 id="babymips">babymips</h2>
<p>需要配置JDK环境并且安装Ghidra</p>
<h3 id="主函数-4">主函数</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600096092065.png" alt="" loading="lazy"></figure>
<p>abStack44为输入的字符，之后进行32次异或：abStack44[i]=abStack44[i]^0x20-char[i]<br>
iVar1处转换后前5位是Q|j{g<img src="https://7usai.github.io/post-images/1600096112265.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600096100128.png" alt="" loading="lazy"></p>
<p>uStack16为偶数时相当于&lt;&lt;2|&gt;&gt;6为奇数时相当于&gt;&gt;2|&lt;&lt;6</p>
<h3 id="脚本-3">脚本</h3>
<pre><code>a=[0x51, 0x7C, 0x6A, 0x7B, 0x67,
  0x52, 0xFD, 0x16, 0xA4, 0x89, 0xBD, 0x92, 0x80, 0x13, 0x41,
  0x54, 0xA0, 0x8D, 0x45, 0x18, 0x81, 0xDE, 0xFC, 0x95, 0xF0,
  0x16, 0x79, 0x1A, 0x15, 0x5B, 0x75, 0x1F, 0x00]
flag=''
for i in range(5,32):
    if((i&amp;1)!=0):
        a[i]=a[i]&gt;&gt;6|(a[i]&lt;&lt;2)%0x100
    else:
        a[i]=(a[i]&lt;&lt;6)%0x100|a[i]&gt;&gt;2
for i in range(32):
    a[i]=a[i]^32-i
    flag+=chr(a[i])
print(flag)
</code></pre>
<p>注意这里的%0x100需要加上不然失败</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻防世界_re_2星题_部分wp]]></title>
        <id>https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/</id>
        <link href="https://7usai.github.io/post/gong-fang-shi-jie-re-bu-fen-wp/">
        </link>
        <updated>2020-09-10T14:38:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="攻防世界re部分wp">攻防世界RE部分wp</h1>
<h2 id="re2-cpp-is-awesome">re2-cpp-is-awesome</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599748738949.png" alt="" loading="lazy"></figure>
<p>64位ELF文件 放入ubuntu中运行结果如下</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599748743703.png" alt="" loading="lazy"></figure>
<p>放入IDA进入main函数</p>
<p><img src="https://7usai.github.io/post-images/1599748750390.png" alt="" loading="lazy"><br>
如下两个 一个正确一个错误</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599748769934.png" alt="" loading="lazy"></figure>
<p>通过分析可得</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599748776529.png" alt="" loading="lazy"></figure>
<p>V12与off_6020A0和dword_6020C0组成的数组比较，相同则得flag</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599748784955.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599748790751.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599748796928.png" alt="" loading="lazy"></figure>
<p>得到所需数值后编写函数</p>
<pre><code>a=[0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2d,0x01,0x03,0x00,0x0d,0x56,0x01,0x03,0x65,0x03,0x2d,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2b]
flag=&quot; &quot;
x=&quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;
b=len(a)
for i in range(b):
    flag+=x[a[i]]
print(flag)
</code></pre>
<pre><code>得flag=ALEXCTF{W3_L0v3_C_W1th_CL45535}
</code></pre>
<h2 id="srm-50">srm-50</h2>
<p>主要部分如下</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599748819043.png" alt="" loading="lazy"></figure>
<p>if部分成立时得flag,说明flag长度为16位，前四位是CZ9d<br>
<img src="https://7usai.github.io/post-images/1599748824045.png" alt="" loading="lazy"><br>
V13<sub>V24组成其余12位，求出V12[4]</sub>V24即可</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599748829235.png" alt="" loading="lazy"></figure>
<p>编写代码</p>
<pre><code>a=[67,90,57,100,109,113,52,99,56,103,57,71,55,98,65,88]
flag=&quot; &quot;
for i in range(len(a)):
    flag+=chr(a[i])
print(flag)

</code></pre>
<pre><code>得flag为CZ9dmq4c8g9G7bAX
</code></pre>
<h2 id="guess-the-number">Guess-the-Number</h2>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599748835634.png" alt="" loading="lazy"></figure>
<p>转为zip解压后得<img src="https://7usai.github.io/post-images/1599748846528.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599748854085.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599748864158.png" alt="" loading="lazy"></figure>
<pre><code>import java.math.BigInteger;

class Untitled {
	public static void main(String[] args) {
          String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;
          String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;
		  BigInteger i1 = new BigInteger(str_one, 16);
   		  BigInteger i2 = new BigInteger(str_two, 16);
   		  BigInteger res = i1.xor(i2);
    	  String result = res.toString(16);
          System.out.printf(&quot;%s&quot;,result);
	}
}
得flag=a7b08c546302cc1fd2a4d48bf2bf2ddb
</code></pre>
<h3 id="收获第一次反编译java">收获：第一次反编译java</h3>
<h2 id="666">666</h2>
<p>主函数</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600000477839.png" alt="" loading="lazy"></figure>
<p>主要加密函数</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600000482916.png" alt="" loading="lazy"></figure>
<pre><code>a2=[0x69,0x7A,0x77,0x68,0x72,0x6F,0x7A,0x22,0x22,0x77,0x22,0x76,0x2E,0x4B,0x22,0x2E,0x4E,0x69]
flag=''
for i in range(0,18,3):
    flag += chr(18 ^ a2[i] - 6)
    flag += chr(18 ^ a2[i + 1] + 6)
    flag += chr(18 ^ a2[i+2] ^ 6)
print(flag)
</code></pre>
<p>编写代码，得flag</p>
<p>注：我python一直显示一个错误的flag<img src="https://7usai.github.io/post-images/1600000495622.png" alt="" loading="lazy"></p>
<p>c++代码如下：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
char i;
char target[]=&quot;izwhroz\&quot;\&quot;w\&quot;v.K\&quot;.Ni&quot;;
for(i=0;i&lt;18;i+=3){
    target[i]=(target[i]^18)-6;
    target[i+1]=(target[i+1]^18)+6;
    target[i+2]=(target[i+2]^18)^6;
}
puts(target);
return 0;
}
</code></pre>
<h2 id="2020913第一面完成">2020.9.13第一面完成</h2>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1600000504111.png" alt="" loading="lazy"></figure>
<h2 id="reverseme-120">ReverseMe-120</h2>
<h3 id="main函数">main函数</h3>
<p><img src="https://7usai.github.io/post-images/1600010757978.png" alt="" loading="lazy"><br>
大概思路是需要v9=0；v9=0的前提是v13=you_know_how_to_remove_junk_code；v13是经过异或的得到的，写脚本得之前的v13如下</p>
<pre><code>a='you_know_how_to_remove_junk_code'
b=''
c=len(a)
for i in range(c):
    b+=chr(ord(a[i])^37)
    print(b)
</code></pre>
<p>得到字符串\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@这里失去头绪</p>
<p>sub_401000函数没看懂；但是查看字符串发现<img src="https://7usai.github.io/post-images/1600010779978.png" alt="" loading="lazy"><br>
猜测是base64;</p>
<p>在线加密后得XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=，即为flag</p>
<h2 id="reversing-x64elf-100">Reversing-x64Elf-100</h2>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1600010785917.png" alt="" loading="lazy"></figure>
<h3 id="主函数">主函数</h3>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1600010790350.png" alt="" loading="lazy"></figure>
<h3 id="关键函数">关键函数</h3>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1600010796725.png" alt="" loading="lazy"></figure>
<h3 id="思路">思路</h3>
<p>flag存在a1数组里，逆向进行if里得运算就行<br>
编写脚本</p>
<pre><code>v3 = [&quot;Dufhbmf&quot;,&quot;pG`imos&quot;,&quot;ewUglpt&quot;]
flag=''
for i in range(12):
    flag+=chr(ord(v3[(i % 3)][2 * int(i / 3)])-1)
    print(flag)
</code></pre>
<pre><code>v3[a][b]的意思
a表示下标为a的字符串，b表示此字符串中下标为b的字符
</code></pre>
<h2 id="igniteme">IgniteMe</h2>
<h3 id="main函数-2">main函数</h3>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1600010801875.png" alt="" loading="lazy"></figure>
<h3 id="进入4011c0">进入4011C0</h3>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1600010805986.png" alt="" loading="lazy"></figure>
<p>这里byte_4420B0我简单的用一个a表示<img src="https://7usai.github.io/post-images/1600010832666.png" alt="" loading="lazy"></p>
<h3 id="编写脚本">编写脚本</h3>
<pre><code>v7=&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;
a=[0x0D,0x13 ,0x17 ,0x11 ,0x02 ,0x01 ,0x20 ,0x1D,0x0C ,0x02 ,0x19 ,0x2F ,0x17 ,0x2B ,0x24 ,0x1F,0x1E ,
   0x16 ,0x09 ,0x0F ,0x15 ,0x27 ,0x13 ,0x26 ,0x0A ,0x2F ,0x1E ,0x1A ,0x2D ,0x0C ,0x22 ,0x04]
v5=''
eflag=''
for i in range(len(v7)):
    v5+=chr(ord(v7[i])^a[i])
for i in range(len(v5)):
    eflag+=chr((ord(v5[i])-72)^0x55)
    print(eflag)
</code></pre>
<p>这里注意最后得到的flag值需要大小写转换，因为懒没写代码</p>
<p>在网上找的代码如下</p>
<pre><code>for i in range(len(eflag)):
    if ord(eflag[i]) &gt;= 97 and ord(eflag[i]) &lt;= 122:
        flag += chr(ord(eflag[i]) - 32)
    elif ord(eflag[i]) &gt;= 65 and ord(eflag[i]) &lt;= 90:
        flag += chr(ord(eflag[i]) + 32)
    else:
        flag += eflag[i]
</code></pre>
<p>再与<img src="https://7usai.github.io/post-images/1600010822260.png" alt="" loading="lazy">连接，得flag=EIS{wadx_tdgk_aihc_ihkn_pjlm}</p>
<h2 id="总结">总结</h2>
<p>二星题还是很简单的，部分题目自己觉得没有学习意义就没写wp</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrambled Eggs (csictf 2020) 转载！！]]></title>
        <id>https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/</id>
        <link href="https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/">
        </link>
        <updated>2020-09-09T15:40:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="scrambled-eggs-csictf-2020-转载自httpsctftimeorg">Scrambled Eggs (csictf 2020) 转载自https://ctftime.org/</h1>
<h2 id="转载-用于个人学习">转载！！！ 用于个人学习</h2>
<h2 id="challenge-description">Challenge description</h2>
<blockquote>
<p>I like my eggs sunny side up, but I ended up scrambling them.</p>
</blockquote>
<p>In this <strong>reversing</strong>/<strong>crypto</strong> challenge, we are provided with two files : [scrambledeggs.txt](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.txt) which contains two encrypted keys and the encrypted flag, and [scrambledeggs.py](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.py) the python script that was used to encrypt the flag.</p>
<p><strong>scrambledeggs.txt</strong> :</p>
<pre><code>Encrytped key1 = xtfsyhhlizoiyx                                                                                                                  
Encrypted key2 = eudlqgluduggdluqmocgyukhbqkx                                                                                                    
Encrypted flag = lvvrafwgtocdrdzfdqotiwvrcqnd
</code></pre>
<p><strong>scrambledeggs.py</strong> :</p>
<pre><code class="language-python">import random 
import sys

map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']

flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')

if(len(flag) != 28 or len(key1) != 14):
    exit()
    
flag = list(flag)
key1 = list(key1)


def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
    
flag = enc1(flag)
    
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp

key2 = enc2(enc2(key1))
key2 = list(key2)

for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
        

l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]

k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)

flag = ''.join(flag)
key1 = ''.join(key1)
key2 = ''.join(key2)
 
key2 = enc2(key2)
flag= enc1(enc1(enc1(enc2(flag))))

print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h2 id="approach-to-the-solution">Approach to the solution</h2>
<h3 id="understanding-the-script">Understanding the script</h3>
<p>After calmly reading and trying to understand the script above, we can summarize its steps as the following points :</p>
<ul>
<li>we start off with the assignment of <code>flag</code> and <code>key1</code> (which both are not the actual ones obviously)</li>
</ul>
<pre><code class="language-python">flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag = enc1(flag)
</code></pre>
<ul>
<li><code>key2</code> is assigned as the double encryption of <code>key1</code> using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(enc2(key1))
</code></pre>
<ul>
<li>then comes the big double loop, which simply makes a few swaps between the characters of <code>flag</code>, <code>key1</code> and <code>key2</code></li>
</ul>
<pre><code class="language-python">for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
</code></pre>
<ul>
<li>after that, there is a possibility that <code>key1</code> and <code>key2</code> are swapped</li>
</ul>
<pre><code class="language-python">l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]
</code></pre>
<ul>
<li>random characters are appended to <code>key2</code>, and using those characters <code>key2</code>'s characters are modified</li>
</ul>
<pre><code class="language-python">k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)
</code></pre>
<ul>
<li><code>key2</code> is encrypted using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(key2)
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc2</code> function, and then encrypted three times using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag= enc1(enc1(enc1(enc2(flag))))
</code></pre>
<ul>
<li>finally <code>key1</code>, <code>key2</code> and <code>flag</code> are printed</li>
</ul>
<pre><code class="language-python">print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h3 id="how-to-approach-this">How to approach this ?</h3>
<p>The general approach to take for this type of challenges is to first start by identifying and dividing the big individual problems/steps and come up with solutions for them if possible, then we procede to reverse each step starting from the bottom heading to the top, and we have to make sure to mark the steps where different values could come up, in our case, these are the steps where random values are used. Since we cannot guess those values, we use brute force by computing all the possible combinations.</p>
<p>So first, let's start by identifying the steps where brute force is needed and where not :</p>
<ul>
<li>the <code>enc1</code> function uses random values to determine where to split the <code>text</code> argument, that means brute force is required</li>
</ul>
<pre><code class="language-python">def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
</code></pre>
<ul>
<li>the <code>enc2</code> function simply maps characters from <code>text</code> to the <code>map</code> defined at the top of the script, so we can &quot;undo&quot; that</li>
</ul>
<pre><code class="language-python">map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp
</code></pre>
<ul>
<li>the big double loop looks daunting but it is easily reversible by litteraly reversing the steps</li>
<li>the key swapping is out of our control, we have to consider the two cases where <code>key1</code> and <code>key2</code> are swapped and when they are not</li>
<li>the part where random characters are mixed with <code>key2</code> aspires that we need to use brute force, but we will find out later that we can actually recover <code>key2</code> without using brute force</li>
</ul>
<h2 id="crafting-the-solution">Crafting the solution</h2>
<p>Now that we have identified the major steps of the encryption and the steps that require brute force, we can begin writing the solution. We will start off by writing some functions that will help us reverse some steps.</p>
<h3 id="reversing-enc1">reversing <code>enc1</code></h3>
<p>The <code>enc1</code> function generates first a random number <code>n</code> using <code>random.randint(0, sys.maxsize%28)</code>, <code>sys.maxsize</code> refers to the platform's pointer size, for 64-bit machines that's <code>2**63-1</code>, therefore, if we assume that the machine used to run the script is 64-bit <code>sys.maxsize%28</code> evaluates to <code>7</code>.</p>
<p>Since we can't guess the random numbers generated, we will simply define the reverse function <code>dec1</code> to take two arguments <code>text</code> and <code>n</code> :</p>
<pre><code class="language-python">def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]
</code></pre>
<p>Then in our main function, we will make sure to generate all the possible values for <code>n</code> (0 to 7)</p>
<h3 id="reversing-enc2">reversing <code>enc2</code></h3>
<p>On the other hand <code>enc2</code> is easily reversible by remapping the characters of <code>text</code> like this :</p>
<pre><code class="language-python">def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)
</code></pre>
<h3 id="unlooping">unlooping</h3>
<p>As stated before, we reverse the big double loop by simply reversing the steps, just like this :</p>
<pre><code class="language-python">def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)
</code></pre>
<h3 id="recovering-key2">recovering <code>key2</code></h3>
<p>We said before that the part where 14 random characters were mixed up with <code>key2</code> is reversible without brute force, that's because those random chars are appended to <code>key2</code> and not scrambled afterwards, so here are the steps to recover <code>key2</code> :</p>
<pre><code class="language-python">def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res
</code></pre>
<h3 id="wrapping-everything-up">Wrapping everything up</h3>
<p>In order to join everything we have been working on, we simply reverse the steps of the total encryption from bottom to top :</p>
<ol>
<li>Generate combinations of three <code>n</code>s (from 0 to 7)</li>
</ol>
<pre><code class="language-python">randsize = 7
combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
</code></pre>
<ol>
<li>Use the combinations to call <code>dec1</code> three times on the encrypted flag, and then call <code>dec2</code> (we can call <code>dec2</code> first since <code>dec1</code> doesn't change the characters of <code>text</code>)</li>
</ol>
<pre><code class="language-python">flag = dec2(eflag)
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
</code></pre>
<ol>
<li>Call <code>dec2</code> on the encrypted <code>key2</code></li>
</ol>
<pre><code class="language-python">key2 = dec2(ekey2)
</code></pre>
<ol>
<li>Recover <code>key2</code> using <code>recover_key2</code></li>
</ol>
<pre><code class="language-python">key2 = recover_key2(key2)
</code></pre>
<ol>
<li>Choose whether to swap <code>key1</code> and <code>key2</code> or not</li>
</ol>
<pre><code class="language-python">swapkeys = True
if swapkeys: key1, key2 = key2, key1
</code></pre>
<ol>
<li>Undo the big double loop using <code>unloop</code></li>
</ol>
<pre><code class="language-python">key1, key2, flag = unloop(key1, key2, flag)
</code></pre>
<ol>
<li>Since originally, before the loop, <code>key2</code> is equal to <code>enc2(enc2(key1))</code> we can check whether that is true to minimize the results</li>
</ol>
<pre><code class="language-python">if dec2(dec2(key2)) == key1:
</code></pre>
<ol>
<li>Once again we generate <code>n</code>s to decrypt <code>flag</code> with <code>dec1</code></li>
</ol>
<pre><code class="language-python">for n in range(randsize + 1):
    flag = dec1(flag, n)
    results.append(flag)
</code></pre>
<ol>
<li>Finally, we can store all the resulting flags in a file named &quot;results.txt&quot;, so that we can check out if it contains the actual correct flag</li>
</ol>
<pre><code class="language-python">outfile = 'results.txt'
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p><strong>Note</strong> : steps 3, 4 and 5 can be done before generating the combinations since those combinations affect only <code>flag</code></p>
<h3 id="the-main-function">The main function</h3>
<pre><code class="language-python">combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
key1 = ekey1
key2 = recover_key2(dec2(ekey2))
flag = dec2(eflag)
if swapkeys: key1, key2 = key2, key1
original = flag, key1, key2
results = []
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
    key1, key2, flag = unloop(key1, key2, flag)
    if dec2(dec2(key2)) == key1:
        for n in range(randsize + 1):
            flag = dec1(flag, n)
            results.append(flag)
    flag, key1, key2 = original
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p>The full script is [here](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/solve.py)</p>
<h2 id="unscrambled-eggs">Unscrambled Eggs</h2>
<p>On the first try, when <code>swapkeys</code> is set to <code>False</code>, &quot;results.txt&quot; turns out to be empty. But then after setting that to <code>True</code>, the file is quite populated, that could mean that we've been successful.</p>
<p><code>grep &quot;^csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep1.png" alt="grep &quot;^csictf&quot; results.txt" loading="lazy"></figure>
<p>Hmmm.. we get nothing</p>
<p><code>grep &quot;csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep2.png" alt="grep &quot;csictf&quot; results.txt" loading="lazy"></figure>
<p>Ah ! we get some results now, if we replace some <code>a</code>s and <code>b</code>s to <code>{</code>, <code>}</code> and <code>_</code> in <code>sacsictfaallbthebkingsbhorse</code> we can read <code>s}csictf{all_the_kings_horse</code>.</p>
<p>It is trivial now that the <strong>flag</strong> is :</p>
<pre><code>csictf{all_the_kings_horses}
</code></pre>
<h2 id="the-full-script">The full script</h2>
<pre><code>#!/usr/bin/env python3
import itertools

# encrypted key1, key2 and flag (from scrambledeggs.txt)
ekey1 = 'xtfsyhhlizoiyx'
ekey2 = 'eudlqgluduggdluqmocgyukhbqkx'
eflag = 'lvvrafwgtocdrdzfdqotiwvrcqnd'

scramble_map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
# result of the evaluation of (sys.maxsize % 28) for 64-bit machines
randsize = 7
# to choose whether or not to swap key1 and key2
swapkeys = True
# write the resulting flag combinations to a file
outfile = 'results.txt'

# reverse enc1, but provide n
def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]

# reverse enc2
def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)

# recover key2 from the encrypted key2 (the part where random chars are appended to key2)
def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res

# undo the big double loop
def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)

if __name__ == '__main__':
    # generate the combinations of 3 `n`s using itertools.product
    combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
    key1 = ekey1
    key2 = recover_key2(dec2(ekey2))
    flag = dec2(eflag)
    if swapkeys: key1, key2 = key2, key1
    original = flag, key1, key2
    results = []
    for c in combinations:
        flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
        key1, key2, flag = unloop(key1, key2, flag)
        if dec2(dec2(key2)) == key1:
            for n in range(randsize + 1):
                flag = dec1(flag, n)
                results.append(flag)
        flag, key1, key2 = original
    with open(outfile, 'w') as f:
        f.write('\n'.join(results))
        f.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTOJ部分题解(更新中)]]></title>
        <id>https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/</id>
        <link href="https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/">
        </link>
        <updated>2020-09-08T15:09:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大白just大白">大白just大白</h2>
<h3 id="题目描述">题目描述</h3>
<p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p>
<p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p>
<p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p>
<p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p>
<p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p>
<p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p>
<h3 id="输入">输入</h3>
<p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p>
<p>接下来m行，每行一个关键字（字符串）</p>
<p>再接下来n行字符串。m和n都不大于20</p>
<p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p>
<h3 id="输出">输出</h3>
<p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>2 3
love
cumt
ACM
ILoveCUMTACM
cumtAACM
2 2
A
b
Ab
bA
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>ILoveCUMTACM
Ab
</code></pre>
<h3 id="代码">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	int max= 21;
    int n,m,i,j;
    string nn[max],mm[max];
    string nn2[max],mm2[max];
    while(cin&gt;&gt;n&gt;&gt;m)
    {
   		for(int i=0;i&lt;m;i++)
		{
			cin&gt;&gt;mm[i];
			mm2[i]=mm[i];
			for(int j = 0; mm[i][j] != '\0'; j++)
            {
                mm[i][j] = tolower(mm[i][j]);
            }
            //cout&lt;&lt;mm[i]&lt;&lt;mm2[i]; 
		}
		for(int i=0;i&lt;n;i++)
		{
			cin&gt;&gt;nn[i];
			nn2[i]=nn[i];
			for(int j = 0; nn[i][j] != '\0'; j++)
            {
                nn[i][j] = tolower(nn[i][j]);
            }
            //cout&lt;&lt;nn[i];
		}
        int p=-1,q=-1,k;
        for(i = 0; i &lt; n; i++)
        {
            k= 0;
            for(j = 0; j &lt; m; j++)
            {
                string::size_type temp = nn[i].find(mm[j]);
                if(temp!=string::npos)
				k++;
            }
            if(k&gt;p)
            {
                p=k;
                q=i;
            }
        }
        cout&lt;&lt;nn2[q]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="小雏鸟的计算">小雏鸟的计算</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p>
<p>考虑以下的算法：<br>
\1.     输入 n<br>
\2.     印出 n<br>
\3.     如果 n = 1 结束<br>
\4.     如果 n 是奇数 那么 n=3*n+1<br>
\5.     否则 n=n/2<br>
\6.     GOTO 2<br>
例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>
据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>
给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>
问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p>
<h3 id="输入-2">输入</h3>
<p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。</p>
<p>0&lt; i，j &lt; 1000000</p>
<h3 id="输出-2">输出</h3>
<p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p>
<h3 id="样例输入-2">样例输入</h3>
<pre><code>1 10
10 1
100 200
201 210
900 1000
</code></pre>
<h3 id="样例输出-2">样例输出</h3>
<pre><code>1 10 20
10 1 20
100 200 125
201 210 89
900 1000 174
</code></pre>
<h3 id="代码-2">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int a;
void f(int x)
{
    if(x == 1) 
	return;
    if(x % 2) 
	x = 3*x+1;
    else 
	x /= 2;
    f(x);
    a++;
}
int count(int x)
{
    a = 1;
    f(x);
    return a;
}
int main()
{
    int l,r,l2,r2,max_;
    while(cin&gt;&gt;l&gt;&gt;r)
    {
    	l2=l;
    	r2=r;
        if(l2 &gt; r2)
		swap(l2,r2);
        max_ = 0;
        for(int i = l2; i &lt;= r2; i++)
            max_ = max(max_,count(i));
        cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;max_&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="排列问题">排列问题</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h3 id="输入-3">输入</h3>
<p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h3 id="输出-3">输出</h3>
<p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h3 id="样例输入-3">样例输入</h3>
<pre><code>abc,
</code></pre>
<h3 id="样例输出-3">样例输出</h3>
<pre><code>abc acb bac bca cab cba
</code></pre>
<h3 id="代码-3">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	string s;
	cin&gt;&gt;s;
	s=s.substr(0,s.length()-1);
	sort(s.begin(),s.end());
	cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	while(next_permutation(s.begin(),s.end()))
	{
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	}
	return 0;
}
</code></pre>
<h2 id="快速幂">快速幂</h2>
<h3 id="题目描述-4">题目描述</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599577873521.png" alt="" loading="lazy"></figure>
<h3 id="输入-4">输入</h3>
<p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h3 id="输出-4">输出</h3>
<p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h3 id="样例输入-4">样例输入</h3>
<pre><code>3
4
5
</code></pre>
<h3 id="样例输出-4">样例输出</h3>
<pre><code>33
289
3414
</code></pre>
<h3 id="代码-4">代码</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
long long n=100000007;
long long poww(long long a, long long b)// return a ^ b
{
	long long ans = 1;
	while(b != 0)
	{
		if(b&amp;1 != 0) 
		ans = ans * a % n;
		a = a * a %n;
		b&gt;&gt;=1;
	}
return ans;
}
int main()
{
	int x;
	while(cin&gt;&gt;x)
	{
		long long y=0;
		for(int i=1;i&lt;=x;i++)
		y+=poww(i,i);
		cout&lt;&lt;(y+1)%n&lt;&lt;endl;
	}
	return 0;
} 
</code></pre>
<h2 id="求第k小">求第k小</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h3 id="输入-5">输入</h3>
<p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h3 id="输出-5">输出</h3>
<p>输出一行，输出第k小数。</p>
<h3 id="样例输入-5">样例输入</h3>
<pre><code>5 2
1 5 3 2 4
</code></pre>
<h3 id="样例输出-5">样例输出</h3>
<pre><code>2
</code></pre>
<h3 id="代码-5">代码</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int a[1000001];
void swap(int &amp;a, int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}
int partition(int arr[], int left, int right)  //找基准数 划分
{
    int i = left + 1 ;
    int j = right;
    int temp = arr[left];
 
    while(i &lt;= j)
    {
        while (arr[i] &lt; temp)
        {
            i++;
        }
        while (arr[j] &gt; temp )
        {
            j--;
        }
        if (i &lt; j)
            swap(arr[i++], arr[j--]);
        else i++;
   }
    swap(arr[j], arr[left]);
    return j; 
}
void quicksort(int a[],int left,int right)
{
	if(left &lt; right)
	{
		int j= partition(a, left, right);
	    quicksort(a, left, j - 1);
		quicksort(a, j + 1, right);	
	}
}
int main()
{
	int n, k;
	cin &gt;&gt; n;
	cin &gt;&gt; k; 
	for(int i = 0; i &lt; n; i++)
		cin &gt;&gt; a[i];
	quicksort(a, 0, n-1);
	cout &lt;&lt; a[k - 1] &lt;&lt; endl;
	return 0;	
}
</code></pre>
<h2 id="沙子的质量dp题">沙子的质量(dp题)</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h3 id="输入-6">输入</h3>
<p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h3 id="输出-6">输出</h3>
<p>合并的最小代价。</p>
<h3 id="样例输入-6">样例输入</h3>
<pre><code>4
1 3 5 2
</code></pre>
<h3 id="样例输出-6">样例输出</h3>
<pre><code>22
</code></pre>
<h3 id="代码-6">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int main()
{
	int dp[300][300];
    int n,i,j,k,a[300],sum[300] = {0};
   	//cout&lt;&lt;sizeof(dp);
	memset(dp,1,sizeof(dp));
    cin&gt;&gt;n;
    for(i = 1; i &lt;= n; i++)
    {
        cin&gt;&gt;a[i];
        sum[i] = sum[i-1]+a[i];
        dp[i][i] = 0;
    }
    for(i = 2; i &lt;= n; i++)
    {
        for(j = i; j &gt;= 1; j--)
        {
            for(k = j; k &lt;= i; k++)
                dp[j][i] = min(dp[j][i],dp[j][k]+dp[k+1][i]+sum[i]-sum[j-1]);
        }
    }
    cout&lt;&lt;dp[1][n];
    return 0;
}
</code></pre>
<h2 id="最长公共子序列dp题">最长公共子序列(dp题)</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad&quot; ,顺次选1，3，5个字符就构成子串&quot; cad&quot; ,现给定两个字符串，求它们的最长共公子串。</p>
<h3 id="输入-7">输入</h3>
<p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h3 id="输出-7">输出</h3>
<p>最长子串的长度。</p>
<h3 id="样例输入-7">样例输入</h3>
<pre><code>abccd aecd
</code></pre>
<h3 id="样例输出-7">样例输出</h3>
<pre><code>3
</code></pre>
<h3 id="代码-7">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int dp[2000][2000]; 
int main()
{
	int len1,len2,i,j;
    char a[2000],b[2000];
    cin&gt;&gt;a&gt;&gt;b;
    len1 = strlen(a);
	len2 = strlen(b);
    for( i = 1; i &lt;= len1; i++)
    {
        for( j = 1; j &lt;= len2; j++)
        {
            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout&lt;&lt;dp[len1][len2];
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RE学习]]></title>
        <id>https://7usai.github.io/post/re-xue-xi/</id>
        <link href="https://7usai.github.io/post/re-xue-xi/">
        </link>
        <updated>2020-09-02T11:44:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="逆向软件基础">逆向软件基础</h1>
<p>debug版本较大、带调试信息，release版本优化程序、程序更小</p>
<h2 id="od快捷键">OD快捷键</h2>
<pre><code>F2 下断点
F3 加载一个可执行程序
F4 程序执行到光标处
F5 缩小、还原当前窗口
F7 单步步入
F8 单步步过
F9 直接运行程序，遇到断点处，程序暂停
Ctrl + F2 重新运行程序到起始处
Ctrl + F9 执行到函数返回处，用于跳出函数实现
Ctrl + G 输入十六进制地址，快速定位到该地址处
Ctrl + N 应用程序的输入表
Alt + B 显示断点窗口
Alt + C 显示 CPU 窗口
Alt + F9 执行到用户代码处，用于快速跳出系统函数
Ctrl+j跳转main函数
</code></pre>
<h2 id="寻找main函数od">寻找main函数(OD)</h2>
<p>1.寻找参考字符串<br>
2.main函数特点：3个push、1个call,F7进入。<br>
3.API寻找<br>
4.IDA</p>
<h2 id="修改内存中的数据">修改内存中的数据</h2>
<p>1.OD:右键-&gt;二进制-&gt;编辑<br>
2.修改PUSH的地址以及该地址中的数据</p>
<h2 id="修改跳转">修改跳转</h2>
<p>1.修改关键跳转<br>
2.修改对比值</p>
<h2 id="滑板指令">滑板指令</h2>
<p>nop/90； 作用：把自己过掉执行下一句</p>
<h2 id="初级破解">初级破解</h2>
<h3 id="找到main函数所在位置">找到main函数所在位置</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599047100466.png" alt="" loading="lazy"></figure>
<h3 id="整体main函数">整体main函数</h3>
<pre><code>00181080  /$  55            push ebp
00181081  |.  8BEC          mov ebp,esp
00181083  |.  83EC 38       sub esp,0x38
00181086  |.  A1 04F01900   mov eax,dword ptr ds:[0x19F004]
0018108B  |.  33C5          xor eax,ebp
0018108D  |.  8945 FC       mov [local.1],eax
00181090  |.  68 A8D61900   push 05.0019D6A8
00181095  |.  E8 86FFFFFF   call 05.00181020
0018109A  |.  6A 32         push 0x32
0018109C  |.  8D45 C8       lea eax,[local.14]
0018109F  |.  6A 00         push 0x0
001810A1  |.  50            push eax
001810A2  |.  E8 790D0000   call 05.00181E20
001810A7  |.  8D45 C8       lea eax,[local.14]
001810AA  |.  50            push eax
001810AB  |.  68 B8D61900   push 05.0019D6B8                         ;  &quot;%s&quot;
001810B0  |.  E8 9BFFFFFF   call 05.00181050
001810B5  |.  8B45 C8       mov eax,[local.14]
001810B8  |.  33D2          xor edx,edx
001810BA  |.  83C4 18       add esp,0x18
001810BD  |.  3C 72         cmp al,0x72
001810BF  |.  0F94C2        sete dl
001810C2  |.  80FC 6B       cmp ah,0x6B
001810C5  |.  8D4A 01       lea ecx,dword ptr ds:[edx+0x1]
001810C8  |.  0F45CA        cmovne ecx,edx
001810CB  |.  807D CA 76    cmp byte ptr ss:[ebp-0x36],0x76
001810CF  |.  8D41 01       lea eax,dword ptr ds:[ecx+0x1]
001810D2  |.  0F45C1        cmovne eax,ecx
001810D5  |.  807D CB 69    cmp byte ptr ss:[ebp-0x35],0x69
001810D9  |.  8D48 01       lea ecx,dword ptr ds:[eax+0x1]
001810DC  |.  0F45C8        cmovne ecx,eax
001810DF  |.  807D CC 72    cmp byte ptr ss:[ebp-0x34],0x72
001810E3  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]
001810E6  |.  0F45D1        cmovne edx,ecx
001810E9  |.  807D CD 00    cmp byte ptr ss:[ebp-0x33],0x0
001810ED  |.  8D42 01       lea eax,dword ptr ds:[edx+0x1]
001810F0  |.  0F45C2        cmovne eax,edx
001810F3  |.  83F8 05       cmp eax,0x5
001810F6  |.  76 07         jbe short 05.001810FF
001810F8  |.  68 BCD61900   push 05.0019D6BC                         ;  ASCII 6C,&quot;ogin sucess!\n&quot;
001810FD  |.  EB 05         jmp short 05.00181104
001810FF  |&gt;  68 CCD61900   push 05.0019D6CC                         ;  ASCII 6C,&quot;ogin failed!\n&quot;
00181104  |&gt;  E8 17FFFFFF   call 05.00181020
00181109  |.  83C4 04       add esp,0x4
0018110C  |.  68 DCD61900   push 05.0019D6DC                         ;  ASCII 70,&quot;ause&quot;
00181111  |.  E8 892A0000   call 05.00183B9F
00181116  |.  8B4D FC       mov ecx,[local.1]
00181119  |.  83C4 04       add esp,0x4
0018111C  |.  33CD          xor ecx,ebp
0018111E  |.  33C0          xor eax,eax
00181120  |.  E8 04000000   call 05.00181129
00181125  |.  8BE5          mov esp,ebp
00181127  |.  5D            pop ebp                                  ;  05.001812F1
00181128  \.  C3            retn

</code></pre>
<p>单步调试一遍</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599047110988.png" alt="" loading="lazy"></figure>
<p>到这个位置显示请输入密码，随便敲一串字符继续调试</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599047118404.png" alt="" loading="lazy"></figure>
<p>调试到此处显示登录失败</p>
<h3 id="破解方法">破解方法</h3>
<h4 id="方法1修改跳转">方法1：修改跳转</h4>
<p>经过初次调试可知00181020为printf，并添加各行作用注释</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599047124421.png" alt="" loading="lazy"></figure>
<p>意思为eax&gt;5时，即上述对比字符串都相同时登录成功输出login success；<br>
过程：eax&gt;5，不执行jbe跳转，将login success压栈，跳转到call print函数位置；</p>
<p><img src="https://7usai.github.io/post-images/1599047131428.png" alt="" loading="lazy"><br>
修改后我们让它直接跳转到压栈位置。</p>
<h4 id="方法2修改关键字">方法2：修改关键字</h4>
<p>这里我们可知关键值时为eax，eax与5比较，大于5时才输出login success</p>
<p><img src="https://7usai.github.io/post-images/1599047137396.png" alt="" loading="lazy"><br>
我们在这里将eax值修改为大于5的数</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599047146195.png" alt="" loading="lazy"></figure>
<h4 id="方法3分析得password">方法3：分析得password</h4>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599047156075.png" alt="" loading="lazy"></figure>
<p>我们在这里可知，与0x72,0x6B,0x76,0x69,0x72,0x0做了对比相同则登录成功，于是密码为</p>
<p>思路：push eax 将输入的值存入了eax，ecx,edx两个中间值辅助eax+1.<br>
<img src="https://7usai.github.io/post-images/1599047162183.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599047167384.png" alt="" loading="lazy"></figure>
<p>得到密码rkvir，成功</p>
<h4 id="方法4修改对比值">方法4：修改对比值</h4>
<p>即修改0x72,0x6B,0x76,0x69,0x72，让其与我们输入的值相同，即将我们输入的值变成password。</p>
<p>假如我们输入7usai就要改成0x37,0x75,0x73,0x61,0x69</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599047173916.png" alt="" loading="lazy"></figure>
<p>登录成功</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599047179674.png" alt="" loading="lazy"></figure>
<h2 id="mfc破解初试">MFC破解初试</h2>
<h3 id="初始界面">初始界面</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599295190085.png" alt="" loading="lazy"></figure>
<h3 id="修改跳转-2">修改跳转</h3>
<p><img src="https://7usai.github.io/post-images/1599295199199.png" alt="" loading="lazy"><br>
rkvir为密码已经可以看出，双击紫色行进入<br>
<img src="https://7usai.github.io/post-images/1599295206191.png" alt="" loading="lazy"><br>
修改跳转<br>
<img src="https://7usai.github.io/post-images/1599295211864.png" alt="" loading="lazy"></p>
<h3 id="修改密码">修改密码</h3>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599295219313.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599295225417.png" alt="" loading="lazy"></figure>
<h2 id="初试破解crakeme">初试破解CrakeMe</h2>
<p><img src="https://7usai.github.io/post-images/1599295232305.png" alt="" loading="lazy"><br>
需要弹出下面的消息框</p>
<h3 id="改跳转">改跳转</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1599295239334.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1599295245091.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web学习]]></title>
        <id>https://7usai.github.io/post/web-xue-xi/</id>
        <link href="https://7usai.github.io/post/web-xue-xi/">
        </link>
        <updated>2020-08-30T07:16:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="web学习">web学习</h1>
<h2 id="web常见术语">web常见术语</h2>
<h3 id="渗透测试">渗透测试</h3>
<p>渗透测试：是为了证明网络防御按照预期计划正常运行而提供的一种机制。不妨假设，你的公司定期更新安全策略和程序，时时给系统打补丁，并采用了漏洞扫描器等工具，以确保所有补丁都已打上。如果你早已做到了这些，为什么还要请外方进行审查或渗透测试呢？因为，渗透测试能够独立地检查你的网络策略，换句话说，就是给你的系统安了一双眼睛。而且，进行这类测试的，都是寻找网络系统安全漏洞的专业人士。</p>
<p>参考资料：https://baike.baidu.com/item/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95</p>
<h3 id="网站">网站</h3>
<p>网站：(Website)是指在因特网上根据一定的规则，使用HTML（标准通用标记语言）等工具制作的用于展示特定内容相关网页的集合。简单地说，网站是一种沟通工具，人们可以通过网站来发布自己想要公开的资讯，或者利用网站来提供相关的网络服务。人们可以通过网页浏览器来访问网站，获取自己需要的资讯或者享受网络服务。<br>
网站是在互联网上拥有域名或地址并提供一定网络服务的主机，是存储文件的空间，以服务器为载体。人们可通过浏览器等进行访问、查找文件，也可通过远程文件传输(FTP)方式上传、下载网站文件。</p>
<p>参考资料：https://baike.baidu.com/item/%E7%BD%91%E7%AB%99/155722</p>
<h3 id="网站分类">网站分类</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1598772667836.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th><strong>静态网站</strong></th>
<th><strong>动态网站</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>每次加载页面时，预建内容都是相同的。</td>
<td>内容快速生成并定期更改。</td>
</tr>
<tr>
<td>它使用HTML代码开发。</td>
<td>它使用诸如PHP，JSP和ASP.NET等服务器端语言来开发网站。</td>
</tr>
<tr>
<td>它为每个请求发送完全相同的响应。</td>
<td>它可能会为每个请求生成不同的HTML。</td>
</tr>
<tr>
<td>仅当有人发布和更新文件(将其发送到Web服务器)时，内容才会更改。</td>
<td>页面包含“服务器端”代码，代码允许服务器在加载页面时生成唯一内容。</td>
</tr>
<tr>
<td>灵活性是静态网站的主要优势。</td>
<td>内容管理系统(CMS)是动态网站的主要优势。</td>
</tr>
</tbody>
</table>
<h3 id="cms">CMS</h3>
<p>CMS:就是模板</p>
<h3 id="脚本语言">脚本语言</h3>
<p>脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</p>
<p>常见的脚本语言：<br>
PHP<br>
JavaScript</p>
<p>数据库</p>
<p>数据库：是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。</p>
<p>常见的数据库：<br>
mysql 、SQL Server、Oracle、DB2、ACCESS</p>
<h3 id="http请求">HTTP请求</h3>
<p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：（1）请求方法URI协议/版本（2）　请求头(Request Header)（3）　请求正文</p>
<h3 id="html">html</h3>
<p>HTML：称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。</p>
<h3 id="javascript">JavaScript</h3>
<p>JavaScript：（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<p>注意：<br>
java和javascript外形字母非常像，但是二者是完全不同的二种语言。形象说，二者关系就和雷锋和雷峰塔关系一样。</p>
<p>参考资料：<br>
https://baike.baidu.com/item/javascript</p>
<h3 id="php">PHP</h3>
<p>PHP：“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。</p>
<h2 id="web组件">web组件</h2>
<p>Web组件是指对 Web 的数据和方法进行封装实体，可以包含 JavaBean 组件，从而方便地进行业务逻辑的处理<br>
https://python.freelycode.com/contribution/detail/1506</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1598772682704.png" alt="" loading="lazy"></figure>
<h3 id="自定义元素">自定义元素</h3>
<pre><code>自定义元素是HTML元素，像&lt;div&gt;, &lt;section&gt; 或&lt;article&gt;，但是我们可以自己对通过浏览器API定义的元素进行命名。自定义元素就像那些标准的HTML元素一样——名称用尖括号括起来——只不过它们总是有一个破折号，比如&lt;news-slider&gt; 或 &lt;bacon-cheeseburger&gt;。展望未来，浏览器厂商已承诺不再创建新的包含一个破折号的内置元素，以防止冲突。
自定义元素包含自己的语义、行为、标记，可以跨框架和浏览器共享。
</code></pre>
<h3 id="影子dom">影子DOM</h3>
<pre><code>影子DOM是DOM的一个封装版本。这允许作者有效地将DOM片段彼此隔离，包括可以用作CSS选择器的任何东西以及与它们关联的样式。通常，文档范围内的任何内容都称为 light DOM，影子根内的任何内容都称为影子DOM。
使用light DOM时，可以使用document.querySelector('selector')来选择元素，也可以使用element. queryselector ('selector')来选择任何元素的子元素；同样，可以通过调用shadowRoot.querySelector来锁定影子根的子节点,其中shadowRoot是对文档片段的引用——不同之处在于，影子根的子元素不能从light DOM中选择。例如，如果我们有一个包含&lt;button&gt;的影子根，调用shadowRoot.querySelector('button')将返回我们的按钮，但是没有一个文档查询选择器（document’s query selector）的调用会返回该元素，因为它属于另一个不同的DocumentOrShadowRoot实例。样式选择器也以同样的方式工作。
在这方面，影子DOM的工作方式有点像 &lt;iframe&gt;，它里边的内容会与文档的其他内容切割开；但是，当我们创建一个阴影根时，我们仍然可以完全控制页面的这一部分，但是范围仅限于上下文。这就是我们所说的封装。
如果你曾经编写过重用相同id，或者依赖于CSS-in- js工具或CSS命名策略(如BEM) 的组件，那么影子DOM有可能改善你的开发体验。
</code></pre>
<h3 id="html模板">HTML模板</h3>
<pre><code>HTML&lt;template&gt;元素允许我们在一个正常的HTML流中剔除可重用的代码模板，这些模板不会立即渲染，但是可以在稍后使用。

HTML导入：将HTML文档导入其他文档的声明方法
</code></pre>
<h2 id="html-2">HTML</h2>
<pre><code>&lt;!DOCTYPE HTML&gt;	声明该代码是由html5编写
&lt;html&gt;

&lt;head&gt;
&lt;title&gt;标题&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
主体
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;

&lt;head&gt;
&lt;title&gt;第一个程序&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
hello world!
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="常用的几个标签">常用的几个标签</h3>
<pre><code>&lt;h1&gt;一级大标题&lt;/h1&gt;
&lt;p&gt;用于存放一段文字&lt;/p&gt;
&lt;b&gt;加粗文字&lt;/b&gt;
&lt;i&gt;斜体文字&lt;/i&gt;
&lt;br /&gt;换行
&lt;a href=”https://www.baidu.com/”&gt;百度&lt;/a&gt;超级链接
&lt;img src=”1.jpg”&gt;包含图片

&lt;form method=&quot;get&quot;&gt;声明传入方式
  Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  Password: &lt;input type=&quot;passwod&quot; name=&quot;password&quot; /&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h2 id="javascript-2">JavaScript</h2>
<h3 id="javascript-和-html-以及-css的区别">JavaScript 和 HTML 以及 CSS的区别</h3>
<p>HTML：提供网页的结构，提供网页中的内容<br>
CSS: 用来美化网页<br>
JavaScript: 可以用来控制网页内容，给网页增加动态的效果</p>
<p>参考资料：<br>
https://www.w3school.com.cn/js/index.asp</p>
<h3 id="javascript组成">JavaScript组成</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1598772698026.png" alt="" loading="lazy"></figure>
<h3 id="ecmascript核心">ECMAScript（核心）</h3>
<p>定义了JavaScript的语法规范<br>
是JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</p>
<h3 id="bom浏览器对象模型">BOM（浏览器对象模型）</h3>
<p>一套操作浏览器功能的API<br>
通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等</p>
<h3 id="dom文档对象模型">DOM（文档对象模型）</h3>
<p>一套操作页面元素的API<br>
DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作</p>
<h3 id="javascript-的书写格式">JavaScript 的书写格式</h3>
<pre><code>第一种，例如：
&lt;input type=&quot;button&quot; value=&quot;按钮&quot; onclick=&quot;alert('Hello World')&quot; /&gt;

第二种，例如：
  &lt;script&gt;
    alert('Hello World!');
  &lt;/script&gt;

第三种，例如：
&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
注意：引用外部js文件的script标签中不可以写JavaScript代码
</code></pre>
<h3 id="输出">输出</h3>
<p>javascript 没有任何打印或输出的函数<br>
可以通过不同的方式输出数据</p>
<p>使用window.alert() 弹出警告框<br>
使用document.write()方法将内容写到html文档中<br>
使用document.getElementById(&quot;&quot;).innerHtml=&quot;需要写入的值&quot;; 写入到HTML元素<br>
使用console.log()写入到浏览器的控制台</p>
<h3 id="输出四种方法示例">输出四种方法示例：</h3>
<pre><code>&lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt;
&lt;script&gt;
	var a=1;
	var b=2;
	if(a&gt;b){
		window.alert(a);
		document.write(a);
		console.log(a);
		document.getElementById(&quot;demo&quot;).innerHTML=a;
	}else{
		console.log(b);
		document.write(b);
		window.alert(b);
		document.getElementById(&quot;demo&quot;).innerHTML=b;
	}
	//alert(a);
	&lt;/script&gt;

</code></pre>
<h3 id="基本语法变量">基本语法：变量</h3>
<p>使用var声明变量，例如：</p>
<pre><code>&lt;script&gt;
	var a=1;
	alert(a);
&lt;/script&gt;

</code></pre>
<p>命名规范：<br>
由字母、数字、下划线、$符号组成，不能以数字开头<br>
不能是关键字和保留字，例如：for、while。<br>
区分大小写</p>
<h3 id="if语句">if语句</h3>
<pre><code>&lt;script&gt;
	var a=1;
	var b=2;
	if(a&gt;b){
		alert(a);
	}else{
		alert(b);
	}
&lt;/script&gt;
</code></pre>
<h3 id="for语句">for语句</h3>
<pre><code>for (初始化表达式1; 判断表达式2; 自增表达式3) {
  // 循环体4
}


for(var i=1;i&lt;10;i++){
		document.write(i);
}

</code></pre>
<h2 id="sql">SQL</h2>
<h3 id="information_schema">information_schema</h3>
<p>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息</p>
<p>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。<br>
TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个数据库中所有表的信息。<br>
COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。</p>
<h3 id="mysql">MYSQL</h3>
<p>user表是存放该mysql数据库中所有用户名跟密码的表</p>
<h3 id="select">select</h3>
<p>select语句是查询语句。<br>
例如：<br>
1.查询test数据库中users表中所有的数据。<br>
select * from test.users;<br>
2.查询test数据库中users表中username列中的数据。<br>
select username from test.users;<br>
3.查询test数据库中users表中id为1的数据。<br>
select * from test.users where id=1;<br>
4.查询test数据库中users表中address为china而且username为zhangsan的数据。<br>
select * from test.users where address='china' and username='zhangsan';</p>
<h3 id="order-by">order by</h3>
<p>排序功能<br>
例如：<br>
1.查询test数据库中users表中所有的数据并按照第一列进行排序。<br>
select * from test.users order by 1;<br>
2.查询test数据库中users表中所有的数据并按照第二列进行排序。<br>
select * from test.users order by 2;<br>
3.查询test数据库中users表中所有的数据并按照第三列进行排序。<br>
select * from test.users order by 3;</p>
<h3 id="union">union</h3>
<p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。<br>
例如：<br>
1.查询test数据库中users中username列的数据并查询person表中username列中的数据。<br>
select username from test.users union select username from test.person;</p>
<h3 id="insert语句">insert语句</h3>
<p>INSERT INTO SQL语句来插入数据</p>
<p>例如：在test数据库person表中插入一条数据：username是lisi，money是100<br>
insert into person (username,money) values ('lisi','100')</p>
<h2 id="php-2">PHP</h2>
<h3 id="第一个程序hello-world">第一个程序：hello world！</h3>
<pre><code>&lt;?php
echo ‘Hello world!’;
php&gt;

</code></pre>
<h3 id="变量的命名">变量的命名</h3>
<p>变量以 $ 符号开头，其后是变量的名称<br>
变量名称必须以字母或下划线开头<br>
变量名称不能以数字开头<br>
变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）可以有汉字<br>
变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</p>
<h3 id="运算符">运算符</h3>
<pre><code>+-*/
&gt;
&lt;
=
&lt;=
&gt;=
!=
==
</code></pre>
<h3 id="if">if</h3>
<pre><code>$sex = '男'
if ($sex == '男'){
echo '哥们';
}else{
echo '姐们';
}
</code></pre>
<h3 id="while">while</h3>
<pre><code>while($id &lt;= 10){
echo '不够';
$id = $id+1;
}
</code></pre>
<h3 id="for">for</h3>
<pre><code>for($id=1;$id&lt;=10;$id++){
echo '不够';
}
</code></pre>
<h3 id="打印1-100">打印1-100</h3>
<pre><code>方法一：
$id = 1;
while($id &lt;= 100){
echo $id,'&lt;br /&gt;';
$id = $id+1;
}
方法二：
for ($id =1;$id &lt;= 100;$id++)
    echo $id,'&lt;br /&gt;';
</code></pre>
<h3 id="数组">数组</h3>
<pre><code>$arr = array('1' =&gt; '张三' , '2' =&gt; '李四');
print_r($arr);
echo '&lt;hr /&gt;';
echo $arr[1];
</code></pre>
<h3 id="_get">$_GET</h3>
<pre><code>header(&quot;Content-type: text/html; charset=utf-8&quot;);
$id = $_GET['id'];
echo '我是第'.$id.'号程序员';
</code></pre>
<h3 id="_post">$_POST</h3>
<pre><code>header(&quot;Content-type: text/html; charset=utf-8&quot;);
$id = $_POST['id'];
echo '我是第'.$id.'号程序员';
</code></pre>
<h3 id="mysqli_connect">Mysqli_connect()</h3>
<pre><code>$conn = mysqli_connect('127.0.0.1','root','root','test');
</code></pre>
<h3 id="mysqli_query">Mysqli_query</h3>
<pre><code>mysqli_query() 函数执行一条 MySQL 查询。
$result = mysqli_query($con,$sql);
</code></pre>
<h3 id="mysqli_fetch_array">Mysqli_fetch_array</h3>
<pre><code>mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有
返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。

$row = mysqli_fetch_array($result)
</code></pre>
<h2 id="whois查询">whois查询</h2>
<p>whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。</p>
<h3 id="查询途径">查询途径</h3>
<p>1.爱站工具网（https://whois.aizhan.com/）<br>
2.站长之家（http://whois.chinaz.com）<br>
3.VirusTotal（ https://www.virustotal.com ）</p>
<p>根据ICANN公布的《通用顶级域名注册数据临时政策细则》和欧盟通用数据保护条例合规要求，全面调整 WHOIS 公开显示的信息。</p>
<p>即：注册商提供WHOIS查询公开信息中将不再显示域名注册人、管理联系人和技术联系人的个人数据，包括姓名、邮箱、电话、街道地址等，只会显示注册商及到期日期等。而且该调整已于2018年5月25日开始生效。</p>
<h2 id="备案信息查询">备案信息查询</h2>
<p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部 门申请的 备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经 营活动的发生</p>
<p>注意：主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案</p>
<h3 id="常用的查询网站">常用的查询网站</h3>
<p>ICP备案查询网：http://www.beianbeian.com/<br>
天眼查：https://beian.tianyancha.com/</p>
<p>站长工具：http://icp.chinaz.com/<br>
工业和信息化部：http://www.beian.miit.gov.cn/</p>
<h2 id="收集敏感信息">收集敏感信息</h2>
<h3 id="谷歌语法">谷歌语法</h3>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1598957444700.png" alt="" loading="lazy"></figure>
<h4 id="举例">举例</h4>
<p>学校网站的后台<br>
Site:edu.cn intext:后台管理</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1598957452119.png" alt="" loading="lazy"></figure>
<h3 id="burp查询服务器的某些信息">Burp查询服务器的某些信息</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1598957458913.png" alt="" loading="lazy"></figure>
<h3 id="ip地址">IP地址</h3>
<p>ping指令</p>
<h3 id="网站指纹识别">网站指纹识别</h3>
<p>BugScaner：http://whatweb.bugscaner.com/look/<br>
云悉指纹：http://www.yunsee.cn/finger.html<br>
WhatWeb：https://whatweb.net/</p>
<h3 id="网站容器">网站容器</h3>
<p>nmap, iis, apache, nginx</p>
<h3 id="脚本类型">脚本类型</h3>
<p>php, asp</p>
<h3 id="数据库类型">数据库类型</h3>
<p>常见搭配：<br>
ASP 和 ASPX：ACCESS、SQL Server<br>
PHP：MySQL、PostgreSQL<br>
JSP：Oracle、MySQL</p>
<h2 id="收集子域名信息">收集子域名信息</h2>
<h3 id="为什么要收集子域名">为什么要收集子域名</h3>
<p>子域名枚举可以发现更多评估范围相关的域名/子域名，以增加漏洞发现机率；<br>
探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞；</p>
<h3 id="方法">方法</h3>
<p>1.谷歌语法<br>
2.在线子域名爆破https://phpinfo.me/domain/<br>
3.Loyer<br>
4.Maltego(kali)</p>
<h2 id="收集常用端口信息">收集常用端口信息</h2>
<p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务，就可以对症下药，便于我们渗透目标服务器。</p>
<h3 id="常见的扫描端口工具">常见的扫描端口工具</h3>
<p>1.Nmap<br>
2.Masscan<br>
3.Zmap<br>
4.御剑高速TCP端口扫描工具</p>
<h3 id="nmap基础使用">Nmap基础使用</h3>
<p>默认扫描：nmap 106.52.110.188<br>
指定端口扫描：nmap –p 3306 106.52.110.188<br>
完整扫描到端口、服务及版本：nmap –v –sV 106.52.110.188</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1598957468921.png" alt="" loading="lazy"></figure>
<h3 id="补充其他端口扫描工具">补充：其他端口扫描工具</h3>
<p>Shodan:https://www.shodan.io/<br>
在线端口扫描：http://www.t1shopper.com/tools/port-scan/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言学习（持续更新）]]></title>
        <id>https://7usai.github.io/post/c-yu-yan-xue-xi-chi-xu-geng-xin/</id>
        <link href="https://7usai.github.io/post/c-yu-yan-xue-xi-chi-xu-geng-xin/">
        </link>
        <updated>2020-08-14T10:22:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c语言">C语言</h1>
<h2 id="输入函数">输入函数</h2>
<ul>
<li>scanf (&quot;%d&quot;,&amp;Num);</li>
<li>scanf_s(&quot;%d&quot;,&amp;Num,10); 10是字符长度</li>
</ul>
<p>int Num4 ;<br>
scanf (&quot;%d&quot;,&amp;Num4);<br>
<strong>//%d就相当于告诉程序，接受的参数是一个int类型</strong>,&amp; 取地址符<br>
<strong>//Num4告诉程序，接收到的数据，存储到Num4里面</strong></p>
<hr>
<h2 id="输出函数">输出函数</h2>
<ul>
<li>printf(&quot;%d&quot; , Num5);</li>
<li>printf(&quot;123\n&quot;):\n是换行的意思，输出123到屏幕后换行</li>
</ul>
<h3 id="例子">例子：</h3>
<ul>
<li>int age;<br>
printf (&quot;请输入您的年龄:&quot;);<br>
scanf (&quot;%d&quot;,&amp;age);<br>
printf(&quot;您的年龄是: %d&quot;,age);</li>
<li>printf (&quot;请输入一个数字:&quot;);<br>
scanf (&quot;%d&quot;,&amp;Num1);<br>
printf(&quot;请再输入一个数字:&quot;);<br>
scanf (&quot;%d&quot;,&amp;Num2);<br>
Num=Num1+Num2;<br>
printf(&quot;%d + %d = %d&quot;,Num1,Num2,Num)<br>
<img src="https://7usai.github.io/post-images/1597400597382.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h2 id="整数类型">整数类型</h2>
<p>进制</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">8进制</th>
<th style="text-align:center">10进制</th>
<th style="text-align:center">16进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">%o</td>
<td style="text-align:center">%d</td>
<td style="text-align:center">%x</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">%ho</td>
<td style="text-align:center">%hd</td>
<td style="text-align:center">%hx</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">%lo</td>
<td style="text-align:center">%ld</td>
<td style="text-align:center">%lx</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">%llo</td>
<td style="text-align:center">%lld</td>
<td style="text-align:center">%llx</td>
</tr>
</tbody>
</table>
<p>e.g</p>
<pre><code>int num=100;
printf(&quot;num的8进制显示:%o,num的10进制显示:%d,num的16进制显示:%x&quot;,num,num,num)

打印结果:
num的8进制显示:144,num的10进制显示:100,num的16进制显示:64
</code></pre>
<p>//int 32位<br>
//short int 16位    short 不长于int类型<br>
//long int 32位     long不短于int类型<br>
//long long int     long long 64位<br>
//unsigned无符号  unsigned int  &quot;%u&quot;</p>
<hr>
<h2 id="字符类型">字符类型</h2>
<h3 id="char">char</h3>
<p>//理论上占8位:-128~127，Ascii码 0~127<br>
//Unicode(万国码)，16位，甚至是32位；</p>
<h4 id="声明方式">声明方式</h4>
<ol>
<li>char name1='A';//只能为'A'，为A或者&quot;A&quot;都错误</li>
<li>char name2;<br>
name2='A';</li>
<li>scanf(&quot;%c&quot;,&amp;name);</li>
<li>char name=65;<br>
printf(&quot;%c&quot;,name);//这是一种正确的声明方式，但是不提倡这么做</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">&quot;A&quot;</th>
<th style="text-align:left">'A'</th>
<th style="text-align:left">A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left">字符</td>
<td style="text-align:left">变量</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>换行</th>
<th>回车</th>
<th>警报</th>
<th>打印\</th>
<th>打印'</th>
<th>打印&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>\r</td>
<td>\a</td>
<td>\\</td>
<td>\'</td>
<td>\&quot;</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="浮点类型">浮点类型</h2>
<p>float 单精度浮点型 32位<br>
double 双精度浮点型 64位<br>
long double 长双精度浮点型</p>
<pre><code>float num=1.1;
double num1= 12E-5;
printf(&quot;%f,%f&quot;,num,num1);
return 0;

打印结果:
1.100000,0.000120
</code></pre>
<hr>
<h2 id="_bool类型">_Bool类型</h2>
<p>c99的时候引入的</p>
<pre><code>_Bool flag=0;//0代表false 假,1代表true 真
</code></pre>
<hr>
<h2 id="基础类型">基础类型</h2>
<p>int,long ,short ,unsigned,char ,float ,double ,signed, _Bool, _Complex(复数), _Imaginary(虚数)</p>
<p>包含一个头文件：inttype.h后有uint64_t(无符号整型64位)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CTFD搭建（ubuntu18.04）]]></title>
        <id>https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/</id>
        <link href="https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/">
        </link>
        <updated>2020-07-31T14:37:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="更换ubuntu1804阿里源">更换ubuntu18.04阿里源</h2>
<p>vim /etc/apt/sources.list</p>
<p>sudo apt-get update</p>
<p>sudo apt-get upgrade</p>
<h2 id="安装pip3">安装pip3</h2>
<p>apt install python3-pip</p>
<p>如果异常可以升级pip</p>
<p>sudo python3 -m pip install --upgrade pip</p>
<h2 id="pip换源">pip换源</h2>
<pre><code>mkdir ~/.pip
cd ~/.pip
touch pip.conf
编辑pip.conf文件
sudo vim ~/.pip/pip.conf
打开pip.conf文件窗口,将以下内容复制到文件中:
[global] 
index-url = http://pypi.douban.com/simple 
[install] 
trusted-host=pypi.douban.com
</code></pre>
<h2 id="安装flask">安装Flask</h2>
<p>sudo pip3 install Flask</p>
<h2 id="下载ctfd">下载CTFd</h2>
<p>sudo git clone https://github.com/isislab/CTFd.git</p>
<p>如果不能成功下载就</p>
<p>sudo git clone https://gitee.com/ivenwings/CTFd.git</p>
<p>给予权限</p>
<p>chmod -R 755 CTFd/</p>
<h2 id="安装ctfd">安装CTFd</h2>
<p>1  cd CTFd/</p>
<p>2  ./prepare.sh</p>
<p>3  pip3 install -r -requirements.txt；这一步如果不行可以尝试python3 -m pip install -r -requirements.txt</p>
<p>4  python3 serve.py</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp（持续更新）]]></title>
        <id>https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/</id>
        <link href="https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/">
        </link>
        <updated>2020-07-31T14:12:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="buuctf-re部分wp">BUUCTF re部分wp</h1>
<h2 id="easyre">easyre</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1596204910229.png" alt="" loading="lazy"></figure>
<h2 id="reverse1">reverse1</h2>
<p>搜索flag字符串找到如下位置<br>
<img src="https://7usai.github.io/post-images/1596204953682.png" alt="" loading="lazy"></p>
<p>再按F5后再双击Str2<br>
<img src="https://7usai.github.io/post-images/1596204960649.png" alt="" loading="lazy"></p>
<p>将hello_world中的o换成0</p>
<p>得flag{hell0_w0rld}</p>
<h2 id="reverse2">reverse2</h2>
<p>找到main函数按下F5<br>
<img src="https://7usai.github.io/post-images/1596204969585.png" alt="" loading="lazy"></p>
<p>双击flag</p>
<p><img src="https://7usai.github.io/post-images/1596204975899.png" alt="" loading="lazy"><br>
输入发现不正确继续看</p>
<p>这里flag中存的是{hacking_for_fun}</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1596204985974.png" alt="" loading="lazy"></figure>
<p>在主函数的这里发生了转换，查ascii表得是将i和r转换成1</p>
<p>得flag{hack1ng_fo1_fun}</p>
<h2 id="新年快乐">新年快乐</h2>
<p>有UPX壳，脱壳后找</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1596204992819.png" alt="" loading="lazy"></figure>
<h2 id="内涵的软件">内涵的软件</h2>
<p>拖进IDA得flag,DBAPP换成flag<br>
<img src="https://7usai.github.io/post-images/1596205001874.png" alt="" loading="lazy"></p>
<h2 id="bjdctf-2ndguessgame">[BJDCTF 2nd]guessgame</h2>
<p>shift+F12得flag</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1596211165409.png" alt="" loading="lazy"></figure>
<h2 id="helloword">helloword</h2>
<p>得到一个APK文件</p>
<p>放入android killer里边得flag<br>
<img src="https://7usai.github.io/post-images/1596211279124.png" alt="" loading="lazy"></p>
<h2 id="xor">XOR</h2>
<p>看main函数应该是一个33位数异或<br>
<img src="https://7usai.github.io/post-images/1596211286748.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1596211291028.png" alt="" loading="lazy"></figure>
<p>这里有33位数</p>
<p>写异或算法</p>
<pre><code>l=[0x66,0x0a,0x6b,0x0c,0x77,0x26,0x4f,0x2e,0x40,0x11,0x78,0x0d,0x5a,0x3b,0x55,0x11,0x70,0x19,0x46,0x1f,0x76,0x22,0x4d,0x23,0x44,0x0e,0x67,0x06,0x68,0x0f,0x47,0x32,0x4f]
x='f'
for i in range(1,len(l)):
    x+=chr(l[i]^l[i-1])
    print (x)
</code></pre>
<p>得flag<br>
<img src="https://7usai.github.io/post-images/1596211295525.png" alt="" loading="lazy"></p>
<h2 id="reverse3">reverse3</h2>
<p>32位IDA打开 找到main函数为sub_4156E0</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1596231374547.png" alt="" loading="lazy"></figure>
<p>Dest与Str2比较，相等则为加密的flag。首先我们输入flag值，flag值经过变换后得Dest，即Str2。</p>
<p>flag先变为v1,再变为Dest1，再变为Dest（Str2）</p>
<p>找到v1转换函数</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1596231379288.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1596231383733.png" alt="" loading="lazy"></figure>
<p>可见是base64加密</p>
<p>又得到Str2的值</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1596231387805.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<pre><code>import base64
str2='e3nifIH9b_C@n@dH'
x=''
for i in range(0,len(str2)):
    x+=chr(ord(str2[i])-i)
print (x)
y=base64.b64decode(x)
print (y)
</code></pre>
<p>得flag</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1596231394662.png" alt="" loading="lazy"></figure>
<p>补充</p>
<p>ord()函数主要用来返回对应字符的ascii码，chr()主要用来表示ascii码对应的字符他的输入时数字（可十进制可十六进制），ord:字符转ascii码，chr:ascii码转字符。在此题计算中先转为ascii减数字，得到的新ascii再转为字符。</p>
<p>python中base64加密与解码，加密用encode解密用decode，如下例</p>
<p>&gt;&gt;&gt; import base64<br>
&gt;&gt;&gt; s = '我是字符串'<br>
&gt;&gt;&gt; a = base64.b64encode(s)<br>
&gt;&gt;&gt; print a<br>
ztLKx9fWt/u0rg==<br>
&gt;&gt;&gt; print base64.b64decode(a)<br>
我是字符串</p>
<h2 id="不一样的flag">不一样的flag</h2>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1596232291308.png" alt="" loading="lazy"></figure>
<p>点开程序是这样，放入IDA32位得主函数</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1596232295572.png" alt="" loading="lazy"></figure>
<p>又查到此字符串，猜测是个迷宫题</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1596232300989.png" alt="" loading="lazy"></figure>
<p>这里的意思时遇到1就退出，即不遇到1的情况下到达#<br>
<img src="https://7usai.github.io/post-images/1596232306563.png" alt="" loading="lazy"></p>
<p>*11110100001010000101111#可分为5行 *为起点#为重点</p>
<pre><code>*1111
01000
01010
00010
1111#
</code></pre>
<p>于是走一遍得</p>
<p>flag{222441144222}</p>
<h2 id="simplerev">SimpleRev</h2>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1597677451168.png" alt="" loading="lazy"></figure>
<p>这里表示得到v4，v4为d或者D时进入Decry函数，不为d或者D时判断是否为Q或者q，是的话退出，不是则输出错误。<br>
<img src="https://7usai.github.io/post-images/1597677458757.png" alt="" loading="lazy"></p>
<p>进入Decry得到text通过key3，v9和join函数得到，进入join函数</p>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1597677466006.png" alt="" loading="lazy"></figure>
<p>意思是a1与a2连接，返回值dest=a1+a2。<br>
回到Decry函数可知text=key3+v9。key=key1+src。</p>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1597677474689.png" alt="" loading="lazy"></figure>
<p>key3=kills,key1=ADSFK，因为是小端序存储，所以text=killshadow，key=ADSFKNDCLS</p>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1597677480466.png" alt="" loading="lazy"></figure>
<p>这一步是将大写字母变为小写字母，key=adsfkndcls</p>
<p><img src="https://7usai.github.io/post-images/1597677488135.png" alt="" loading="lazy"><br>
编写脚本</p>
<pre><code>key=&quot;adsfkndcls&quot;
text=&quot;killshadow&quot;
loop=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
flag=&quot;&quot;
for i in range(0,len(text)):
    for j in loop:
        if ord(text[i])==(ord(j)-39-ord(key[i])+97)%26+97:
            flag+=j
print(flag)
</code></pre>
<p>得到flag</p>
<p>KLDQCUDFZO</p>
<h2 id="刮开有奖">刮开有奖</h2>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1597677495395.png" alt="" loading="lazy"></figure>
<p>找到主函数DialogFunc并进入可知v7是数组的开头第一位，进入sub_4010F0</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1597677500492.png" alt="" loading="lazy"></figure>
<p>转为c语音代码得</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int f(char arr[], int a, int b)
{
    int result;
    int i;
    int v5;
    int v6;
    result = b;
    for (i = a; i &lt;= b; a = i)
    {
        v5 = i;
        v6 = arr[i];
        if (a &lt; result &amp;&amp; i &lt; result)
        {
            do
            {
                if (v6 &gt; arr[result])
                {
                    if (i &gt;= result)
                        break;
                    ++i;
                    arr[v5] = arr[result];
                    if (i &gt;= result)
                        break;
                    while (arr[i] &lt;= v6)
                    {
                        if (++i &gt;= result)
                            goto LABEL_13;
                    }
                    if (i&gt;=result)
                        break;
                    v5 = i;
                    arr[result] = arr[i];
                }
                --result;
            } while (i &lt; result);
        }
LABEL_13:
        arr[result] = v6;
        f(arr, a, i - 1);
        result = b;
        ++i;
    }
    return result;
}
int main()
{
    char arr[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};
    cout &lt;&lt; arr &lt;&lt; endl;
    f(arr,0,10);
    cout&lt;&lt;arr&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>运行一下得</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1597677510196.png" alt="" loading="lazy"></figure>
<p>进入401000函数可看出事base64</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1597677516740.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1597677522324.png" alt="" loading="lazy"></figure>
<p>这里第一位是U第二位J第三位开始通过ak1w,V1ax解码得jMp和WP1所以从第三位开始是WP1jMp</p>
<p>拼得flag{UJWP1jMp}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora快捷键]]></title>
        <id>https://7usai.github.io/post/typora-kuai-jie-jian/</id>
        <link href="https://7usai.github.io/post/typora-kuai-jie-jian/">
        </link>
        <updated>2020-07-24T03:45:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一菜单栏">一：菜单栏</h2>
<hr>
<ul>
<li>文件：alt+F</li>
<li>编辑：alt+E</li>
<li>段落：alt+P</li>
<li>格式：alt+O</li>
<li>视图：alt+V</li>
<li>主题：alt+T</li>
<li>帮助：alt+H</li>
</ul>
<h2 id="二文件">二：文件</h2>
<ul>
<li>新建：Ctrl+N</li>
<li>新建窗口：Ctrl+Shift+N</li>
<li>打开：Ctrl+O</li>
<li>快速打开：Ctrl+P</li>
<li>保存：Ctrl+S</li>
<li>另存为：Ctrl+Shift+S</li>
<li>偏好：Ctrl+,</li>
<li>关闭：Ctrl+W</li>
</ul>
<h2 id="三编辑">三：编辑</h2>
<ul>
<li>撤销：Ctrl+Z</li>
<li>重做：Ctrl+Y</li>
<li>剪切：Ctrl+X</li>
<li>复制：Ctrl+C</li>
<li>粘贴：Ctrl+V</li>
<li>复制为MarkDown：Ctrl+Shift+C</li>
<li>粘贴为纯文本：Ctrl+Shift+V</li>
<li>全选：Ctrl+A</li>
<li>选中当前行/句：Ctrl+L</li>
<li>选中当前格式文本：Ctrl+E</li>
<li>选中当前词：Ctrl+D</li>
<li>跳转到文首：Ctrl+Home</li>
<li>跳转到所选内容：Ctrl+J</li>
<li>跳转到文末：Ctrl+End</li>
<li>查找：Ctrl+F</li>
<li>查找下一个：F3</li>
<li>查找上一个：Shift+F3</li>
<li>替换：Ctrl+H</li>
</ul>
<h2 id="四段落">四：段落</h2>
<ul>
<li>标题：Ctrl+1/2/3/4/5</li>
<li>段落：Ctrl+0</li>
<li>增大标题级别：Ctrl+=</li>
<li>减少标题级别：Ctrl+-</li>
<li>表格：Ctrl+T</li>
<li>代码块：Ctrl+Shift+K</li>
<li>公式块：Ctrl+Shift+M</li>
<li>引用：Ctrl+Shift+Q</li>
<li>有序列表：Ctrl+Shift+[</li>
<li>无序列表：Ctrl+Shift+]</li>
<li>增加缩进：Ctrl+]</li>
<li>减少缩进：Ctrl+[</li>
</ul>
<h2 id="五格式">五：格式</h2>
<ul>
<li>加粗：Ctrl+B</li>
<li>斜体：Ctrl+I</li>
<li>下划线：Ctrl+U</li>
<li>代码：Ctrl+Shift+`</li>
<li>删除线：Alt+Shift+5</li>
<li>超链接：Ctrl+K</li>
<li>图像：Ctrl+Shift+I</li>
<li>清除样式：Ctrl+</li>
</ul>
<h2 id="六视图">六：视图</h2>
<ul>
<li>显示隐藏侧边栏：Ctrl+Shift+L</li>
<li>大纲视图：Ctrl+Shift+1</li>
<li>文档列表视图：Ctrl+Shift+2</li>
<li>文件树视图：Ctrl+Shift+3</li>
<li>源代码模式：Ctrl+/</li>
<li>专注模式：F8</li>
<li>打字机模式：F9</li>
<li>切换全屏：F11</li>
<li>实际大小：Ctrl+Shift+0</li>
<li>放大：Ctrl+Shift+=</li>
<li>缩小：Ctrl+Shift+-</li>
<li>应用内窗口切换：Ctrl+Tab</li>
<li>打开DevTools：Shift+F12</li>
</ul>
]]></content>
    </entry>
</feed>