<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://7usai.github.io</id>
    <title>7usai</title>
    <updated>2020-07-31T22:30:43.383Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://7usai.github.io"/>
    <link rel="self" href="https://7usai.github.io/atom.xml"/>
    <subtitle>7usai&apos;blog</subtitle>
    <logo>https://7usai.github.io/images/avatar.png</logo>
    <icon>https://7usai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 7usai</rights>
    <entry>
        <title type="html"><![CDATA[CTFD搭建（ubuntu18.04）]]></title>
        <id>https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/</id>
        <link href="https://7usai.github.io/post/ctfd-da-jian-ubuntu1804/">
        </link>
        <updated>2020-07-31T14:37:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="更换ubuntu1804阿里源">更换ubuntu18.04阿里源</h2>
<p>vim /etc/apt/sources.list</p>
<p>sudo apt-get update</p>
<p>sudo apt-get upgrade</p>
<h2 id="安装pip3">安装pip3</h2>
<p>apt install python3-pip</p>
<p>如果异常可以升级pip</p>
<p>sudo python3 -m pip install --upgrade pip</p>
<h2 id="pip换源">pip换源</h2>
<pre><code>mkdir ~/.pip
cd ~/.pip
touch pip.conf
编辑pip.conf文件
sudo vim ~/.pip/pip.conf
打开pip.conf文件窗口,将以下内容复制到文件中:
[global] 
index-url = http://pypi.douban.com/simple 
[install] 
trusted-host=pypi.douban.com
</code></pre>
<h2 id="安装flask">安装Flask</h2>
<p>sudo pip3 install Flask</p>
<h2 id="下载ctfd">下载CTFd</h2>
<p>sudo git clone https://github.com/isislab/CTFd.git</p>
<p>如果不能成功下载就</p>
<p>sudo git clone https://gitee.com/ivenwings/CTFd.git</p>
<p>给予权限</p>
<p>chmod -R 755 CTFd/</p>
<h2 id="安装ctfd">安装CTFd</h2>
<p>1  cd CTFd/</p>
<p>2  ./prepare.sh</p>
<p>3  pip3 install -r -requirements.txt；这一步如果不行可以尝试python3 -m pip install -r -requirements.txt</p>
<p>4  python3 serve.py</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BUUCTF re部分wp（持续更新）]]></title>
        <id>https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/</id>
        <link href="https://7usai.github.io/post/buuctf-re-bu-fen-wpchi-xu-geng-xin/">
        </link>
        <updated>2020-07-31T14:12:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="buuctf-re部分wp">BUUCTF re部分wp</h1>
<h2 id="easyre">easyre</h2>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1596204910229.png" alt="" loading="lazy"></figure>
<h2 id="reverse1">reverse1</h2>
<p>搜索flag字符串找到如下位置<br>
<img src="https://7usai.github.io/post-images/1596204953682.png" alt="" loading="lazy"></p>
<p>再按F5后再双击Str2<br>
<img src="https://7usai.github.io/post-images/1596204960649.png" alt="" loading="lazy"></p>
<p>将hello_world中的o换成0</p>
<p>得flag{hell0_w0rld}</p>
<h2 id="reverse2">reverse2</h2>
<p>找到main函数按下F5<br>
<img src="https://7usai.github.io/post-images/1596204969585.png" alt="" loading="lazy"></p>
<p>双击flag</p>
<p><img src="https://7usai.github.io/post-images/1596204975899.png" alt="" loading="lazy"><br>
输入发现不正确继续看</p>
<p>这里flag中存的是{hacking_for_fun}</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1596204985974.png" alt="" loading="lazy"></figure>
<p>在主函数的这里发生了转换，查ascii表得是将i和r转换成1</p>
<p>得flag{hack1ng_fo1_fun}</p>
<h2 id="新年快乐">新年快乐</h2>
<p>有UPX壳，脱壳后找</p>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1596204992819.png" alt="" loading="lazy"></figure>
<h2 id="内涵的软件">内涵的软件</h2>
<p>拖进IDA得flag,DBAPP换成flag<br>
<img src="https://7usai.github.io/post-images/1596205001874.png" alt="" loading="lazy"></p>
<h2 id="bjdctf-2ndguessgame">[BJDCTF 2nd]guessgame</h2>
<p>shift+F12得flag</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1596211165409.png" alt="" loading="lazy"></figure>
<h2 id="helloword">helloword</h2>
<p>得到一个APK文件</p>
<p>放入android killer里边得flag<br>
<img src="https://7usai.github.io/post-images/1596211279124.png" alt="" loading="lazy"></p>
<h2 id="xor">XOR</h2>
<p>看main函数应该是一个33位数异或<br>
<img src="https://7usai.github.io/post-images/1596211286748.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1596211291028.png" alt="" loading="lazy"></figure>
<p>这里有33位数</p>
<p>写异或算法</p>
<pre><code>l=[0x66,0x0a,0x6b,0x0c,0x77,0x26,0x4f,0x2e,0x40,0x11,0x78,0x0d,0x5a,0x3b,0x55,0x11,0x70,0x19,0x46,0x1f,0x76,0x22,0x4d,0x23,0x44,0x0e,0x67,0x06,0x68,0x0f,0x47,0x32,0x4f]
x='f'
for i in range(1,len(l)):
    x+=chr(l[i]^l[i-1])
    print (x)
</code></pre>
<p>得flag<br>
<img src="https://7usai.github.io/post-images/1596211295525.png" alt="" loading="lazy"></p>
<h2 id="reverse3">reverse3</h2>
<p>32位IDA打开 找到main函数为sub_4156E0</p>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1596231374547.png" alt="" loading="lazy"></figure>
<p>Dest与Str2比较，相等则为加密的flag。首先我们输入flag值，flag值经过变换后得Dest，即Str2。</p>
<p>flag先变为v1,再变为Dest1，再变为Dest（Str2）</p>
<p>找到v1转换函数</p>
<figure data-type="image" tabindex="7"><img src="https://7usai.github.io/post-images/1596231379288.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://7usai.github.io/post-images/1596231383733.png" alt="" loading="lazy"></figure>
<p>可见是base64加密</p>
<p>又得到Str2的值</p>
<figure data-type="image" tabindex="9"><img src="https://7usai.github.io/post-images/1596231387805.png" alt="" loading="lazy"></figure>
<p>编写脚本</p>
<pre><code>import base64
str2='e3nifIH9b_C@n@dH'
x=''
for i in range(0,len(str2)):
    x+=chr(ord(str2[i])-i)
print (x)
y=base64.b64decode(x)
print (y)
</code></pre>
<p>得flag</p>
<figure data-type="image" tabindex="10"><img src="https://7usai.github.io/post-images/1596231394662.png" alt="" loading="lazy"></figure>
<p>补充</p>
<p>ord()函数主要用来返回对应字符的ascii码，chr()主要用来表示ascii码对应的字符他的输入时数字（可十进制可十六进制），ord:字符转ascii码，chr:ascii码转字符。在此题计算中先转为ascii减数字，得到的新ascii再转为字符。</p>
<p>python中base64加密与解码，加密用encode解密用decode，如下例</p>
<p>&gt;&gt;&gt; import base64<br>
&gt;&gt;&gt; s = '我是字符串'<br>
&gt;&gt;&gt; a = base64.b64encode(s)<br>
&gt;&gt;&gt; print a<br>
ztLKx9fWt/u0rg==<br>
&gt;&gt;&gt; print base64.b64decode(a)<br>
我是字符串</p>
<h2 id="不一样的flag">不一样的flag</h2>
<figure data-type="image" tabindex="11"><img src="https://7usai.github.io/post-images/1596232291308.png" alt="" loading="lazy"></figure>
<p>点开程序是这样，放入IDA32位得主函数</p>
<figure data-type="image" tabindex="12"><img src="https://7usai.github.io/post-images/1596232295572.png" alt="" loading="lazy"></figure>
<p>又查到此字符串，猜测是个迷宫题</p>
<figure data-type="image" tabindex="13"><img src="https://7usai.github.io/post-images/1596232300989.png" alt="" loading="lazy"></figure>
<p>这里的意思时遇到1就退出，即不遇到1的情况下到达#<br>
<img src="https://7usai.github.io/post-images/1596232306563.png" alt="" loading="lazy"></p>
<p>*11110100001010000101111#可分为5行 *为起点#为重点</p>
<pre><code>*1111
01000
01010
00010
1111#
</code></pre>
<p>于是走一遍得</p>
<p>flag{222441144222}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora快捷键]]></title>
        <id>https://7usai.github.io/post/typora-kuai-jie-jian/</id>
        <link href="https://7usai.github.io/post/typora-kuai-jie-jian/">
        </link>
        <updated>2020-07-24T03:45:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一菜单栏">一：菜单栏</h2>
<hr>
<ul>
<li>文件：alt+F</li>
<li>编辑：alt+E</li>
<li>段落：alt+P</li>
<li>格式：alt+O</li>
<li>视图：alt+V</li>
<li>主题：alt+T</li>
<li>帮助：alt+H</li>
</ul>
<h2 id="二文件">二：文件</h2>
<ul>
<li>新建：Ctrl+N</li>
<li>新建窗口：Ctrl+Shift+N</li>
<li>打开：Ctrl+O</li>
<li>快速打开：Ctrl+P</li>
<li>保存：Ctrl+S</li>
<li>另存为：Ctrl+Shift+S</li>
<li>偏好：Ctrl+,</li>
<li>关闭：Ctrl+W</li>
</ul>
<h2 id="三编辑">三：编辑</h2>
<ul>
<li>撤销：Ctrl+Z</li>
<li>重做：Ctrl+Y</li>
<li>剪切：Ctrl+X</li>
<li>复制：Ctrl+C</li>
<li>粘贴：Ctrl+V</li>
<li>复制为MarkDown：Ctrl+Shift+C</li>
<li>粘贴为纯文本：Ctrl+Shift+V</li>
<li>全选：Ctrl+A</li>
<li>选中当前行/句：Ctrl+L</li>
<li>选中当前格式文本：Ctrl+E</li>
<li>选中当前词：Ctrl+D</li>
<li>跳转到文首：Ctrl+Home</li>
<li>跳转到所选内容：Ctrl+J</li>
<li>跳转到文末：Ctrl+End</li>
<li>查找：Ctrl+F</li>
<li>查找下一个：F3</li>
<li>查找上一个：Shift+F3</li>
<li>替换：Ctrl+H</li>
</ul>
<h2 id="四段落">四：段落</h2>
<ul>
<li>标题：Ctrl+1/2/3/4/5</li>
<li>段落：Ctrl+0</li>
<li>增大标题级别：Ctrl+=</li>
<li>减少标题级别：Ctrl+-</li>
<li>表格：Ctrl+T</li>
<li>代码块：Ctrl+Shift+K</li>
<li>公式块：Ctrl+Shift+M</li>
<li>引用：Ctrl+Shift+Q</li>
<li>有序列表：Ctrl+Shift+[</li>
<li>无序列表：Ctrl+Shift+]</li>
<li>增加缩进：Ctrl+]</li>
<li>减少缩进：Ctrl+[</li>
</ul>
<h2 id="五格式">五：格式</h2>
<ul>
<li>加粗：Ctrl+B</li>
<li>斜体：Ctrl+I</li>
<li>下划线：Ctrl+U</li>
<li>代码：Ctrl+Shift+`</li>
<li>删除线：Alt+Shift+5</li>
<li>超链接：Ctrl+K</li>
<li>图像：Ctrl+Shift+I</li>
<li>清除样式：Ctrl+</li>
</ul>
<h2 id="六视图">六：视图</h2>
<ul>
<li>显示隐藏侧边栏：Ctrl+Shift+L</li>
<li>大纲视图：Ctrl+Shift+1</li>
<li>文档列表视图：Ctrl+Shift+2</li>
<li>文件树视图：Ctrl+Shift+3</li>
<li>源代码模式：Ctrl+/</li>
<li>专注模式：F8</li>
<li>打字机模式：F9</li>
<li>切换全屏：F11</li>
<li>实际大小：Ctrl+Shift+0</li>
<li>放大：Ctrl+Shift+=</li>
<li>缩小：Ctrl+Shift+-</li>
<li>应用内窗口切换：Ctrl+Tab</li>
<li>打开DevTools：Shift+F12</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编学习部分总结]]></title>
        <id>https://7usai.github.io/post/hui-bian-xue-xi-bu-fen-zong-jie/</id>
        <link href="https://7usai.github.io/post/hui-bian-xue-xi-bu-fen-zong-jie/">
        </link>
        <updated>2020-07-24T03:29:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="汇编">汇编</h1>
<h2 id="汇编代码">汇编代码</h2>
<p>.586  <em>:指令集</em><br>
.MODEL flat, stdcall :指定调用约定，flat：内存指令方式 stadcall：调用约定<br>
includelib user32.lib :lib 静态库 包含一下lib文件<br>
includelib kernel32.lib :<br>
ExitProcess PROTO, dwExitCode : DWORD<br>
MessageBoxA PROTO hWnd : DWORD, lText : BYTE, lpCaption : BYTE, uType: DWORD<br>
.data<br>
Number DWORD 0<br>
text db &quot;shellcode&quot;,0<br>
.code<br>
main proc<br>
mov eax,5<br>
mov ebx,6<br>
add eax,ebx<br>
add eax,Number<br>
push 0<br>
push offset text<br>
push offset text<br>
push 0<br>
call MessageBoxA<br>
add esp,16<br>
call ExitProcess<br>
main ENDP<br>
END main</p>
<h2 id="知识点">知识点</h2>
<p>ASCII码</p>
<p>UNICODE字符集：统一码、万国码、单一码</p>
<h2 id="mov">MOV</h2>
<p>mov a,b：寄存器，寄存器||寄存器，立即数||寄存器，存储器。</p>
<h2 id="add">ADD</h2>
<p>加法指令，操作数1+操作数2，结果放入操作数1中</p>
<h2 id="整数常量">整数常量</h2>
<p>0A3H,42Q,26(D)，01010010B</p>
<p>2 b, 8 o/q,16 h ,10 (d)</p>
<h2 id="实数常量">实数常量</h2>
<p>2， 3.0， +3.0， -44.E+5，  26.E5</p>
<h2 id="字符常量">字符常量</h2>
<p>'A'/&quot;A&quot; 单/双引号都可</p>
<h2 id="字符串常量">字符串常量</h2>
<p>&quot;hello&quot;/'hello'</p>
<h2 id="保留字">保留字</h2>
<p>指令： mov	lea	 add	sub	jcc……</p>
<p>寄存器</p>
<p>属性： db	dword……</p>
<p>运算符</p>
<h2 id="标识符">标识符</h2>
<p>第一个字符是有限制的	标识符不能与保留字相同</p>
<h2 id="伪指令">伪指令</h2>
<p>.data	.code	offest...</p>
<h2 id="指令">指令</h2>
<p>mov eax,123	：汇编语句</p>
<h2 id="内部数据类型">内部数据类型</h2>
<h3 id="整数">整数</h3>
<p>BYTE 8位 无符号		WORD 16位 无符号		DWORD 32位 无符号</p>
<p>SBYTE 8位 有符号		WORD 16位 有符号		SDWORD 32位 有符号</p>
<p>FWORD 48位 保护模式的远指针		QWORD 64位 整数		TBYTE 80位 整数</p>
<h3 id="实数">实数</h3>
<p>REAL4 32位 短实数 /4字节		REAL8 64位 长实数 /8字节		REAL10 80位 扩展实数 /10字节</p>
<h3 id="伪指令-2">伪指令</h3>
<p>db 8位整数 //相当于C语言里的char 可以保存ASCII码</p>
<p>dw 16位整数</p>
<p>db 32位整数或实数</p>
<p>dq 64位整数或实数</p>
<p>dt 80位整数</p>
<h2 id="数组">数组</h2>
<h3 id="初始化数组初值为0">初始化数组（初值为0）</h3>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1595562002397.png" alt="" loading="lazy"></figure>
<h3 id="初始化数组不定义初值">初始化数组不定义初值</h3>
<img src="F:\markdown\Typora\SAVES\image-20200624193431916.png" alt="image-20200624193431916" style="zoom:80%;" />
<h2 id="一些疑问">一些疑问</h2>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1595562020942.png" alt="" loading="lazy"></figure>
<p>老师讲解：dword 8位二进制数；	 win32 	32➗8=4   	4字节   	单位为4</p>
<h2 id="大端序小端序">大端序小端序</h2>
<figure data-type="image" tabindex="3"><img src="https://7usai.github.io/post-images/1595562042953.png" alt="" loading="lazy"></figure>
<p>67 45 23 01小端序		12345678 大端序</p>
<h2 id="数据传送指令">数据传送指令</h2>
<h3 id="操作数类型">操作数类型</h3>
<p>立即数	寄存器操作数（eax,ebx...)	内存操作数</p>
<h3 id="reg通用寄存器">reg通用寄存器</h3>
<p>reg8 (8位) reg16 reg32</p>
<p>sreg 段寄存器</p>
<h3 id="imm-立即数">imm 立即数</h3>
<p>imm8 imm16 imm32</p>
<h3 id="mem内存">mem内存</h3>
<p>mem8 mem16 mem32</p>
<p>(8,16,32为位数)</p>
<h3 id="数据传送指令-2">数据传送指令</h3>
<h3 id="mov-2">mov</h3>
<p>mov 目的操作数，源操作数 （源操作数如果是地址，就把地址上的数给目的操作数；如果是立即数，就直接给。前后的位数要一致，两数不能同为内存操作数）//int a=15--&gt;mov a,15</p>
<p>能使用的5种情况：mov reg,reg	mov mem,reg	mov reg,mem	mov mem,imm	mov reg,imm</p>
<p>如何实现mov mem2,mem1：mov reg,mem1+++mov mem2,reg</p>
<p>mov reg32,reg16:(eax 32位 ax 16位 ah,al 8位)看下面例子</p>
<p>mov eax,cx：		mov eax,FFFFFFFFH+++mov ax,cx</p>
<h3 id="movzx">movzx</h3>
<p>movzx eax,cx</p>
<p>cx 1234H</p>
<p>eax=00001234H（填0扩展）</p>
<h3 id="movsx">movsx</h3>
<p>movsx eax,cx</p>
<p>填1扩展</p>
<h3 id="lahf">LAHF</h3>
<p>lahf ,（没有操作数的指令）将标志存储到ah里</p>
<p>mov flag,ah</p>
<h3 id="sahf">SAHF</h3>
<p>mov ah,flag</p>
<p>sahf，将ah中的值拷贝到efalgs标志位里（zf,sf.....）</p>
<h3 id="xchg">XCHG</h3>
<p>交换指令</p>
<p>xchg reg,reg		xchg reg,mem		xchg mem,reg</p>
<h2 id="加法与减法">加法与减法</h2>
<p>add</p>
<p>add eax,ecx</p>
<p>eax=1,ecx=2 	add后 eax=3,ecx=2</p>
<p>sub减法</p>
<p>sub eax,ecx</p>
<p>eax=2,ecx=1 	sub后 eax=1,ecx=1</p>
<p>inc 自增//i++</p>
<p>inc eax  		eax=5 inc后 eax=6</p>
<p>dec 自减</p>
<p>neg</p>
<p>非 ，将操作数转为二进制补码并将符号取反</p>
<p>neg reg/mem	补码：二进制数按位取反后+1</p>
<h2 id="数据相关的运算符与伪指令">数据相关的运算符与伪指令</h2>
<p>arrNum DWORD 0,1,2,3,4,5</p>
<p>mov eax offset arrNum + 4  	:将1的地址放在eax里</p>
<p>mov eax,[eax]  		:将eax中地址的值放在eax里（将1放入eax里）</p>
<p>num DWORD 5</p>
<p>mov ax,word ptr num 		：因为ax是16位，num是32位</p>
<p>mov eax,offset lengthof num   	:获取元素个数</p>
<p>var word 32 dup(0)</p>
<p>mov eax, sizeof var		:eax =40--&gt;64 十进制  ：32*2(字节数)=64</p>
<h2 id="间接寻址">间接寻址</h2>
<p>var byte 0,1,2,3,4,5,6,7,8</p>
<p>xor eax,eax ：异或操作将eax清零</p>
<p>mov eax,offset var ：eax中存的是var的偏移，（var 为1个字节）</p>
<p>mov bl,[eax]		；将eax中地址的值给bl（1个字节）</p>
<p>mov bl,[eax+1]   ;b1为1</p>
<p>mov bl,[eax+2]	;bi为2</p>
<p>var dword 0,1,2,3,4,5,6,7,8</p>
<p>mov esi,4		;esi为下标</p>
<p>mov eax,var[esi*4]		; *4 ,4为dword宽度 （4字节） 此时eax为4</p>
<p>pbyte typedef ptr byte声明pbyte为byte(定义在数据段之前)</p>
<h2 id="jmp和loop">JMP和loop</h2>
<p>jmp无条件跳转		loop跳转一次cx--一次</p>
<h2 id="堆栈操作">堆栈操作</h2>
<p>push 压栈 	pop 出栈</p>
<p>push eax;将eax中的值压入栈顶</p>
<p>pop eax;将栈顶的值压出到eax中</p>
<p>push   ;esp-4存入一个4字节的；栈顶地址减4</p>
<p>pop     ;esp+4取出一个4字节的</p>
<p>pushfd  把32位的eflags寄存器压栈(多用于保护环境)</p>
<p>popfd  把eflags弹出</p>
<p>pushad 压栈通用寄存器 	popad 出栈</p>
<p>按此顺序压入eax,ecx,edx,ebx,esp,ebp,esi,edi  		；pop时按反顺序压出</p>
<p>pusha    	popa  16位</p>
<h3 id="获取字符串长度">获取字符串长度</h3>
<p>source byte &quot;my name is wanghailin&quot;,0</p>
<p>sourcesize = ( $ - source) - 1</p>
<h3 id="loop">loop</h3>
<p>loopz loope 循环条件：ecx&gt;0 &amp;&amp; ZF=1 (loopz一边用加减法，loope用cmp对比，两操作数相等时ZF=1跳转)</p>
<p>loopnz loopne  循环条件：ecx&gt;0 &amp;&amp; ZF=0</p>
<h2 id="定义函数">定义函数</h2>
<p>xxxx proc</p>
<p>函数内容</p>
<p>ret</p>
<p>xxxx endp</p>
<h3 id="call">call</h3>
<p>call指令：1.将eip压栈 push eip 2. jmp到函数位置</p>
<p>eip指令指针：指向下一行要执行的指令(call的下一行)</p>
<p>jmp:jmp到函数位置</p>
<h3 id="ret">ret</h3>
<p>ret指令 1.pop eip(将call的下一行压出到eip)2.jmp eip(跳转到call的下一行)</p>
<p>xxxx proc uses eax,ebx</p>
<p>函数内容</p>
<p>xxxx endp</p>
<p>可直接调用eax,ebx用于函数</p>
<h2 id="布尔与比较指令">布尔与比较指令</h2>
<p>与and 	或or	 非not	 异或xor</p>
<h3 id="test">test</h3>
<p>(测试某一位是否为1)相当于and 但不修改寄存器值 只修改eflags</p>
<p>如：</p>
<p>mov eax,00000001</p>
<p>test eax,00000000 :eax值不变,ZF=1(结果为00000000)</p>
<p>test eax,00000001 :eax值不变,ZF=0(结果为00000001)</p>
<h3 id="cmp">cmp</h3>
<p>cmp o1,o2	:o1-o2</p>
<p>o1&lt;o2 	ZF 0	 CF 1 	SF != OF</p>
<p>o1&gt;o2	 ZF 0	 CF 0	 SF =OF</p>
<p>o1=o2 	ZF 1	 CF 0</p>
<p>ZF 0标志位</p>
<p>CF 进位标志位:进位时为1</p>
<p>SF 符号标志位</p>
<p>OF 溢出标志位</p>
<h2 id="条件跳转指令">条件跳转指令</h2>
<p>JCC指令</p>
<p><a href="https://blog.csdn.net/fengshh2301/article/details/53327195">相关blog</a></p>
<p>JZ/JE 	ZF为1时跳转</p>
<p>JNZ/JNE 	ZF为0时跳转</p>
<h2 id="条件结构">条件结构</h2>
<h3 id="顺序结构">顺序结构</h3>
<h3 id="选择结构">选择结构</h3>
<p>o1 dword 100</p>
<p>o2 dword 100</p>
<p>x dword ?</p>
<p>y dword ?</p>
<p>main proc</p>
<p>​	mov eax o1</p>
<p>​	cmp eax o2	:o1=o2,eax=0,ZF=1</p>
<p>​	jnz l1	:ZF=0时跳转</p>
<p>​	mov x,1</p>
<p>​	mov y,1</p>
<p>​	jmp l2</p>
<p>l1:mov x,0</p>
<p>​	mov y,0</p>
<p>l2:push 	:l2用于让执行完if中语句后不执行else的语句</p>
<p>​	call ExitProcess	:退出</p>
<p><strong>相当于</strong></p>
<p>if(o1=o2)</p>
<p>{</p>
<p>​			x=1;</p>
<p>​			y=1;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>​			x=0;</p>
<p>​			y=0;</p>
<p>}</p>
<h3 id="循环结构">循环结构</h3>
<p>i dword 0</p>
<p>main proc</p>
<p>​	mov eax,100</p>
<p>​	cmp eax,i</p>
<p>​	jle l1	:eax&lt;=i跳转</p>
<p>​	inc i</p>
<p>l1:</p>
<p>​	push 0</p>
<p>​	call ExitProcess	:退出</p>
<p><strong>相当于</strong></p>
<p>while(i&lt;100)</p>
<p>{</p>
<p>​			i++;</p>
<p>}</p>
<h2 id="条件控制流伪命令">条件控制流伪命令</h2>
<h3 id="if">if</h3>
<p>.data</p>
<p>i dword 100</p>
<figure data-type="image" tabindex="4"><img src="https://7usai.github.io/post-images/1595562117092.png" alt="" loading="lazy"></figure>
<p>可以使用的运算符 ==	!==	&gt;	&gt;=	&lt;	&lt;=	&amp;	|	!	CARRY?(有进位CF=1返回true)	overflow?(溢出OF=1返回true)</p>
<h3 id="while">while</h3>
<figure data-type="image" tabindex="5"><img src="https://7usai.github.io/post-images/1595562126073.png" alt="" loading="lazy"></figure>
<h3 id="do-while">do while</h3>
<figure data-type="image" tabindex="6"><img src="https://7usai.github.io/post-images/1595562138129.png" alt="" loading="lazy"></figure>
<h2 id="移位与循环移位指令">移位与循环移位指令</h2>
<h3 id="逻辑移位">逻辑移位</h3>
<p>11001111--&gt;01100111		:补0</p>
<p>移出的一位放入了CF标志位中</p>
<h3 id="算数移位">算数移位</h3>
<p>11001111--&gt;11100111 	:符号位为1，补充1(为0时补充0)</p>
<p>SHL左移	SHR右移	SAL算数左移	SAR算数右移	ROL循环左移	ROR循环右移	RCL带进位的循环左移	RCR带进位的循环右移	SHLD双精度左移	SHRD双精度右移</p>
<h3 id="rcl带进位的循环左移">RCL带进位的循环左移</h3>
<p>clc 	:cf=0</p>
<p>mov bl,88h	:bl=10001000</p>
<p>rcl bl,1	:bl=00010000 cf=1	:把最高位1放入cf里，把cf里的数放到最后</p>
<p>rcl bl,1	:bl=00100001 cf=0</p>
<h3 id="shld双精度左移">SHLD双精度左移</h3>
<p>o1=11100000</p>
<p>o2=10011101</p>
<p>o3=1</p>
<p>shld o1,o2,o3	:o3移动位数</p>
<p>移位后</p>
<p>o1最高位放入cf里 	:CF=1</p>
<p>o1=11000001:最后一位1用o2来补上</p>
<h2 id="乘法与除法指令">乘法与除法指令</h2>
<p>无符号 mul div</p>
<p>有符号 imul idiv</p>
<p>乘数 bl bx ebx</p>
<p>被乘数 al ax eax</p>
<p>xor eax,eax</p>
<p>mov al,5h</p>
<p>mov bl,10h</p>
<p>mul bl 	:乘后的数放入al</p>
<p>有符号 imul edx,eax,ebx 	:eax✖ebx---&gt;edx</p>
<p>div 除数 被除数 商 余数</p>
<p>div mem/reg(除数)</p>
<p>被除数ax,dx,ax,eax,edx</p>
<p>8位:商在al 余数在ah</p>
<p>16位:商在ax 余数在dx</p>
<p>32位:商在eax 余数在edx</p>
]]></content>
    </entry>
</feed>