<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>7usai</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="7usai&#39;blog"/>
<meta name="keywords" content="7usai&#39;blog"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://7usai.github.io/favicon.ico">

<link rel="stylesheet" href="https://7usai.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://7usai.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://7usai.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://7usai.github.io/images/avatar.png" alt="7usai"
                 class="img-responsive">
        </figure>
        <a href="https://7usai.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>7usai</h2>
        <p>7usai&#39;blog</p>
        <ul class="fh5co-social">
            
                <li>
                    
                        <a href="https://github.com/7usai" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://7usai.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://7usai.github.io/tag/_wk3DR6W6/">CTF</a></li>
                
                    <li><a href="https://7usai.github.io/tag/7xbgN0lBu/">二进制</a></li>
                
                    <li><a href="https://7usai.github.io/tag/eUcnOz4Tr/">转载</a></li>
                
                    <li><a href="https://7usai.github.io/tag/TEP_9-KfN/">C++</a></li>
                
                    <li><a href="https://7usai.github.io/tag/XKOVycb-9/">语言</a></li>
                
                    <li><a href="https://7usai.github.io/tag/lGYs_sz42/">web</a></li>
                
                    <li><a href="https://7usai.github.io/tag/dcphGguTG/">开发</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://7usai.github.io">7usai </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
                    <img src="https://7usai.github.io/post-images/cxue-xi-zhuan-zai.jpg" alt="C++学习（转载）" class="img-responsive">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
                    <div class="tag-container">
                        
                            <a href="https://7usai.github.io/tag/eUcnOz4Tr/" class="tag">转载, </a>
                        
                    </div>
                
            </span>
            <h2 class="fh5co-article-title animate-box">C++学习（转载）</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-09-01</li>
                <li>19049字</li>
                <li>78 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <p><strong>C****艹学习笔记</strong></p>
<p>本笔记主干基于书籍《C艹面向对象程序设计教程(第4版)》，在此基础上会有所扩展。</p>
<p>内容如有不对之处，希望大家能够指出并私信我。</p>
<p>我的个人博客：https://www.kn0sky.com/</p>
<p>Web版笔记：https://wiki.kn0sky.com/#/note_cpp/README</p>
<p><strong>第一章：面向对象程序设计概述</strong></p>
<p><strong>面向过程与面向对象</strong></p>
<p>面向过程程序设计的主要特征是：程序由 过程定义 和 过程调用 组成</p>
<p>程序 = 过程 + 调用</p>
<p>面向对象程序设计的主要特征是：程序由类的定义和类的使用组成（一切消息由向对象发送消息来实</p>
<p>现，对象收到消息启动相关方法来完成）</p>
<p>程序 = 对象 + 消息</p>
<p><strong>面向对象程序设计基本概念</strong></p>
<p>对象：对象由数据和操作代码组成</p>
<p>类：类是一组对象的抽象</p>
<p>再程序设计中，先声明类，再声明对象</p>
<p>消息与方法：对象收到消息，调用相应的方法</p>
<p><strong>面向对象程序设计基本特征</strong></p>
<p>\1. 抽象：类是对象的抽象，对象是类的实例，抽象分为数据抽象和代码抽象，对应属性与方法</p>
<p>\2. 封装：把方法用函数包起来，使用的时候只需要知道需要的参数，提供了代码的重用性</p>
<p>\3. 继承：继承分为单继承和多继承，子类从单个或多个父类继承数据和方法，同时又与父类有所差别</p>
<p>\4. 多态：不同对象收到相同的消息时执行不同的操作</p>
<p>**第二章：****C++**<strong>概述</strong></p>
<p>C++语言的特点：全面兼容C，并对C进行了扩充</p>
<p><strong>注释行</strong></p>
<p>C++有两种注释方式：</p>
<p>//单行注释</p>
<p>/*多</p>
<p>行</p>
<p>注</p>
<p>释*/多行注释可以嵌套单行注释( // )的注释方式。</p>
<p><strong>C++</strong> <strong>的输入输出</strong></p>
<p>C++ 除了可以使用C语言中使用的 scanf() ， printf() 函数进行输入输出，还增加了使用标准输入流</p>
<p>对象 cin 和标准输出流对象 cout 来进行。</p>
<p>程序示例：</p>
<p>cin反汇编程序：</p>
<p>cout反汇编程序：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a;</p>
<p>cin &gt;&gt; a;</p>
<p>cout &lt;&lt; a;</p>
<p>return 0;</p>
<p>}</p>
<p>int a;</p>
<p>cin &gt;&gt; a;</p>
<p>006718D2 mov esi,esp</p>
<p>;这里将esp栈顶指针放入esi存起来</p>
<p>006718D4 lea eax,[a]</p>
<p>006718D7 push eax</p>
<p>;取变量a的地址放入栈中</p>
<p>006718D8 mov ecx,dword ptr [<em>imp</em>?cin@std@@3V?$basic_istream@DU?</p>
<p>$char_traits@D@std@@@1@A (067B0ACh)]</p>
<p>006718DE call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (067B098h)]</p>
<p>;这里把一个地址的值放到了ecx里，函数调用之后，我们输入数值，数值会存到那个地址里，从而使ecx里的</p>
<p>值变成了我们输入的结果</p>
<p>006718E4 cmp esi,esp</p>
<p>006718E6 call __RTC_CheckEsp (0671235h)</p>
<p>;对比当前栈和函数调用之前是否有变化，检查堆栈平衡</p>
<p>cout &lt;&lt; a;</p>
<p>005447BB mov esi,esp</p>
<p>;存栈顶</p>
<p>005447BD mov eax,dword ptr [a]</p>
<p>005447C0 push eax</p>
<p>;变量a入栈</p>
<p>005447C1 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (054B0B0h)]</p>
<p>;不懂，可能是存储打印是否成功的005447C7 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (054B0A4h)]</p>
<p>;函数调用打印变量的值</p>
<p>005447CD cmp esi,esp</p>
<p>005447CF call __RTC_CheckEsp (0541235h)</p>
<p>;堆栈平衡检查</p>
<p>return 0;</p>
<p>运算符 &gt;&gt; , &lt;&lt; 仍然保持C语言中右移、左移的功能，再用于输入输出时，进行了扩充 cin , cout ，运行</p>
<p>用户输入和输出一连串数据，示例：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a, b, c;</p>
<p>cin &gt;&gt; a &gt;&gt;b &gt;&gt; c;</p>
<p>cout &lt;&lt; a + b &lt;&lt; c;</p>
<p>return 0;</p>
<p>}</p>
<p>输入：需要使用空白符进行分隔（空格，TAB，回车都行）</p>
<p>1 2 3</p>
<p>输出：会从左到右进行输出</p>
<p>33</p>
<p>示例反汇编：</p>
<p>int a, b, c;</p>
<p>cin &gt;&gt; a &gt;&gt;b &gt;&gt; c;</p>
<p>00031882 mov esi,esp</p>
<p>00031884 lea eax,[c]</p>
<p>00031887 push eax</p>
<p>00031888 mov edi,esp</p>
<p>0003188A lea ecx,[b]</p>
<p>0003188D push ecx</p>
<p>0003188E mov ebx,esp</p>
<p>00031890 lea edx,[a]</p>
<p>00031893 push edx</p>
<p>;从右往左的顺序将地址依次入栈，每次入栈前都把栈顶的值取出来，分别放到esi，edi，ebx里</p>
<p>00031894 mov ecx,dword ptr [<em>imp</em>?cin@std@@3V?$basic_istream@DU?</p>
<p>$char_traits@D@std@@@1@A (03B0ACh)]</p>
<p>0003189A call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318A0 cmp ebx,esp</p>
<p>000318A2 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量a，函数调用完会把ecx里存的那个地址放到eax里</p>
<p>000318A7 mov ecx,eax<strong>进制转换</strong></p>
<p>可以通过设置转换基数操纵符dec（十进制），hex（十六进制），oct（八进制）进行进制转换</p>
<p>示例：</p>
<p>反汇编：</p>
<p>000318A9 call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318AF cmp edi,esp</p>
<p>000318B1 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量b</p>
<p>000318B6 mov ecx,eax</p>
<p>000318B8 call dword ptr</p>
<p>[__imp_std::basic_istream&lt;char,std::char_traits<char> &gt;::operator&gt;&gt; (03B098h)]</p>
<p>000318BE cmp esi,esp</p>
<p>000318C0 call __RTC_CheckEsp (031235h)</p>
<p>;从键盘接收变量c</p>
<p>cout &lt;&lt; a + b &lt;&lt; c;</p>
<p>000318C5 mov esi,esp</p>
<p>000318C7 mov eax,dword ptr [c]</p>
<p>000318CA push eax</p>
<p>;变量c放入栈中</p>
<p>000318CB mov ecx,dword ptr [a]</p>
<p>000318CE add ecx,dword ptr [b]</p>
<p>000318D1 mov edi,esp</p>
<p>000318D3 push ecx</p>
<p>;计算a+b然后放入栈中</p>
<p>000318D4 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (03B0B0h)]</p>
<p>000318DA call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (03B0A4h)]</p>
<p>000318E0 cmp edi,esp</p>
<p>000318E2 call __RTC_CheckEsp (031235h)</p>
<p>;输出c的值，同cin，调用完函数后会把原来存到ecx的值放到eax里</p>
<p>000318E7 mov ecx,eax</p>
<p>000318E9 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (03B0A4h)]</p>
<p>000318EF cmp esi,esp</p>
<p>000318F1 call __RTC_CheckEsp (031235h)</p>
<p>;输出a+b的值</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a = 16;</p>
<p>cout &lt;&lt; hex &lt;&lt; a;</p>
<p>return 0;</p>
<p>}<strong>灵活的局部变量</strong></p>
<p>C语言中，局部变量都需要写在程序的最前面，C++中没有这个限制：</p>
<p>像这样在程序中间进行定义变量的行为，在C语言中会报错，在C++中可以正常编译</p>
<p><strong>结构名、联合名、枚举名可以直接作为类型名称</strong></p>
<p>在C语言中，声明了一个结构体，联合体或者枚举类型，在使用的时候，需要在定义变量前面加上结构</p>
<p>名、联合名、枚举名，C++则不需要：</p>
<p>int a = 16;</p>
<p>009520C8 mov dword ptr [a],10h</p>
<p>;赋值</p>
<p>cout &lt;&lt; hex &lt;&lt; a;</p>
<p>009520CF mov esi,esp</p>
<p>009520D1 mov eax,dword ptr [a]</p>
<p>009520D4 push eax</p>
<p>;a入栈</p>
<p>009520D5 mov edi,esp</p>
<p>009520D7 push offset std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::sentry::sentry (09511F4h)</p>
<p>;类型入栈</p>
<p>009520DC mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (095D0DCh)]</p>
<p>009520E2 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (095D0A4h)]</p>
<p>009520E8 cmp edi,esp</p>
<p>009520EA call __RTC_CheckEsp (095128Fh)</p>
<p>;计算进制转换结果，但不知道保存在哪里了</p>
<p>009520EF mov ecx,eax</p>
<p>009520F1 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (095D0A0h)]</p>
<p>009520F7 cmp esi,esp</p>
<p>009520F9 call __RTC_CheckEsp (095128Fh)</p>
<p>;打印输出</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int a = 16;</p>
<p>cout &lt;&lt; dec &lt;&lt; a;</p>
<p>int b;</p>
<p>cin &gt;&gt; b;</p>
<p>return 0;</p>
<p>}<strong>const</strong> <strong>修饰符</strong></p>
<p>C语言中常用 #define 来定义常量，这种方法是在编译的时候进行字符替换，不占用存储单元</p>
<p>C++提供了一种新的方法来定义常量： const 如：</p>
<p>这个常量是有类型，占用存储单元，有地址，可以被指向的，但不能修改。</p>
<p>如果 const 定义的是一个整型常量，关键词int可以忽略。</p>
<p>函数的形参也可以用const说明。</p>
<p><strong>const****与指针：指向常量的指针</strong></p>
<p>声明的常量的值不能改变，但指针可以改变指向</p>
<p><strong>const****与指针：常指针</strong></p>
<p>指针的地址不能改变，指针指的值可以变</p>
<p><strong>const****与指针：指向常量的常指针</strong></p>
<p>enum Bool{FALSE,TRUE};</p>
<p>Bool done;//C++可以这样定义</p>
<p>enum Bool done; //C需要这样定义</p>
<p>const int LIMIT = 99;</p>
<p>const LIMIT =100;//两行等价</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>const char* name = &quot;chen&quot;; //声明一个指向常量的指针</p>
<p>// name[3] = 'a'; const声明的常量的值不能改变</p>
<p>name = &quot;hello&quot;; //指针指向的地址可以改变</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>char st1[] = &quot;hello&quot;;</p>
<p>char * const name = st1; //指向字符地址的常量指针</p>
<p>//常指针固定不能移动，但值可以修改</p>
<p>name[3] = '4';//可以改变内容</p>
<p>//name = &quot;asd&quot;; 不能改变地址</p>
<p>return 0;</p>
<p>}<strong>函数原型</strong></p>
<p>在调用函数之前需要进行函数原型声明</p>
<p>如果调用的函数在调用之前已经声明好了，则不用在做原型声明了</p>
<p>原型声明格式： 返回值类型 函数名（参数表）;</p>
<p>参数表可不包含参数的名字只留下类型（但写上名字更好辨认参数用途）</p>
<p>当参数表为空的时候，C与C++有所不同</p>
<p><strong>内联函数</strong></p>
<p>为了消除函数调用时的系统开销，来提高运行速度，引入了内联函数</p>
<p>在函数说明前冠以关键字 inline ，该函数就是内联函数</p>
<p>使用时，编译器会把形参变成实参，直接在调用处展开</p>
<p>内联函数内一般不能包含复杂控制语句如循环、判断。</p>
<p>例如：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>char st1[] = &quot;hello&quot;;</p>
<p>const char * const name = st1; //常量常指针</p>
<p>//常指针固定不能移动，值也不能改</p>
<p>//name[3] = '4';//可以改变内容</p>
<p>//name = &quot;asd&quot;;// 不能改变地址</p>
<p>return 0;</p>
<p>}</p>
<p>//C语言用的函数声明</p>
<p>int add(int a,int b);</p>
<p>int add();</p>
<p>add();</p>
<p>int add(int,int)</p>
<p>//C:</p>
<p>int add(void);//参数表为空</p>
<p>int add(); //参数表可能有值</p>
<p>//C++</p>
<p>int add(void);</p>
<p>int add();</p>
<p>//都意味着参数表为空会被编译器改成：</p>
<p>理论上是这样的，但我这实际操作里通过反汇编发现内联函数没起作用（我的环境是VS2019）</p>
<p>网上查找资料显示，内联函数知识对编译器的建议，是否内联还得看编译器</p>
<p><strong>带有默认参数的函数</strong></p>
<p>C++允许函数实参和形参个数不同，方法就是在函数定义的时候或声明的时候给形参定义默认值。</p>
<p>当实参不足时，会使用默认值作为实参进行调用</p>
<p>提供默认值的参数应该放在函数参数表的右边，省略参数也只能从右边省略</p>
<p>如果函数定义在调用之前，则应该在函数定义中设置默认值</p>
<p>如果函数定义在调用之后，则应该在函数声明中设置默认值</p>
<p>例如：</p>
<p>反汇编：</p>
<p>inline add(int a,int b){</p>
<p>return a+b;</p>
<p>}</p>
<p>int main(){</p>
<p>int c = add(1,2);</p>
<p>return 0</p>
<p>}</p>
<p>int main(){</p>
<p>int c;</p>
<p>int a=1;</p>
<p>int b=2;</p>
<p>c=a+b;</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int power(int x,int y=2);</p>
<p>int main(){</p>
<p>int i = power(2);</p>
<p>int j = power(2, 3);</p>
<p>return 0;</p>
<p>}</p>
<p>int power(int x, int y) {</p>
<p>int res=1;</p>
<p>for (int i = 0; i &lt; y; i++)</p>
<p>res *= x;</p>
<p>return res;</p>
<p>}</p>
<p>int i = power(2);</p>
<p>00691848 push 2</p>
<p>0069184A push 2<strong>函数的重载</strong></p>
<p>C语言中，函数名必须时唯一的，哪怕相同功能不同类型的参数都不行，但C++可以</p>
<p>C++中，只要函数参数类型不同，或者参数个数不同，或者都有，则可以使用相同函数名</p>
<p>编译器会根据实参的类型和数量来判断调用哪个重载函数</p>
<p>反汇编分析：</p>
<p>0069184C call power (0691389h)</p>
<p>00691851 add esp,8</p>
<p>00691854 mov dword ptr [i],eax</p>
<p>;直接将默认值2入栈进行函数调用</p>
<p>int j = power(2, 3);</p>
<p>00691857 push 3</p>
<p>00691859 push 2</p>
<p>0069185B call power (0691389h)</p>
<p>00691860 add esp,8</p>
<p>00691863 mov dword ptr [j],eax</p>
<p>;按照函数参数逐个入栈进行调用</p>
<p>return 0;</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int mul(float a);</p>
<p>int mul(int a, int b);</p>
<p>int mul(int a, int b, int c);</p>
<p>int main(){</p>
<p>int a1 = mul(1.2);</p>
<p>int a2 = mul(1, 2);</p>
<p>int a3 = mul(1, 2, 3);</p>
<p>cout &lt;&lt; a1 &lt;&lt; ' ' &lt;&lt; a2 &lt;&lt; ' ' &lt;&lt; a3 &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>int mul(float a) {</p>
<p>return a * a;</p>
<p>}</p>
<p>int mul(int a, int b) {</p>
<p>return a * b;</p>
<p>}</p>
<p>int mul(int a, int b, int c) {</p>
<p>return a * b * c;</p>
<p>}</p>
<p>int a1 = mul(1.2);</p>
<p>009B2618 push ecx</p>
<p>009B2619 movss xmm0,dword ptr [__real@3f99999a (09B9B30h)]</p>
<p>009B2621 movss dword ptr [esp],xmm0</p>
<p>009B2626 call mul (09B10D2h)</p>
<p>009B262B add esp,4</p>
<p>009B262E mov dword ptr [a1],eax</p>
<p>;调用了mul:09B10D2h</p>
<p>int a2 = mul(1, 2);</p>
<p>009B2631 push 2</p>
<p>009B2633 push 1说明：</p>
<p>函数返回值不在参数匹配检查范围中，当两个函数只有返回值类型不同时，则不允许重载</p>
<p>函数的重载与带默认值的函数一起用会引起二义性</p>
<p>函数调用时，如果形参和实参类型不同，编译器会自动进行类型转换，转换成功，程序继续执行，</p>
<p>反之则报错</p>
<p><strong>作用域运算符</strong>：：</p>
<p>通常情况下，如果有两个同名变量，一个全局一个局部，那么局部变量在其作用域内拥有高优先级</p>
<p>在变量前面加上作用域运算符 :: 则可以使用全局变量</p>
<p><strong>无名联合</strong></p>
<p>无名联合时C++中的一种特殊联合，它在关键字 union 后面没有给出联合名</p>
<p>在访问无名联合时，不能访问无名联合变量，应该访问联合变量中的成员。</p>
<p><strong>强制类型转换</strong></p>
<p>C语言中的强制类型转换：</p>
<p>C++中的强制类型转换：</p>
<p>两种方法C++都能接收，建议使用后。</p>
<p><strong>运算符<strong><strong>new</strong></strong>和****delete</strong></p>
<p>C语言使用函数 malloc() 和 free() 动态分配内存，C++使用 new , delete</p>
<p>new使用的最基本形式： 指针变量名 = new 类型</p>
<p>在运行过程中，运算符从堆中为程序分配一块与类型大小相同的内存空间，并将内存首地址存于指针变</p>
<p>量中</p>
<p>009B2635 call mul (09B1285h)</p>
<p>009B263A add esp,8</p>
<p>009B263D mov dword ptr [a2],eax</p>
<p>;调用了mul:09B1285h</p>
<p>int a3 = mul(1, 2, 3);</p>
<p>009B2640 push 3</p>
<p>009B2642 push 2</p>
<p>009B2644 push 1</p>
<p>009B2646 call mul (09B1370h)</p>
<p>009B264B add esp,0Ch</p>
<p>009B264E mov dword ptr [a3],eax</p>
<p>;调用了mul:09B1370h</p>
<p>;三次调用了三个不同的函数地址</p>
<p>int i=10;</p>
<p>double a = (double)i;</p>
<p>int i=10;</p>
<p>double a = double(i);运算符delete用于释放运算符new所分配的内存空间，使用形式为： delete 指针变量名</p>
<p>new和malloc相比：</p>
<p>\1. malloc需要使用sizeof函数计算所需要的字节数，new会根据类型自动计算</p>
<p>\2. new能自动返回正确的指针类型，malloc需要进行强制类型转换</p>
<p>说明：</p>
<p>使用new可以为数组动态分配内存空间，只需要在类型名后面加上数组大小：</p>
<p>也可以为多维数组进行动态分配，但必须提供所有维度的大小，其中第一维度的值可以时任意合法</p>
<p>的正整数表达式</p>
<p>new为简单变量分配空间的同时可以进行初始化</p>
<p>但new不能对动态分配的数组进行初始化</p>
<p>释放动态分配数组空间时可用 [] 放到指针变量前来删除</p>
<p>new动态分配内存，当内存空间不足，分配失败，会返回空指针NULL</p>
<p><strong>引用</strong></p>
<p>引用用于给变量起别名。</p>
<p>声明一个引用时，必须同时用另一个变量的名字来将他初始化。</p>
<p>格式为： 类型 &amp;引用名 = 已定义的变量名</p>
<p>仅在声明时候的 &amp; 为引用声明符，其他地方均为取址符。</p>
<p>引用不另开内存单元，变量和引用占用同一个内存空间。</p>
<p>说明：</p>
<p>引用名可以使用任何合法的变量名，除了用作函数参数和返回类型外，在声明引用时必须立即进行</p>
<p>初始化</p>
<p>为引用提供的初始值可以是变量和另一个引用</p>
<p>引用在初始化之后不能被重新声明为另一个变量的引用</p>
<p>不是所有类型的数据都能引用，如下类型不能引用</p>
<p>int* p;</p>
<p>p = new int;</p>
<p>delete p;</p>
<p>int * pi = new int[10];</p>
<p>int * p = new int(12);</p>
<p>delete []p;</p>
<p>int i;</p>
<p>int&amp; j=i;不能建立void类型的引用</p>
<p>不能建立数组类型的引用</p>
<p>不能建立引用的引用</p>
<p>不能建立指向引用的指针（引用本身不是数据类型，没有指针）</p>
<p>可以将引用的地址赋值给指针，指针指向原来的变量</p>
<p><strong>引用作为函数参数</strong></p>
<p>引用的一个主要用途就是作为函数参数，在函数中要对实参进行改变，可以用指针来改变实参的内容，</p>
<p>也可以使用引用来直接对实参进行改变，使函数参数更清晰易懂。</p>
<p>例如：将a变量的值与b变量进行交换</p>
<p><strong>使用引用函数返回值</strong></p>
<p>使用引用可以返回函数的值，可以将函数调用放在赋值表达式的左边</p>
<p><strong>练手习题</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>void swap(int&amp; x, int&amp; y) {</p>
<p>int tmp;</p>
<p>tmp = x;</p>
<p>x = y;</p>
<p>y = tmp;</p>
<p>}</p>
<p>int main(){</p>
<p>int a = 5, b = 10;</p>
<p>cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</p>
<p>swap(a, b);</p>
<p>cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>运行结果：</p>
<p>5 10</p>
<p>10 5</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int a[] = { 1,2,3,4,5 };</p>
<p>int&amp; index(int i) { //返回值为引用</p>
<p>return a[i];</p>
<p>}</p>
<p>int main(){</p>
<p>index(2) = 99; //返回的使a[2]的引用</p>
<p>cout &lt;&lt; index(2) &lt;&lt; endl;</p>
<p>cout &lt;&lt; a[2] &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}一、编写一个C++风格程序，解决百钱问题：将一元RMB兑换成1、2、5分的硬币，有几种换法？</p>
<p><strong>第三章：类和对象</strong></p>
<p>类是C++最强有力的特征。</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main(){</p>
<p>int sum = 0;</p>
<p>int coin1 = 100;</p>
<p>int coin2 = 50;</p>
<p>int coin5 = 20;</p>
<p>for (int i = 0; i &lt;= coin1; i++) {</p>
<p>for (int j = 0; j &lt;= coin2; j++) {</p>
<p>for (int k = 0; k &lt;= coin5; k++) {</p>
<p>if (i + 2 * j + 5 * k == 100) {</p>
<p>sum++;</p>
<p>cout &lt;&lt; &quot;一分硬币：&quot; &lt;&lt; i &lt;&lt; &quot; 二分硬币：&quot; &lt;&lt; j &lt;&lt; &quot; 五分硬币：&quot;</p>
<p>&lt;&lt; k &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout&lt;&lt;&quot;总共排列种类有：&quot;&lt;&lt;sum&lt;&lt;&quot;种&quot;&lt;&lt;endl;</p>
<p>return 0;</p>
<p>}结构体的扩充</p>
<p>C++语言对C的结构体类型进行了扩充，不仅可以含有数据，还可以含有函数，结构体中的数据叫做数</p>
<p>据成员，函数则叫成员函数。</p>
<p>访问成员函数需要先定义该结构体类型的变量。</p>
<p>结构体的声明例如：</p>
<p>调用成员函数：</p>
<p><strong>类的声明</strong></p>
<p>struct npc{</p>
<p>int hp;</p>
<p>int mp;</p>
<p>void initv(int hp_value,int mp_value){</p>
<p>hp = hp_value;</p>
<p>mp = mp_value;</p>
<p>}</p>
<p>};</p>
<p>npc A;</p>
<p>A.initv(100,100);C++提供了一种比结构体更安全有效的类型：类，与结构体的扩充十分相似，结构体是为了兼容C而进</p>
<p>行了扩充，类是C++风格的数据类型</p>
<p>类与结构体的扩充功能几乎一样，但有一点不同：类默认成员是private属性，结构体默认是public属</p>
<p>性，类提供了默认的安全性。</p>
<p>private和public是成员限定符，声明成员的访问属性。</p>
<p>声明一个类相当于声明了一个类型。</p>
<p>类的声明一般如下：</p>
<p>成员限定符有三种：</p>
<p>private：私有成员只能由本类的成员函数访问，类外部的访问都是非法的</p>
<p>public：公有成员既可以由本类成员访问，也可以由外部访问</p>
<p>是对外界的接口，来自类外的对私有成员的访问需要通过接口进行</p>
<p>protected：保护成员可以由本类成员函数访问，也可以由派生类成员函数访问</p>
<p>类声明中的这三个部分不需要全都有，也没有顺序限制</p>
<p>数据成员不能用自动、寄存器和外部进行说明</p>
<p><strong>成员函数的定义</strong></p>
<p>类的成员函数是函数的一种，用法与普通函数一样</p>
<p>私有的成员函数只能被本类中的其他成员函数调用，不能被外部访问，公有的都行</p>
<p><strong>定义方式<strong><strong>1</strong></strong>：普通成员函数</strong></p>
<p>在类声明中给出成员函数原型，而将成员函数定义在类的外部</p>
<p>形式如下：</p>
<p>作用域运算符 :: 表示该函数属于类</p>
<p>在类声明中，成员函数原型参数表可以只写类型</p>
<p>在外部声明，成员函数定义需要写出参数名</p>
<p><strong>定义方式<strong><strong>2</strong></strong>：内联成员函数</strong></p>
<p>可以直接将成员函数定义在类的内部，这种定义方式没有使用inline进行声明，属于隐式定义。</p>
<p>也可以在类内声明函数原型，在类外定义函数，但在类内函数原型声明和类外函数定义处需要加上</p>
<p>inline，这是显式定义（可以两处都写inline，也可以只写一处）。</p>
<p>定义内联函数时，必须将类的声明和内联函数的定义放在同一个文件中。</p>
<p>class 类名{</p>
<p>private:</p>
<p>私有成员;</p>
<p>public:</p>
<p>公有成员;</p>
<p>};</p>
<p>返回值类型 类名：：成员函数名（参数表）{</p>
<p>函数体</p>
<p>}<strong>对象的定义以及使用</strong></p>
<p>对象的定义由以下两种方法：</p>
<p>\1. 直接在声明的同时进行定义,只需要在定义完成的右括号后面写上变量名即可</p>
<p>\2. 声明了类以后，使用类名进行定义 类名 对象名;</p>
<p>对对象中成员的访问由以下三种方法：</p>
<p>\1. 使用对象选择符 . 进行访问</p>
<p>\2. 如果定义的时对象指针，则需要通过 -&gt; 进行访问</p>
<p>\3. 也可以通过引用访问对象中的成员</p>
<p>程序示例：对象中成员的访问</p>
<p>class npc{</p>
<p>private:</p>
<p>int hp;</p>
<p>int mp;</p>
<p>public:</p>
<p>int initv();</p>
<p>}npcA,npcB;</p>
<p>npc npcA;</p>
<p>对象.数据成员</p>
<p>对象.成员函数(参数表)</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class Point {</p>
<p>private:</p>
<p>int x;</p>
<p>int y;</p>
<p>public:</p>
<p>void setpoint(int a, int b) {</p>
<p>x = a;</p>
<p>y = b;</p>
<p>}</p>
<p>int getx() {</p>
<p>return x;</p>
<p>}</p>
<p>int gety() {</p>
<p>return y;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>Point op1;</p>
<p>op1.setpoint(1, 2);</p>
<p>int op1x;</p>
<p>op1x = op1.getx();</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}反汇编分析：</p>
<p>Point op1;</p>
<p>op1.setpoint(1, 2);</p>
<p>001918F2 push 2</p>
<p>001918F4 push 1</p>
<p>001918F6 lea ecx,[op1]</p>
<p>001918F9 call std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::_Sentry_base::~_Sentry_base (0191447h)</p>
<p>;参数入栈，将对象op1的地址存到ecx，调用成员函数</p>
<p>;成员函数</p>
<p>void setpoint(int a, int b) {</p>
<p>...</p>
<p>;此处省略函数调用前的初始化，this是对象op1的首地址</p>
<p>x = a;</p>
<p>0019211D mov eax,dword ptr [this]</p>
<p>;将对象x数据成员首地址拿出来</p>
<p>00192120 mov ecx,dword ptr [a]</p>
<p>;把a的值拿出来</p>
<p>00192123 mov dword ptr [eax],ecx</p>
<p>;给对象x数据成员赋值</p>
<p>y = b;</p>
<p>00192125 mov eax,dword ptr [this]</p>
<p>00192128 mov ecx,dword ptr [b]</p>
<p>0019212B mov dword ptr [eax+4],ecx</p>
<p>}</p>
<p>int op1x;</p>
<p>op1x = op1.getx();</p>
<p>001918FE lea ecx,[op1]</p>
<p>00191901 call std::basic_ostream&lt;char,std::char_traits<char></p>
<p>&gt;::sentry::sentry (019144Ch)</p>
<p>;把对象地址存入ecx，进入函数调用</p>
<p>;函数调用</p>
<p>int getx(){</p>
<p>...</p>
<p>00191F9F pop ecx</p>
<p>00191FA0 mov dword ptr [this],ecx</p>
<p>;把ecx取出来，放到this指针里</p>
<p>00191FA3 mov ecx,19F026h</p>
<p>00191FA8 call @__CheckForDebuggerJustMyCode@4 (019127Bh)</p>
<p>return x;</p>
<p>00191FAD mov eax,dword ptr [this]</p>
<p>00191FB0 mov eax,dword ptr [eax]</p>
<p>;把指针的地址存入eax，然后将该地址的值赋给eax</p>
<p>}</p>
<p>00191906 mov dword ptr [op1x],eax</p>
<p>;从eax取出刚刚函数调用得到的值x，存入变量op1x中</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>00191909 mov esi,espthis指针相关见this指针</p>
<p><strong>对象初始化</strong></p>
<p>对象初始化方法如下：</p>
<p>通过构造函数来对数据成员进行赋值操作</p>
<p>当数据成员为const或引用类型，则需要通过成员初始化列表对数据成员初始化</p>
<p><strong>构造函数</strong></p>
<p>在类的声明中不能给数据成员赋值。</p>
<p>在定义对象时给数据成员赋值叫做对象的初始化。</p>
<p>如果一个类所有成员都是公有的，则可以通过类似结构体初始化的方式赋值：</p>
<p>也可以采用公有成员函数来对数据成员进行赋初值。</p>
<p>C++提供了构造函数来进行初始化工作：</p>
<p>构造函数名字必须与类名相同</p>
<p>可以有任意类型参数</p>
<p>不能有返回值</p>
<p>不需要调用，创建对象时自动执行，且只执行一次</p>
<p>可以写在类内（内联函数）也可以写在类外</p>
<p>0019190B push offset std::operator&lt;&lt;&lt;std::char_traits<char> &gt; (01912A8h)</p>
<p>00191910 mov edi,esp</p>
<p>00191912 mov eax,dword ptr [op1x]</p>
<p>00191915 push eax</p>
<p>00191916 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (019D0D8h)]</p>
<p>;先后入栈endl和变量op1x</p>
<p>0019191C call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (019D0A0h)]</p>
<p>00191922 cmp edi,esp</p>
<p>00191924 call __RTC_CheckEsp (0191285h)</p>
<p>00191929 mov ecx,eax</p>
<p>0019192B call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (019D0A4h)]</p>
<p>cout &lt;&lt; op1x &lt;&lt; endl;</p>
<p>;连续两次调用显示函数，依次显示变量和换行</p>
<p>00191931 cmp esi,esp</p>
<p>00191933 call __RTC_CheckEsp (0191285h)</p>
<p>return 0;</p>
<p>00191938 xor eax,eax</p>
<p>}</p>
<p>class npc{</p>
<p>public:</p>
<p>int hp;</p>
<p>int mp;</p>
<p>};</p>
<p>npc npcA(100,100);一般声明为公有成员</p>
<p>构造函数可以不带参数，但这样对对象的初始化时固定的</p>
<p>定义形式如下：</p>
<p><strong>用成员初始化列表对数据成员初始化</strong></p>
<p>当数据成员为const或引用类型，则需要通过成员初始化列表对数据成员初始化</p>
<p>一般形式如下：</p>
<p>数据成员是按照他们在类中声明的顺序进行初始化，与成员初始化列表出现顺序无关。</p>
<p>从反汇编来看，操作与函数赋值一样。</p>
<p><strong>构造函数的重载</strong></p>
<p>与普通函数一样，构造函数也能进行重载，对每一个对象来说，构造函数只会执行一次，比如当创建对</p>
<p>象通过参数给数据成员赋值，不提供参数赋值默认值，提供参数则赋值参数值。</p>
<p>使用无参数构造函数创建对象时（比如类是Point），应该用语句 Point OP1; 而不加后面的括号，使用</p>
<p>参数赋值的话则是 Point OP2(2,3);</p>
<p><strong>带默认参数的构造函数</strong></p>
<p>对于带参数的构造函数，可以直接定义成带默认参数的构造函数。</p>
<p>构造函数的重载和有默认参数的构造函数不能同时用。</p>
<p>如果构造函数在类外进行定义，则默认参数应该写在类内的函数原型里：</p>
<p>//类名 对象名(实参表);</p>
<p>//类名 * 指针变量名 = new 类名(实参表);</p>
<p>//定义无名对象，通过指针访问，new建立，不用时用delete删除</p>
<p>/*</p>
<p>类名::构造函数名([参数表])[成员初始化列表]{</p>
<p>构造函数体</p>
<p>}</p>
<p>*/</p>
<p>//成员初始化列表形式为：</p>
<p>//数据成员1（初始值1），数据成员2（初始值2）...</p>
<p>calss A{</p>
<p>public:</p>
<p>A(int a,int b):a(0),b(1){}</p>
<p>private:</p>
<p>int a;</p>
<p>int b;</p>
<p>}<strong>析构函数</strong></p>
<p>与构造函数相对的是析构函数，用来清理空间。</p>
<p>析构函数：</p>
<p>析构函数名与类名相同，但前面需要加一个波浪号~</p>
<p>同构造函数，不返回任何值，不用写返回值类型</p>
<p>析构函数没有参数，不能被重载</p>
<p>撤销对象时，系统自动调用析构函数</p>
<p>每个类必须有一个析构函数</p>
<p>在以下情况，析构函数也会被调用：</p>
<p>如果对象被定义在一个函数里，当这个函数调用结束，对象将被释放，析构函数自动调用</p>
<p>如果对象时使用new运算符动态创建的，当使用delete释放的时候会调用析构函数</p>
<p>程序实例：构造函数与析构函数</p>
<p>反汇编分析：</p>
<p>calss A{</p>
<p>public:</p>
<p>A(int a=1,int b=2);</p>
<p>private:</p>
<p>int a;</p>
<p>int b;</p>
<p>}</p>
<p>A::A(int a,int b){</p>
<p>//函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class addnum {</p>
<p>public:</p>
<p>addnum(int a, int b) :x(a), y(b) {</p>
<p>cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>~addnum() {</p>
<p>cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>int getxaddy() {</p>
<p>return x + y;</p>
<p>}</p>
<p>private:</p>
<p>int x;</p>
<p>int y;</p>
<p>};</p>
<p>int main() {</p>
<p>addnum* p;</p>
<p>p = new addnum(1,2);</p>
<p>int c = p-&gt;getxaddy();</p>
<p>delete p;</p>
<p>return 0;</p>
<p>}addnum* p;</p>
<p>p = new addnum(1,2);</p>
<p>00B82857 push 8</p>
<p>00B82859 call operator new (0B813B1h)</p>
<p>00B8285E add esp,4</p>
<p>;开辟一片空间，将成功与否写在eax里</p>
<p>00B82861 mov dword ptr [ebp-0F8h],eax</p>
<p>00B82867 mov dword ptr [ebp-4],0</p>
<p>00B8286E cmp dword ptr [ebp-0F8h],0</p>
<p>00B82875 je main+7Eh (0B8288Eh)</p>
<p>;eax的值存在ebp-0F0h里，如果这里的值等于0，则跳转到main+7h</p>
<p>00B82877 push 2</p>
<p>00B82879 push 1</p>
<p>00B8287B mov ecx,dword ptr [ebp-0F8h]</p>
<p>00B82881 call addnum::addnum (0B81384h)</p>
<p>;参数入栈函数调用</p>
<p>addnum(int a, int b) :x(a), y(b) {</p>
<p>00B820E0 mov dword ptr [this],ecx</p>
<p>00B820E3 mov ecx,offset _580C3C40_main@cpp (0B8F026h)</p>
<p>00B820E8 call @__CheckForDebuggerJustMyCode@4 (0B812DAh)</p>
<p>;把ecx（申请的空间首地址）存入this指针，然后进行一个检查，不管他</p>
<p>00B820ED mov eax,dword ptr [this]</p>
<p>00B820F0 mov ecx,dword ptr [a]</p>
<p>00B820F3 mov dword ptr [eax],ecx</p>
<p>;存入变量a</p>
<p>00B820F5 mov eax,dword ptr [this]</p>
<p>00B820F8 mov ecx,dword ptr [b]</p>
<p>00B820FB mov dword ptr [eax+4],ecx</p>
<p>;往后挪4位存入变量b</p>
<p>...</p>
<p>;省略cout部分</p>
<p>00B82886 mov dword ptr [ebp-100h],eax</p>
<p>; eax是创建的对象的首地址</p>
<p>00B8288C jmp main+88h (0B82898h)</p>
<p>00B8288E mov dword ptr [ebp-100h],0 ;这行被跳过，在申请空间失败的时候会跳转到</p>
<p>此处</p>
<p>00B82898 mov eax,dword ptr [ebp-100h]</p>
<p>;ebp-100h是对象首地址，存入eax</p>
<p>00B8289E mov dword ptr [ebp-0ECh],eax</p>
<p>00B828A4 mov dword ptr [ebp-4],0FFFFFFFFh</p>
<p>00B828AB mov ecx,dword ptr [ebp-0ECh]</p>
<p>00B828B1 mov dword ptr [p],ecx</p>
<p>;将对象首地址存入指针p中</p>
<p>int c = p-&gt;getxaddy();</p>
<p>00B828B4 mov ecx,dword ptr [p]</p>
<p>00B828B7 call addnum::getxaddy (0B810FAh)</p>
<p>00B828BC mov dword ptr [c],eax</p>
<p>;调用函数将返回值存入eax，从eax取出存入变量c</p>
<p>delete p;</p>
<p>008D653F mov eax,dword ptr [p]</p>
<p>008D6542 mov dword ptr [ebp-104h],eax</p>
<p>008D6548 cmp dword ptr [ebp-104h],0</p>
<p>008D654F je main+0D6h (08D6566h)</p>
<p>;判断p是否是空指针，是就跳转构造函数负责初始化数据成员，析构函数用来清除对对象的指向清理空间</p>
<p><strong>对象数组</strong></p>
<p>就是由对象组成的数组，每个元素是一个对象，每个元素创建的时候会调用构造函数，删除时调用析构</p>
<p>函数。</p>
<p>由对象构成的数组，如果构造函数只有一个参数可通过以下方式来赋值</p>
<p>可通过构造函数的重载来设置有一个参数和没有参数的赋值，在定义对象数组时，如下，前两个对象调</p>
<p>用有参数的构造函数，后两个对象调用无参数构造函数：</p>
<p>如果构造函数有多个参数，可以这样定义对象数组：</p>
<p><strong>对象指针</strong></p>
<p>指针就是通过内存地址访问对象</p>
<p><strong>用指针访问单个对象成员</strong></p>
<p>008D6551 push 1</p>
<p>008D6553 mov ecx,dword ptr [ebp-104h]</p>
<p>008D6559 call addnum::`scalar deleting destructor' (08D14BAh)</p>
<p>;析构函数调用</p>
<p>008D655E mov dword ptr [ebp-10Ch],eax</p>
<p>008D6564 jmp main+0E0h (08D6570h)</p>
<p>008D6566 mov dword ptr [ebp-10Ch],0</p>
<p>return 0;</p>
<p>008D6570 xor eax,eax</p>
<p>}</p>
<p>008D1F00 mov dword ptr [this],ecx</p>
<p>008D1F03 mov ecx,dword ptr [this]</p>
<p>008D1F06 call addnum::~addnum (08D14B5h)</p>
<p>;调用析构函数之后，p指针不见了，然后内存的内容还在</p>
<p>008D1F0B mov eax,dword ptr [ebp+8]</p>
<p>008D1F0E and eax,1</p>
<p>008D1F11 je addnum::`scalar deleting destructor'+41h (08D1F21h)</p>
<p>008D1F13 push 8</p>
<p>008D1F15 mov eax,dword ptr [this]</p>
<p>008D1F18 push eax</p>
<p>008D1F19 call operator delete (08D12CBh)</p>
<p>;调用delete操作后，内存空间的内容被覆盖清空</p>
<p>008D1F1E add esp,8</p>
<p>008D1F21 mov eax,dword ptr [this]</p>
<p>point ob1[4]={1,2,3,4};</p>
<p>point ob1[4]={1,2};</p>
<p>point ob2[2]={</p>
<p>point(1,2,3),</p>
<p>point(2,3,4)</p>
<p>}一般用 . 来访问对象成员，用指针访问的话用 -&gt;</p>
<p><strong>用对象指针访问对象数组</strong></p>
<p>定义一个对象指针，把对象数组赋值给对象指针：</p>
<p>这时p指向数组第一个元素的地址，当p+1则指向下一个元素的地址（地址偏移量不用自己算）</p>
<p><strong>this****指针</strong></p>
<p>从一个类中建立多个对象之后，不同对象的数据成员是不同的，会占用不同的内存空间，但是成员函数</p>
<p>一般是一样的，所以共用一块内存空间</p>
<p>this指针也叫自引用指针，在对对象进行函数调用的时候，程序会往this指针赋值为当前对象的首地</p>
<p>址，所以调用的时候，this可以区分不同对象的数据</p>
<p><strong>string</strong> <strong>类</strong></p>
<p>C++支持两种类型的字符串：</p>
<p>\1. C语言中的以\0结尾的字符数组</p>
<p>\2. C++表转库中的string类型</p>
<p>前者可以混在后者里进行运算</p>
<p>运算符同普通变量一样</p>
<p>使用string需要包含库文件： #include<string></p>
<p>定义和初始化：</p>
<p><strong>向函数传递对象</strong></p>
<p><strong>使用对象作为参数</strong></p>
<p>把实参赋给形参，形参进行改变，但不改变实参本身，是一种单向传递。</p>
<p>实际上是调用拷贝构造函数用实参初始化形参，详见拷贝构造函数</p>
<p><strong>使用对象指针作为参数</strong></p>
<p>把对象地址作为参数，函数改变的则是地址的内容，会改变对象本身。</p>
<p><strong>使用对象引用作为参数</strong></p>
<p>把对象引用作为参数，对象引用其实就是对象本身，函数改变的也是对象本身。</p>
<p><strong>对象的赋值</strong></p>
<p>当两个对象类型相同时，可通过 = 进行赋值：</p>
<p>point arr[4];</p>
<p>point* p;</p>
<p>p = arr;</p>
<p>string str1;</p>
<p>string str2(&quot;123&quot;);</p>
<p>string str3=&quot;1234&quot;;赋值操作仅仅是让两个对象的数据成员相同。</p>
<p>赋值通过赋值运算符函数实现（第五章）</p>
<p>当类中存在指针，可能会发生错误。</p>
<p><strong>拷贝构造函数</strong></p>
<p>拷贝构造函数是一种特殊的构造函数：</p>
<p>形参时本类对象的引用，和构造函数一样没有返回值类型，函数名为类名，可以自定义，也可以默</p>
<p>认生成，但必须有</p>
<p>用于在建立新的对象时用本对象去进行初始化</p>
<p><strong>自定义拷贝构造函数</strong></p>
<p>我们可以选择自己去定义拷贝构造函数，用一个对象去初始化另一个对象</p>
<p>初始化有两种方式：</p>
<p>类名 对象2（对象1）;</p>
<p>类名 对象2=对象1;</p>
<p>示例：</p>
<p>B=A</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class point {</p>
<p>public:</p>
<p>point(int a, int b) :x(a), y(b) {}</p>
<p>point(point&amp; p) {</p>
<p>x = p.x + 1;</p>
<p>y = p.y + 2;</p>
<p>} //拷贝构造函数传递的参数是本类的对象</p>
<p>int getsum() {</p>
<p>return x + y;</p>
<p>}</p>
<p>private:</p>
<p>int x, y;</p>
<p>};</p>
<p>int main() {</p>
<p>point op1(1, 2);</p>
<p>point op2 = op1;//初始化方法1</p>
<p>point op3(op2);//初始化方法2</p>
<p>cout &lt;&lt; op1.getsum() &lt;&lt; endl;</p>
<p>cout &lt;&lt; op2.getsum() &lt;&lt; endl;</p>
<p>cout &lt;&lt; op3.getsum() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}<strong>默认拷贝构造函数</strong></p>
<p>如果没有自定义拷贝构造函数，则系统会自动生成一个拷贝构造函数，用于将对象的数据成员一一赋</p>
<p>值。</p>
<p>如果类中有指针类型，调用默认拷贝构造函数可能会报错。</p>
<p><strong>调用拷贝构造函数的三种清空</strong></p>
<p>\1. 用类中的一个对象初始化另一个对象时</p>
<p>\2. 函数的形参是对象时</p>
<p>\3. 当函数的返回值时对象时</p>
<p>此时，函数执行结束后会将数值存到临时对象里，用于接收返回值对象的赋值，赋值完成后，临时</p>
<p>对象也会消失</p>
<p><strong>静态成员</strong></p>
<p>用于实现一个类中各个对象之间的的成员共享，C++提出了静态成员的概念</p>
<p><strong>静态数据成员</strong></p>
<p>将类内的数据成员定义前面加上 static ，则定义为静态数据成员</p>
<p>静态数据成员相当于类内的“全局变量”</p>
<p>初始化需要在类外单独进行，通过 类型 类名：：变量名 来进行访问</p>
<p>公有的静态数据成员可通过 ：： 来访问，也可通过对象访问，私有的静态数据成员只能通过公有的成员</p>
<p>函数进行访问。</p>
<p><strong>静态成员函数</strong></p>
<p>将类内的成员函数<strong>原型声明前面</strong>加上 static ，则定义为静态成员函数</p>
<p>是类中所有对象的共享函数，用于访问静态数据成员</p>
<p>私有静态成员函数不能做类外的函数和对象访问</p>
<p>可以用在定义对象之前调用，处理静态数据成员</p>
<p>编译系统将静态成员函数限定为内部连接</p>
<p>静态成员函数没有this指针，如果用来访问非静态成员，可以通过将目标的引用作为参数输入</p>
<p><strong>示例</strong></p>
<p>运行结果：</p>
<p>3</p>
<p>6</p>
<p>9</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class stu_information {</p>
<p>public:</p>
<p>stu_information(string name, float score);<strong>友元</strong></p>
<p>void show();</p>
<p>static void showall();</p>
<p>private:</p>
<p>string name;//名字</p>
<p>float score;//分数</p>
<p>static float average_sum;//平均分数</p>
<p>static int count;//人数</p>
<p>static float sum;//分总和</p>
<p>};</p>
<p>stu_information::stu_information(string name1, float score1) {</p>
<p>name = name1;</p>
<p>score = score1;</p>
<p>count++;</p>
<p>sum += score;</p>
<p>average_sum = sum / count;</p>
<p>}</p>
<p>void stu_information::show() {</p>
<p>cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; score &lt;&lt; endl;</p>
<p>}</p>
<p>void stu_information::showall() { //访问静态数据成员</p>
<p>cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;总人数：&quot; &lt;&lt; count &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;平均分：&quot; &lt;&lt; average_sum &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>//初始化静态数据成员</p>
<p>int stu_information::count = 0;</p>
<p>float stu_information::sum = 0.0;</p>
<p>float stu_information::average_sum = 0.0;</p>
<p>int main() {</p>
<p>stu_information::showall();</p>
<p>stu_information stu1(&quot;张三&quot;,88);</p>
<p>stu_information* stu2 = new stu_information(&quot;张四&quot;,93);</p>
<p>stu1.show();</p>
<p>stu2-&gt;show();</p>
<p>stu_information::showall();</p>
<p>return 0;</p>
<p>}</p>
<p>运行结果：</p>
<p>----------</p>
<p>总人数：0</p>
<p>平均分：0</p>
<p>----------</p>
<p>张三:88</p>
<p>张四:93</p>
<p>----------</p>
<p>总人数：2</p>
<p>平均分：90.5</p>
<p>----------友元是用来在类外访问类内的私有部分的辅助手段。</p>
<p>声明了友元函数的类中的数据可以被友元函数访问。</p>
<p><strong>友元函数</strong></p>
<p>友元函数是类外的一个函数，需要在类内函数声明前面加上 friend 来标识，参数接收类的对象，可用</p>
<p>于访问该类的私有数据成员。</p>
<p>一个函数需要访问多个类的时候，友元函数就很方便。</p>
<p><strong>将非成员函数声明成友元函数</strong></p>
<p><strong>将成员函数声明成友元函数</strong></p>
<p>一个类想要通过自己的成员函数访问另一个类的私有数据成员，可通过往另一个类中声明友元函数来实</p>
<p>现。</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class gril {</p>
<p>public:</p>
<p>gril(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>friend void disp(const gril&amp;);//友元函数声明</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>void disp(const gril&amp; x) {//友元函数定义</p>
<p>cout &lt;&lt; x.name &lt;&lt; &quot;:&quot; &lt;&lt; x.age &lt;&lt; endl;//访问对象的数据时需要用对象名.成员来进行访</p>
<p>问</p>
<p>}</p>
<p>int main() {</p>
<p>gril A(&quot;LiHua&quot;, 15);</p>
<p>disp(A);</p>
<p>return 0;</p>
<p>}</p>
<p>LiHua:15</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class boy;</p>
<p>class gril {</p>
<p>public:</p>
<p>gril(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;<strong>友元类</strong></p>
<p>类之间也可以做友元，通过 friend 类名 来声明，可以声明在私有部分也可以在公有部分。</p>
<p>一个类作为另一个类的友元，相当与把一个类的成员函数都变成了另一个类的友元函数：</p>
<p>也就是：写friend的地方的成员可以被friend后面跟着的类或函数所访问</p>
<p>说明：</p>
<p>友元关系是单向的，写friend的那个类只能被访问</p>
<p>友元关系不具有传递性，A是B的友元，B是C的友元，A不是C的友元</p>
<p><strong>类的组合</strong></p>
<p>可以用一个类的对象作为另一个类的成员，称为类的组合，内嵌对象称为对象成员，也叫子对象。</p>
<p>对象成员的初始化通过构造函数初始化表来进行（类似于前面提到的成员初始化列表）。</p>
<p>构造函数会依次对成员进行初始化然后再执行函数体内容</p>
<p>}</p>
<p>void disp(boy&amp; );//disp为类gril的成员函数</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>class boy {</p>
<p>public:</p>
<p>boy(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>friend void gril::disp(boy&amp;);//作为boy的友元函数，可以访问boy的私有成员</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>};</p>
<p>void gril::disp(boy&amp; x) { //成员函数声明</p>
<p>cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; age &lt;&lt; endl;</p>
<p>cout &lt;&lt; x.name &lt;&lt; &quot;:&quot; &lt;&lt; x.age &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>gril A(&quot;LiHua&quot;, 15);</p>
<p>boy B(&quot;ZhangSan&quot;, 42);</p>
<p>A.disp(B);</p>
<p>return 0;</p>
<p>}</p>
<p>LiHua:15</p>
<p>ZhangSan:42</p>
<p>#include<iostream>其中，构造函数：</p>
<p>对象定义：</p>
<p><strong>常类型</strong></p>
<p><strong>常引用</strong></p>
<p>说明引用时前面用const修饰</p>
<p>用于作函数的形参，可以避免对实参的修改</p>
<p><strong>常对象</strong></p>
<p>说明对象时前面用const修饰</p>
<p>数据成员的值在整个生存周期不能被改变，在定义时必须进行初始化</p>
<p><strong>常数据成员</strong></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class sorces {</p>
<p>private:</p>
<p>float computer;</p>
<p>float english;</p>
<p>float math;</p>
<p>public:</p>
<p>sorces(float c, float e, float m):computer(c),english(e),math(m){}</p>
<p>void dispc() {</p>
<p>cout &lt;&lt; computer &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class stuinfo {</p>
<p>private:</p>
<p>string name;</p>
<p>sorces sorce;</p>
<p>public:</p>
<p>stuinfo(string n, float c, float e, float m) :name(n), sorce(c, e, m) {}</p>
<p>void dispc() {</p>
<p>cout &lt;&lt; name &lt;&lt; endl;</p>
<p>sorce.dispc();</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>stuinfo A(&quot;LiHua&quot;, 66, 77, 88);</p>
<p>A.dispc();</p>
<p>return 0;</p>
<p>}</p>
<p>stuinfo(string n, float c, float e, float m) :name(n), sorce(c, e, m) {}</p>
<p>stdinfo A(&quot;LiHua&quot;,66,77,88);说明数据成员时前面用const修饰</p>
<p>只能通过成员初始化列表进行初始化，任何函数都不能进行赋值</p>
<p><strong>常成员函数</strong></p>
<p>说明成员函数时<strong>后面</strong>用const修饰</p>
<p>在声明函数和定义函数的时候都要用关键字const说明</p>
<p>常成员函数可以访问常数据成员也可以访问普通数据成员</p>
<p>常对象只能调用常成员函数，且常成员函数不能更新数据成员的值</p>
<p><strong>第四章：派生类与继承</strong></p>
<p>继承，允许在已有类的基础上创建新的类，新类可以从一个或多个已有类中继承函数和数据，还可以加</p>
<p>进新的成员</p>
<p>已有类称为基类或父类，新类称为派生类或子类。</p>
<p><strong>派生类的构成</strong></p>
<p>构造一个派生类分以下三部分工作：</p>
<p>\1. 派生类从基类接收全部成员（除构造函数和析构函数，这两个需要在派生类重新定义）</p>
<p>\2. 调整从基类接收的成员</p>
<p>\1. 改变成员的访问属性（通过声明的继承方式来改变）</p>
<p>\2. 对基类成员进行重定义（使用相同成员名可覆盖原成员，函数需要参数表也相同）</p>
<p>\3. 在派生类增加新的成员</p>
<p><strong>派生类的声明</strong></p>
<p>class 派生类名：[继承方式] 基类名{</p>
<p>新增的数据成员和成员函数</p>
<p>}继承有三类：</p>
<p>public：公有继承【除了私有成员以外的所有成员访问属性不变】</p>
<p>private：私有继承【除了私有成员以外的所有成员访问属性变私有】</p>
<p>protected：保护继承【除了私有成员以外的所有成员访问属性变保护】</p>
<p>私有成员继承后均变不可访问属性</p>
<p>访问属性：</p>
<p>公有：可内部和外部访问</p>
<p>私有：仅可本类内部访问，不可外部访问</p>
<p>保护：可本类和派生类内部访问，不可外部访问</p>
<p><strong>派生类对基类成员访问规则</strong></p>
<p><strong>私有继承的访问规则</strong></p>
<p>私有继承后，基类公有、保护成员全变私有，私有变不可访问</p>
<p>在派生类中只能通过父类的成员函数来访问父类的私有成员</p>
<p>私有继承之后，再次继承会使得父类成员全部不可访问</p>
<p><strong>公有继承的访问规则</strong></p>
<p>公有继承后，基类公有、保护成员属性不变，私有变不可访问</p>
<p>在派生类中只能通过父类的成员函数来访问父类的私有成员</p>
<p><strong>保护继承的访问规则</strong></p>
<p>保护继承后，基类公有、保护成员全变保护，私有变不可访问</p>
<p>举例：继承的使用</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class person {</p>
<p>private:</p>
<p>string name;</p>
<p>int age;</p>
<p>protected:</p>
<p>void setinfo(string name1, int age1) {</p>
<p>name = name1;</p>
<p>age = age1;</p>
<p>}</p>
<p>void getinfo() {</p>
<p>cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class student :public person {</p>
<p>protected:</p>
<p>float sorces;</p>
<p>public:</p>
<p>void setinfo1(string n, int a, float s) {</p>
<p>setinfo(n, a);//调用基类的函数访问基类的私有成员<strong>派生类的构造函数和析构函数</strong></p>
<p>当基类的构造函数没有参数或者没有显式定义，派生类可以不向基类传递参数，也可以不定义构造函数</p>
<p>派生类的构造函数格式如下：</p>
<p><strong>与使用成员初始化列表初始化类非常相似</strong></p>
<p>当构造函数定义在外部时，类内声明不需要写初始化列表</p>
<p>构造函数与析构函数的执行顺序：</p>
<p>\1. 基类的构造函数</p>
<p>\2. 派生类的构造函数</p>
<p>\3. 派生类对象成员的构造函数</p>
<p>\4. 派生类对象成员的析构函数</p>
<p>\5. 派生类的析构函数</p>
<p>\6. 基类的析构函数</p>
<p>如果派生类的基类也是派生类，每个派生类只需负责其直接提供基类数据成员的初始化</p>
<p><strong>调整基类成员在派生类中访问属性的其他方法</strong></p>
<p><strong>同名成员</strong></p>
<p>在派生类中声明与基类同名的成员会覆盖基类的同名成员</p>
<p>可以通过作用域运算符来访问到基类的同名成员，例如：</p>
<p>sorces = s;</p>
<p>}</p>
<p>void disp() {</p>
<p>getinfo();//调用基类的函数访问基类的私有成员</p>
<p>cout &lt;&lt; &quot;sorces:&quot; &lt;&lt; sorces &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>student LiHua;</p>
<p>LiHua.setinfo1(&quot;LiHua&quot;, 66, 77);</p>
<p>LiHua.disp();</p>
<p>return 0;</p>
<p>}</p>
<p>name:LiHua</p>
<p>age:66</p>
<p>sorces:77</p>
<p>派生类名（参数总表）：基类名（参数表）{</p>
<p>派生类新增的成员的初始化语句</p>
<p>}</p>
<p>class A{</p>
<p>public:</p>
<p>void print();声明同名的数据成员会作为新的变量出现：</p>
<p><strong>访问声明</strong></p>
<p>访问声明用来个别调整基类成员在派生类中保持<strong>原来</strong>（原来的访问属性不可改变）的访问属性。</p>
<p>声明方法是：把基类成员写在派生类中，同时给成员名前加上 基类名：： ，访问声明中不带有类型和参</p>
<p>数</p>
<p>数据成员也可以访问声明。</p>
<p>对于重载函数名，访问声明将对所有同名函数生效。</p>
<p>};</p>
<p>class B: public A{</p>
<p>public:</p>
<p>void print(){</p>
<p>A::print();</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main(){</p>
<p>B tmp;</p>
<p>tmp.print();//访问派生类中的print函数</p>
<p>tmp.A::print();//访问基类中的print函数</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>int i;</p>
<p>base(int x):i(x){}</p>
<p>};</p>
<p>class derived :private base {</p>
<p>public:</p>
<p>derived(int a,int b) :base(a),i(b){}</p>
<p>int i;</p>
<p>};</p>
<p>int main() {</p>
<p>derived A(2,4);</p>
<p>cout &lt;&lt; A.i &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>4</p>
<p>class A{</p>
<p>public:</p>
<p>int a;</p>
<p>protected:<strong>多重继承</strong></p>
<p>从一个基类中派生叫做单继承</p>
<p>从多个基类中派生叫做多重继承</p>
<p><strong>多重继承派生类的声明</strong></p>
<p>与单继承派生类相似：</p>
<p>如果没写继承方式，默认是private</p>
<p>对于基类成员的访问与单继承相同</p>
<p>如果多个基类有相同的成员名，访问的时候需要使用成员限定名来消除二义性。</p>
<p><strong>多重继承派生类的构造函数与析构函数</strong></p>
<p>与单继承类似（有点像成员初始化列表）</p>
<p>对基类的初始化顺序取决于定义派生类时，基类声明的顺序</p>
<p>析构函数时不带参数的，所以派生类是否定义析构函数与基类无关</p>
<p><strong>虚基类</strong></p>
<p>使用场景：一个类多重继承的多个类拥有同一个父类，虚基类可以让这同一个父类成为这多重继承的类</p>
<p>的共同基类，而不是各自的基类。</p>
<p>一个类有多个直接基类，这些直接基类又有共同的基类，为了让这些直接基类对公共基类只存在一个复</p>
<p>制，则可以将这个公共基类说明为虚基类</p>
<p>void print();</p>
<p>};</p>
<p>class B: private A{</p>
<p>public:</p>
<p>A::a;</p>
<p>protected:</p>
<p>A::print;</p>
<p>};</p>
<p>A::print(){</p>
<p>cout &lt;&lt; a*a &lt;&lt; endl;</p>
<p>}</p>
<p>int main(){</p>
<p>B tmp;</p>
<p>cout &lt;&lt; tmp.a;</p>
<p>tmp.print();</p>
<p>return 0;</p>
<p>}</p>
<p>class 派生类名：继承方式1 基类1，继承方式2，基类2....{</p>
<p>新增部分</p>
<p>};</p>
<p>派生类名（参数总表）：基类名1（参数表1），基类名2（参数表2）...{</p>
<p>新增成员初始化语句</p>
<p>}声明继承关系时，使用关键字virtual说明即可（与继承方式关键字没有位置关系，在前在后都行）</p>
<p><strong>虚基类的初始化</strong></p>
<p>虚基类的初始化与一般多继承的初始化是一样的，但构造函数调用顺序不同：先调用虚基类的构造函</p>
<p>数，再调用非基类的构造函数，最后再调用派生类的构造函数。</p>
<p>如果虚基类中有带有形参的构造函数，则所有直接或间接派生类都必须再构造函数的成员初始化列表中</p>
<p>列出对虚基类构造函数的调用。</p>
<p>示例：初始化</p>
<p>class 派生类名:virtual 继承方式 基类名{</p>
<p>};</p>
<p>#include<iostream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>private:</p>
<p>int a;</p>
<p>public:</p>
<p>base(int a):a(a){</p>
<p>cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base1 :virtual public base {</p>
<p>private:</p>
<p>int a1;</p>
<p>public:</p>
<p>base1(int a, int a1) :base(a), a1(a1) {</p>
<p>cout &lt;&lt; &quot;base1&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base2 : virtual public base {</p>
<p>private:</p>
<p>int a2;</p>
<p>public:</p>
<p>base2(int a, int a2) :base(a), a2(a2) {</p>
<p>cout &lt;&lt; &quot;base2&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base3 : public base1, public base2 {</p>
<p>private:</p>
<p>int a3;</p>
<p>public:</p>
<p>base3(int a, int a1, int a2, int a3) :base(a), base1(a, a1), base2(a, a2),</p>
<p>a3(a3) {</p>
<p>cout &lt;&lt; &quot;base3&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main() {<strong>一个问题</strong></p>
<p>派生类从基类继承成员的时候，继承的成员是基类的成员还是基类成员的复制？虚基类呢？</p>
<p>base3 tmp(1,2,3,4);</p>
<p>return 0;</p>
<p>}</p>
<p>base</p>
<p>base1</p>
<p>base2</p>
<p>base3</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>protected:</p>
<p>int a;</p>
<p>public:</p>
<p>base(int a1) {</p>
<p>a = a1;</p>
<p>cout &lt;&lt; &quot;base:&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base0 :virtual public base {</p>
<p>public:</p>
<p>base0(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;虚基类1：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base1 :virtual public base {</p>
<p>public:</p>
<p>base1(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;虚基类2：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class basev :public base0, public base1 {</p>
<p>public:</p>
<p>basev(int a1) :base(a1),base0(a1),base1(a1) {}</p>
<p>void geta() {</p>
<p>base0::geta();</p>
<p>base1::geta();</p>
<p>cout &lt;&lt;&quot;虚基类派生：&quot;&lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>/*</p>
<p>base0和base1是base虚基类的派生类，basev是base0和base1的派生类</p>
<p>执行过程中会调用一次基类的构造函数base0和base1和basev从base继承的成员访问地址是一样的，访问时可以直接访问</p>
<p>也就是说，虚基类可以让不同类继承的同一个基类的元素，而不是不同类分别复制继承同一个基类</p>
<p>*/</p>
<p>class base2 :public base {</p>
<p>public:</p>
<p>base2(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;一般基类1：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class base3 :public base {</p>
<p>public:</p>
<p>base3(int a1) :base(a1) {}</p>
<p>void geta() {</p>
<p>cout &lt;&lt; &quot;一般基类2：&quot; &lt;&lt; &amp;a &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class basea :public base2, public base3 {</p>
<p>public:</p>
<p>basea(int a1):base2(a1),base3(a1){}</p>
<p>void geta() {</p>
<p>base2::geta();</p>
<p>base3::geta();</p>
<p>cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>/*</p>
<p>base2和base3是base基类的派生类，这里没有声明虚基类，basea是base2和base3的派生类</p>
<p>basea中继承的base2和base3分别各自从base类中继承了成员，所以base2和base3中继承的成员是不同</p>
<p>的（地址），访问时需要成员限定符来单独指定</p>
<p>base的构造函数调用了两次</p>
<p>*/</p>
<p>int main() {</p>
<p>basev tmp1(1);</p>
<p>tmp1.geta();</p>
<p>basea tmp2(2);</p>
<p>tmp2.geta();</p>
<p>return 0;</p>
<p>}</p>
<p>base:009BF71C</p>
<p>虚基类1：009BF71C</p>
<p>虚基类2：009BF71C</p>
<p>虚基类派生：009BF71C</p>
<p>------------------</p>
<p>base:009BF704</p>
<p>base:009BF708</p>
<p>一般基类1：009BF704</p>
<p>一般基类2：009BF708</p>
<p>------------------<strong>基类与派生类对象之间的赋值兼容关系</strong></p>
<p>简单来说就是：派生类可以当基类来用，反之不行：</p>
<p>\1. 派生类对象可以给基类对象赋值</p>
<p>\2. 派生类对象可以初始化基类对象引用</p>
<p>\3. 派生类对象（公有派生对象可以，私有则不行）地址可以赋值给基类对象的指针</p>
<p>\4. 函数形参是基类对象（或基类引用）时，可以用派生类对象来代替</p>
<p>示例：</p>
<p><strong>第五章：多态性</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>int i;</p>
<p>base(int x) {</p>
<p>i = x;</p>
<p>}</p>
<p>void show() {</p>
<p>cout &lt;&lt; &quot;base:&quot; &lt;&lt; i &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class derived:public base {</p>
<p>public:</p>
<p>derived(int x) :base(x){}</p>
<p>};</p>
<p>void fun(base&amp; bb) {</p>
<p>cout &lt;&lt; bb.i &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>base op1(12);</p>
<p>derived op2(23),*ptr;</p>
<p>base op3 = op2;//派生类对象给基类对象赋值</p>
<p>op3.show();</p>
<p>base&amp; op4 = op2;//派生类对象可以初始化基类引用</p>
<p>op4.show();</p>
<p>ptr = &amp;op2;//派生类对象地址可以复制给基类对象指针</p>
<p>ptr-&gt;show();</p>
<p>fun(op2);//派生类对象可以代替基类对象作为函数参数</p>
<p>return 0;</p>
<p>}</p>
<p>base:23</p>
<p>base:23</p>
<p>base:23</p>
<p>23多态性是指不同对象接收到相同消息执行不同的操作</p>
<p>程序编译过程分为静态联编和动态联编</p>
<p>静态联编支持多态性通过<strong>重载</strong>（函数重载[第二章]，运算符重载）实现</p>
<p>动态联编支持多态性通过<strong>虚函数</strong>实现</p>
<p><strong>运算符重载</strong></p>
<p>运算符的重载通过创建运算符重载函数来实现。可以是如下几种：</p>
<p>在类外定义的运算符重载函数</p>
<p>类的成员函数</p>
<p>类的友元函数</p>
<p>运算符重载用于简化类的对象与其他数据进行运算的操作</p>
<p><strong>在类外定义的运算符重载函数</strong></p>
<p>这种运算符重载函数仅能用于操作类的公有成员，私有成员和保护成员需要用到类的成员重载函数和友</p>
<p>元函数。</p>
<p>定义方法：定义函数名为operator@(@表示运算符，可以是+-*/...等)的函数</p>
<p>说明：</p>
<p>\1. 只有以下运算符不允许重载：2. 只能对C++已有的运算符进行重载，不能新定义运算符</p>
<p>\3. 重载不能改变运算符的</p>
<p>\1. 操作对象</p>
<p>\2. 优先级</p>
<p>\3. 结合特性</p>
<p>\4. 运算符重载函数的参数需要至少有一个是类对象</p>
<p>\5. 运算符重载函数可以是普通函数，类的成员函数，类的友元函数</p>
<p>\6. 一般用作类的运算符必须重载</p>
<p>\7. 赋值运算符 = ，默认有重载，功能是赋值</p>
<p>示例：</p>
<p><strong>友元运算符重载</strong></p>
<p>定义形式有两种：</p>
<p>\1. 在类内定义</p>
<p>\2. 在类外定义，在类内声明友元函数原型（类外的重载函数不属于成员）</p>
<p>定义方式同普通友元函数一样，详见第二章</p>
<p>对双目运算符重载需要两个参数</p>
<p>. 成员访问运算符</p>
<p>.* 成员访问指针运算符</p>
<p>:: 作用域运算符</p>
<p>sizeof 长度运算符</p>
<p>?: 条件运算符</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class complex {</p>
<p>public:</p>
<p>double r;</p>
<p>double i;</p>
<p>complex(double a=0, double b=0) :r(a), i(b) {}</p>
<p>};</p>
<p>complex operator+(complex op1, complex op2) {</p>
<p>complex tmp;</p>
<p>tmp.r = op1.r + op2.r;</p>
<p>tmp.i = op1.i + op2.i;</p>
<p>return tmp;</p>
<p>}</p>
<p>int main() {</p>
<p>complex A(1, 2), B(3, 3),sum;</p>
<p>sum = A + B;</p>
<p>cout &lt;&lt; sum.r &lt;&lt; endl &lt;&lt; sum.i &lt;&lt; endl;</p>
<p>}</p>
<p>4</p>
<p>5对单目运算符重载需要一个参数</p>
<p>说明：</p>
<p>\1. 在函数返回的时候，可以直接用类的构造函数生成一个临时对象</p>
<p>\2. 重载函数的参数不能使用对象作为形参然后返回这个对象，因为对象返回前会先被析构，形参的修</p>
<p>改无法传递到函数外，需要用引用或者指针</p>
<p>\3. 运算符重载函数可以返回任意类型</p>
<p>\4. 有的运算符不能定义为友元运算符重载函数：</p>
<p>\1. 赋值运算符=</p>
<p>\2. 下标运算符[]</p>
<p>\3. 函数调用运算符()</p>
<p><strong>成员运算符重载函数</strong></p>
<p>定义形式有两种：</p>
<p>\1. 在类内定义</p>
<p>\2. 在类外定义，在类内声明函数原型</p>
<p>对于双目运算符，需要一个参数（右参数），左参数由this指针隐含传递</p>
<p>对于单目运算符，不需要参数，由当前对象作为操作数传递参数</p>
<p><strong>成员运算符重载函数与友元运算符重载函数的区别</strong></p>
<p>\1. 运算符参数数量不同</p>
<p>\2. 有一种情况必须用友元运算符重载函数：一个对象与一个普通类型数据进行计算的时候</p>
<p>书上215页给出的声明运算符重载函数的经验参考：</p>
<p>\1. 对于单目运算符，建议选择成员函数</p>
<p>\2. 对于运算符=,(),[],-&gt;，只能作为成员函数</p>
<p>\3. 对于运算符+=,-=,*=,/=,&amp;=,!=,~=,%=,&lt;&lt;=,&gt;&gt;=，建议重载为成员函数</p>
<p>\4. 其他运算符，建议重载为友元函数</p>
<p>**++<strong><strong>和</strong></strong>--**<strong>的重载</strong></p>
<p>++和--这两个运算符可前缀也可后缀，默认情况下，前缀是先运算再返回，后缀是先返回再运算。</p>
<p>重载运算符的时候，可以通过关键词int作为参数来选择是前缀还是后缀使用：</p>
<p>前缀：</p>
<p>后缀：</p>
<p>友元运算符重载函数没有this指针，所以采用对象引用参数传递数据</p>
<p>return complex(op1.r+op2.r,op1.i+op2.i);</p>
<p>op.operator++();</p>
<p>operator++(X&amp; a);</p>
<p>op.operator++(int);</p>
<p>operator++(X&amp; a,int);前缀后缀方式的函数内部语句取决与编程需要</p>
<p>**示例：****++,--**<strong>运算符前缀和后缀的运算顺序分析</strong></p>
<p>一般情况下前缀和后缀的区别</p>
<p>反汇编分析：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>int a = 10;</p>
<p>int b = 10;</p>
<p>cout &lt;&lt; ++a;</p>
<p>//cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; b++;</p>
<p>return 0;</p>
<p>}</p>
<p>int a = 10;</p>
<p>00322798 mov dword ptr [a],0Ah</p>
<p>int b = 10;</p>
<p>0032279F mov dword ptr [b],0Ah</p>
<p>;变量赋值</p>
<p>cout &lt;&lt; ++a;</p>
<p>003227A6 mov eax,dword ptr [a]</p>
<p>003227A9 add eax,1</p>
<p>003227AC mov dword ptr [a],eax</p>
<p>003227AF mov esi,esp</p>
<p>003227B1 mov ecx,dword ptr [a]</p>
<p>003227B4 push ecx</p>
<p>;把a的值加1然后入栈进入调用</p>
<p>003227B5 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (032D0D8h)]</p>
<p>003227BB call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (032D0E0h)]</p>
<p>003227C1 cmp esi,esp</p>
<p>003227C3 call __RTC_CheckEsp (0321285h)</p>
<p>//cout &lt;&lt; endl;</p>
<p>;打印</p>
<p>cout &lt;&lt; b++;</p>
<p>003227C8 mov eax,dword ptr [b]</p>
<p>003227CB mov dword ptr [ebp-0DCh],eax</p>
<p>;把b的值额外存起来</p>
<p>003227D1 mov ecx,dword ptr [b]</p>
<p>003227D4 add ecx,1</p>
<p>003227D7 mov dword ptr [b],ecx</p>
<p>;b的值加一</p>
<p>003227DA mov esi,esp</p>
<p>003227DC mov edx,dword ptr [ebp-0DCh]</p>
<p>003227E2 push edx</p>
<p>;把刚才额外存起来的值入栈调用</p>
<p>003227E3 mov ecx,dword ptr [<em>imp</em>?cout@std@@3V?$basic_ostream@DU?</p>
<p>$char_traits@D@std@@@1@A (032D0D8h)]<strong>赋值运算符</strong> = <strong>的重载</strong></p>
<p>一般情况下，用默认的重载赋值运算符就够用了，默认的功能就是将一个对象的值逐域赋值给另一个对</p>
<p>象，这是一种浅层复制的方法。</p>
<p>类的赋值运算符只能重载为成员函数</p>
<p>当类中由指针成员时，使用默认的赋值运算符会产生错误：指针悬挂问题</p>
<p><strong>指针悬挂问题</strong></p>
<p>用别人一张图来简单说明，两个对象p1和p2，都有一个指针类型的数据成员，当使用了默认的赋值运</p>
<p>算符进行赋值之后（p2=p1），p2的指针会指向p2指向的那个空间，当对象p2被撤销后，p1的指针指</p>
<p>向了一个错误的地方，这就是指针悬挂问题</p>
<p><strong>深层赋值</strong></p>
<p>通过深层赋值可以解决指针悬挂问题，通过重载赋值运算符=实现：</p>
<p>还以上图为例，内容大致为先将P2原来指向的空间给释放掉，然后重新申请一片空间，将p1指向的空</p>
<p>间的值复制到p2新的空间</p>
<p><strong>下标运算符</strong>**&quot;[]&quot;**<strong>的重载</strong></p>
<p>[]是一个双目运算符</p>
<p>重载函数只能定义为成员函数，形参表示下标</p>
<p>重载时，返回一个int型的引用，可使重载的[]用在赋值语句的左边</p>
<p>示例：</p>
<p>003227E9 call dword ptr</p>
<p>[__imp_std::basic_ostream&lt;char,std::char_traits<char> &gt;::operator&lt;&lt; (032D0E0h)]</p>
<p>003227EF cmp esi,esp</p>
<p>003227F1 call __RTC_CheckEsp (0321285h)</p>
<p>;打印</p>
<p>return 0;</p>
<p>003227F6 xor eax,eax</p>
<p>}<strong>类型转换</strong></p>
<p><strong>系统预设的类型转换</strong></p>
<p>分为隐式转换和显示转换：</p>
<p>隐式转换</p>
<p>在赋值表达式A=B时，赋值运算都右边的B会先转换成A的类型</p>
<p>当char或short类型变量与int类型变量进行运算时，将char和short类型转换成int类型</p>
<p>当两个操作对象不一样的时候，算数运算前，低级别 的类型自动转换成高级别的类型</p>
<p>显式转换</p>
<p>类型名(表达式)</p>
<p>通过转换构造函数可以将 预定义类型数据 转换成 类类型数据</p>
<p>通过类型转换函数可以将 类类型数据 转换成 预定义类型数据</p>
<p><strong>转换构造函数</strong></p>
<p>一个特殊的构造函数，只有一个参数，用这个参数初始化一个临时对象用来运算</p>
<p><strong>类型转换函数</strong></p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class arr {</p>
<p>public:</p>
<p>arr(int a1,int b1,int c1,int d1){</p>
<p>a[0] = a1;</p>
<p>a[1] = b1;</p>
<p>a[2] = c1;</p>
<p>a[3] = d1;</p>
<p>}</p>
<p>int&amp; operator[](int aa);</p>
<p>private:</p>
<p>int a[4];</p>
<p>};</p>
<p>int&amp; arr::operator[](int aa) {</p>
<p>if (aa &lt; 0 || aa &gt;= 4)exit(1);</p>
<p>return a[aa];</p>
<p>}</p>
<p>int main() {</p>
<p>arr op1(1, 2, 3, 4);</p>
<p>int t = 0;</p>
<p>t = op1[2];</p>
<p>cout &lt;&lt; t &lt;&lt; endl;</p>
<p>op1[1] = 10;</p>
<p>cout &lt;&lt; op1[1] &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>3</p>
<p>10格式：</p>
<p>目标类型为要转换的类型，就像是重载预设的显式转换函数</p>
<p>说明：</p>
<p>\1. 类型转换只能是类的成员函数</p>
<p>\2. 类型转换函数没有参数，也没函数类型</p>
<p>\3. 必须由return语句</p>
<p>\4. 一个类可以有多个类型转换函数</p>
<p><strong>示例</strong></p>
<p>\1. 程序先从类中寻找有没有重载类的加法运算符</p>
<p>\2. 然后寻找类中重载的类型转换函数，找到了是int</p>
<p>\3. 然后找找有没有转换构造函数</p>
<p>\4. 然后类型转换成int，然后通过转换构造函数生成临时对象用于赋值</p>
<p>operator 目标类型(){</p>
<p>函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class complex {</p>
<p>public:</p>
<p>complex() {}</p>
<p>complex(int a, int b) {</p>
<p>r = a;</p>
<p>i = b;</p>
<p>}</p>
<p>complex(int x) {</p>
<p>r = i = x;</p>
<p>}</p>
<p>operator int() {</p>
<p>return r + i;</p>
<p>}</p>
<p>void print() {</p>
<p>cout &lt;&lt; r &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; endl;</p>
<p>}</p>
<p>private:</p>
<p>int r;</p>
<p>int i;</p>
<p>};</p>
<p>int main() {</p>
<p>complex A(5, 4),B(2,2),C;</p>
<p>C = A + B;</p>
<p>C.print();</p>
<p>return 0;</p>
<p>}<strong>虚函数</strong></p>
<p>当基类指针指向公有派生类对象的时候，基类指针只能访问派生类中从基类继承的成员，不能访问派生</p>
<p>类中定义的成员。</p>
<p>也就是基类指针只能指向派生类的基类部分</p>
<p>为了解决这个问题，引入虚函数，虚函数在程序运行过程中进行决定执行哪个内容</p>
<p>虚函数用于处理基类指针指向派生类所带来的问题。</p>
<p><strong>定义虚函数</strong></p>
<p>在普通的声明函数前加上关键字“virtual”即可声明为虚函数，虚函数只能声明为成员函数，不能声明为</p>
<p>友元函数和静态成员函数</p>
<p>也可以在类外定义，在类内声明，仅在声明的时候写出虚函数关键字即可</p>
<p>在派生类中，对虚函数重新定义需要函数原型与基类完全相同，当一个成员函数被定义为虚函数的时</p>
<p>候，其派生类中复合重新定义虚函数要求的同名函数都会自动成为虚函数</p>
<p>在派生类中，如果没有重新定义虚函数，则公有派生类直接继承基类的虚函数</p>
<p>只有通过基类指针访问虚函数时才能获得运行时的多态性</p>
<p><strong>虚析构函数</strong></p>
<p>C++中不能声明虚析构函数，但可以声明虚析构函数</p>
<p>基类指针指向派生类之后，如果没有虚析构函数，则删除对象时会调用基类的析构函数，而不是</p>
<p>派生类的</p>
<p><strong>虚函数与重载函数的关系</strong></p>
<p>基类的虚函数重新定义是一种特殊的重载函数，在派生类中重新定义的时候，要求函数类型，函数名，</p>
<p>参数数量，参数类型顺序都必须与基类虚函数原型完全相同</p>
<p><strong>多重继承与虚函数</strong></p>
<p>多重继承时，例如：</p>
<p>class A{</p>
<p>virtual void print(){</p>
<p>cout &lt;&lt; &quot;111&quot;&lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class B{</p>
<p>virtual ~B(){</p>
<p>cout &lt;&lt; &quot;T&quot;&lt;&lt;endl;</p>
<p>}</p>
<p>};</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>class B1{</p>
<p>virtual void fun(){</p>
<p>cout &lt;&lt; &quot;B1&quot; &lt;&lt; endl;<strong>纯虚函数</strong></p>
<p>纯虚函数是一个在基类中声明的函数，在基类中没有定义，在派生类中需要进行定义，所以在基类中声</p>
<p>明为纯虚函数</p>
<p>在基类中为派生类保留一个虚函数的名字，功能由派生类来定义</p>
<p><strong>抽象类</strong></p>
<p>一个类中至少存在一个纯虚函数，则称之为抽象类</p>
<p>抽象类不能建立对象，只能用作基类</p>
<p>抽象类不能作为参数类型，返回值类型，转换类型，但可以声明指针，用来实现多态性</p>
<p>如果抽象类的派生类没有重新说明纯虚函数，则派生类也是抽象类</p>
<p><strong>第六章：模板与异常处理</strong></p>
<p>}</p>
<p>};</p>
<p>class B2{</p>
<p>void fun(){</p>
<p>cout &lt;&lt; &quot;B2&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>class D{</p>
<p>void fun(){</p>
<p>cout &lt;&lt; &quot;D&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>};</p>
<p>int main(){</p>
<p>B1 *ptr1;</p>
<p>B2 *ptr2;</p>
<p>D obj;</p>
<p>ptr1 = &amp;obj;</p>
<p>ptr1 -&gt; fun();//对于ptr1的继承路线，fun函数是虚函数，此时fun函数指向派生类的fun函数</p>
<p>ptr2 = &amp;obj;</p>
<p>ptr2 -&gt; fun();//对于ptr2的继承路线，fun函数是普通函数，此时fun函数指向B2类中的fun函数</p>
<p>return 0;</p>
<p>}</p>
<p>virtual 函数类型 函数名称(参数表)=0;模板是实现代码重用机制的一种工具，可以实现类型参数化</p>
<p>模板分为：</p>
<p>函数模板</p>
<p>类模板</p>
<p><strong>函数模板和模板函数</strong></p>
<p>函数模板是建立一个通用函数，函数返回类型和形参类型不指定，用虚拟类型来代表，在调用的时候用</p>
<p>实参类型来取代虚拟类型</p>
<p>函数模板声明如下：</p>
<p>其中typename和class都可以用，功能是一样的</p>
<p>函数模板经过实例化生成的具体函数是模板函数</p>
<p>使用示例：</p>
<p>模板中的虚拟类型会在模板函数调用的时候，变成实参的类型</p>
<p>说明：</p>
<p>函数模板中可以用多个类型参数，每个类型参数都要用关键字typename</p>
<p>template关键字和函数模板之间不能有其他的内容</p>
<p>模板函数类似于重载函数，但同一函数模板实例化后执行相同的操作</p>
<p>函数模板也可以重载</p>
<p>函数模板与同名非模板函数可以重载，调用顺序是：</p>
<p>先找参数完全匹配的非重载函数，找到就调用</p>
<p>如果没找到，就找函数模板，将其实例化</p>
<p>如果实例化后产生一个相匹配的函数，就调用它</p>
<p>template &lt;typename 参数类型&gt;</p>
<p>返回类型 函数名(模板参数表){</p>
<p>函数体</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>AT max(AT a, AT b) {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; max(5, 6) &lt;&lt; endl;</p>
<p>cout &lt;&lt; max('a', 'b') &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>6</p>
<p>b<strong>类模板与模板类</strong></p>
<p>类模板是建立一个通用类，其数据成员，成员函数的返回值和形参类型不指定，用一个虚拟类型代表</p>
<p>声明：</p>
<p>类成员声明中，如果需要用通用类型，直接用类型参数即可</p>
<p>定义对象：</p>
<p>使用举例：</p>
<p>成员函数如果声明在类外：</p>
<p>使用举例：</p>
<p>template &lt;typename 类型参数&gt;</p>
<p>class 类名{</p>
<p>类成员声明</p>
<p>};</p>
<p>类模板名&lt;实际类型名&gt;对象名(实参列表)</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>class compare {</p>
<p>private:</p>
<p>AT a;</p>
<p>AT b;</p>
<p>public:</p>
<p>compare(AT a1, AT b1) {</p>
<p>a = a1;</p>
<p>b = b1;</p>
<p>}</p>
<p>AT max() {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>compare<int>op1(4, 5);</p>
<p>cout &lt;&lt; op1.max() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>5</p>
<p>template &lt;typename 类型参数&gt;</p>
<p>函数类型 类名&lt;类型参数&gt;::成员函数名(形参表){</p>
<p>}说明：</p>
<p>类模板使用前，需要在模板名字后面加上&lt;参数类型&gt;</p>
<p>模板类可以有多个类型参数</p>
<p><strong>异常处理</strong></p>
<p>程序中常见的错误分为：编译时的错误，运行时的错误，后者难以发现，称之为异常</p>
<p>传统的处理异常的方式是通过条件分支语句来实现</p>
<p>C++处理异常是：执行一个函数过程中出现异常，发出一个消息，传给上一级来解决，依次逐级上传，</p>
<p>如果到最高一级还不能解决就中断程序</p>
<p>异常处理机制分为三部分：检查try，抛出throw，捕获catch</p>
<p>用法举例：</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>template <typename AT></p>
<p>class compare {</p>
<p>private:</p>
<p>AT a;</p>
<p>AT b;</p>
<p>public:</p>
<p>compare(AT a1, AT b1) {</p>
<p>a = a1;</p>
<p>b = b1;</p>
<p>}</p>
<p>AT max();</p>
<p>};</p>
<p>template <typename AT></p>
<p>AT compare<AT>::max() {</p>
<p>return a &gt; b ? a : b;</p>
<p>}</p>
<p>int main() {</p>
<p>compare<int>op1(4, 5);</p>
<p>cout &lt;&lt; op1.max() &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>using namespace std;</p>
<p>//生成一个有10个相同成员的数组，成员的值位于0到10之间</p>
<p>int* arr(int a) {</p>
<p>if (a &gt; 10 || a &lt; 0)throw a;</p>
<p>int arr1[10] = { a };</p>
<p>return arr1;</p>
<p>}</p>
<p>int main() {</p>
<p>int* a;</p>
<p>int* b;</p>
<p>try {在函数中可能出错的地方用throw抛出异常，抛出异常后立即结束函数调用跳出</p>
<p>将可能出错的函数放在try语句中运行</p>
<p>抛出异常后，由catch语句捕捉处理</p>
<p>说明：</p>
<p>try和catch后面的语句必须带有花括号</p>
<p>catch后面的括号中，一般只写异常信息的类型即可</p>
<p>catch后面的括号中，用 ··· 可以捕获所有异常</p>
<p>在某种情况下，throw可以不包括表达式</p>
<p>C++一旦抛出异常，但程序不捕获的话，系统会中断程序</p>
<p>**第七章：****C++**<strong>的流类库与输入输出</strong></p>
<p>C++的输入输出系统比C语言更加安全可靠，可以解决C语言中scanf和printf函数参数没写对而导致错误</p>
<p>输出的问题</p>
<p>a = arr(5);</p>
<p>b = arr(55);</p>
<p>}</p>
<p>catch(int){</p>
<p>cout &lt;&lt; &quot;超出数组边界&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}printf和scanf只能输入输出预定义的数据类型，C++中可以重载&gt;&gt; ,&lt;&lt;来输入输出自定义类型的数据</p>
<p>**C++**<strong>流的概述</strong></p>
<p><strong>输入输出流</strong></p>
<p>C++输入输出以字节流的形式实现，字节流从输入设备流向内存，从内存流向输出设备。</p>
<p>用于输入输出的头文件：</p>
<p>iostream：标准I/O</p>
<p>fstream：文件I/O</p>
<p>strstream：字符串I/O</p>
<p>iomanip：用于格式控制</p>
<p><strong>预定义的流对象</strong></p>
<p>与输入设备相联系的流对象称为输入流对象</p>
<p>与输出设备相联系的流对象称为输出流对象</p>
<p>预定义的流对象：</p>
<p>cin：与标准输入设备相联系（键盘）</p>
<p>cout：与标准输出设备相联系（显示器）</p>
<p>cerr：与标准错误输出设备相联系（显示器）</p>
<p>clog：与标准错误输出设备相联系（显示器）</p>
<p>cerr和clog都是用来输出错误信息，区别在于cerr不经过缓冲区直接显示在显示器上</p>
<p><strong>输入输出的成员函数</strong></p>
<p>put 函数：用于输出一个字符，参数可以是ASCII码或者字符</p>
<p>get 函数：读取一个字符（包括空白符），赋给字符变量ch，读取失败返回0</p>
<p>getline 函数：从输入流读取n-1个字符，赋值给特定字符数组，然后插入一个字符串结束标识\n</p>
<p>getline 和 cin&lt;&lt; 的区别：</p>
<p>getline只能读取字符类型数据，cin&lt;&lt;可以读取各种类型</p>
<p>getline可以读取空白符，cin&lt;&lt;以空白符作为终止状态</p>
<p>ignore 函数：跳过输入流中的n个字符，或者遇到指定终止字符时提前结束</p>
<p><strong>输入输出的格式控制</strong></p>
<p>用到的时候去查就行</p>
<p>cout.put(char c);</p>
<p>cin.get(ch);</p>
<p>cin.getline(字符数组/字符指针,字符个数n,终止标识字符)</p>
<p>cin.ignore(n,终止字符);<strong>类名</strong></p>
<p><strong>说明</strong></p>
<p>ifstream</p>
<p>输入文件流类</p>
<p>ofstream</p>
<p>输出文件流类</p>
<p>fstream</p>
<p>输入输出文件流类</p>
<p><strong>用户定义类型的输入输出</strong></p>
<p>可以通过重载运算符&lt;&lt;和&gt;&gt;来实现</p>
<p><strong>重载插入运算符</strong>**&lt;&lt;**</p>
<p>其中第一个参数：ostream类对象out的引用，第二个参数是用户自定义的对象</p>
<p>重载插入运算符可以是友元函数或者普通函数，不能是成员函数</p>
<p><strong>重载提取运算符</strong>**&gt;&gt;**</p>
<p>与插入运算符类似</p>
<p><strong>文件的输入输出</strong></p>
<p>C++把文件看成字符序列，一个文件是由一个个字符顺序组成的。可以分为文本文件和二进制文件</p>
<p>文本文件每个字节存放一个ASCII码，代表一个字符</p>
<p>二进制文件按内存存储形式原样存放</p>
<p>文件输入输出的基本过程如下：</p>
<p>\1. 打开文件：创建流对象，与文件向关联</p>
<p>\2. 读写操作</p>
<p>\3. 关闭文件</p>
<p><strong>文件的打开与关闭</strong></p>
<p>进行文件的输入输出，其实是建立一个流对象，将这个流对象与文件相关联，流对象的使用类似于标准</p>
<p>流对象cin和cout</p>
<p>用于输入输出的类：</p>
<p>建立流对象，其实就是建立输入输出流类的对象，例如：</p>
<p>ostream &amp;operator&lt;&lt;(ostream &amp;out,user_name&amp; obj){</p>
<p>out&lt;&lt;obj.item1;</p>
<p>out&lt;&lt;obj.item2;</p>
<p>return out;</p>
<p>}</p>
<p>ostream &amp;operator&gt;&gt;(istream &amp;in,user_name&amp; obj){</p>
<p>in&gt;&gt;obj.item1;</p>
<p>in&gt;&gt;obj.item2;</p>
<p>return in;</p>
<p>}<strong>打开方式</strong></p>
<p><strong>描述</strong></p>
<p>ios::app</p>
<p>追加模式。所有写入都追加到文件末尾。</p>
<p>ios::ate</p>
<p>文件打开后定位到文件末尾。</p>
<p>ios::in</p>
<p>打开文件用于读取。</p>
<p>ios::out</p>
<p>打开文件用于写入。</p>
<p>ios::trunc</p>
<p>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p>
<p>使用成员函数open打开文件：</p>
<p>打开方式：</p>
<p>关闭文件则是通过调用成员函数close()来进行关闭，不需要参数</p>
<p>整个打开关闭文件流程如下：</p>
<p><strong>文本文件的读写</strong></p>
<p>打开文件建立流对象之后，就可以进行读写操作了</p>
<p>文本文件的读写示例：</p>
<p>ifstream in;</p>
<p>ofstream out;</p>
<p>fstream both;</p>
<p>in.open(文件名，打开方式)</p>
<p>#include<fstream></p>
<p>#include<iostream></p>
<p>int main(){</p>
<p>fstream out;</p>
<p>out.open(&quot;C:\test.txt&quot;,ios::out|ios::in);</p>
<p>out.close();</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>#include<fstream></p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>ofstream out;</p>
<p>out.open(&quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;);//打开文件</p>
<p>out &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;//写入数据</p>
<p>out.close();//关闭文件</p>
<p>ifstream in;</p>
<p>char str[80];</p>
<p>in.open(&quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;);</p>
<p>in.getline(str, 80, '\n');</p>
<p>cout &lt;&lt; str &lt;&lt; endl;//输出读取的内容<strong>二进制文件的读写</strong></p>
<p>打开方式要使用 ios::binary</p>
<p>有两种方式进行读写：</p>
<p>\1. put和get</p>
<p>\2. read和write</p>
<p>put和get读写示例：</p>
<p>write和read用法</p>
<p>in.close();</p>
<p>return 0;</p>
<p>}</p>
<p>#include<iostream></p>
<p>#include<fstream></p>
<p>#include<string></p>
<p>using namespace std;</p>
<p>int test_write(string fpath) {</p>
<p>ofstream outf(fpath, ios::binary);//构造函数与open成员函数功能相同</p>
<p>if (!outf) {</p>
<p>cout &lt;&lt; &quot;open fail!&quot; &lt;&lt; endl;</p>
<p>exit(1);</p>
<p>}</p>
<p>char ch = 'a';</p>
<p>for (int i = 0; i &lt; 26; i++) {</p>
<p>outf.put(ch);</p>
<p>ch++;</p>
<p>}</p>
<p>outf.close();</p>
<p>return 0;</p>
<p>}</p>
<p>int test_read(string fpath) {</p>
<p>ifstream inf(fpath, ios::binary);</p>
<p>if (!inf) {</p>
<p>cout &lt;&lt; &quot;read fail!&quot; &lt;&lt; endl;</p>
<p>exit(1);</p>
<p>}</p>
<p>char ch;</p>
<p>while (inf.get(ch))cout &lt;&lt; ch;</p>
<p>inf.close();</p>
<p>return 0;</p>
<p>}</p>
<p>int main() {</p>
<p>string fpath = &quot;C:\Users\halo\Desktop\tmp\cpp.txt&quot;;</p>
<p>test_write(fpath);</p>
<p>test_read(fpath);</p>
<p>return 0;</p>
<p>}第一个参数是数据起始地址，第二个参数是数据长度</p>
<p><strong>二进制文件的随机读写</strong></p>
<p>本段内容来自菜鸟教程：https://www.runoob.com/cplusplus/cpp-files-streams.html</p>
<p>istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream</p>
<p>的 seekg（&quot;seek get&quot;）和关于 ostream 的 seekp（&quot;seek put&quot;）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是</p>
<p>ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是</p>
<p>ios::end（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位</p>
<p>&quot;get&quot; 文件位置指针的实例：</p>
<p><strong>命名空间</strong></p>
<p>用来解决名字冲突问题</p>
<p>定义命名空间：</p>
<p>使用命名空间：</p>
<p><strong>头文件命名规则</strong></p>
<p>使用带后缀.h 的头文件，则不必使用命名空间</p>
<p>使用不带后缀的头文件，需要声明命名空间std;</p>
<p>inf.read(char* buf,int len)</p>
<p>outf.write(const char* buf,int len)</p>
<p>// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</p>
<p>fileObject.seekg( n );</p>
<p>// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</p>
<p>fileObject.seekg( n, ios::cur );</p>
<p>// 把文件的读指针从 fileObject 末尾往回移 n 个字节</p>
<p>fileObject.seekg( n, ios::end );</p>
<p>// 定位到 fileObject 的末尾</p>
<p>fileObject.seekg( 0, ios::end );</p>
<p>namespace NS{</p>
<p>int i=5;</p>
<p>int j=10;</p>
<p>}</p>
<p>using namespace NS;</p>
<p>cout &lt;&lt; i&lt;&lt; endl;</p>
<p>cout &lt;&lt; NS::i &lt;&lt;endl;<strong>参考资料</strong>**😗*</p>
<p>《C++面向对象程序设计教程(第四版)》</p>
<p>《C++面向对象程序设计教程(第四版)习题解答与上机指导》</p>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://7usai.github.io/post/web-xue-xi/">
                                    <h3 class="post-title">
                                        web学习
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    
</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></p>
</footer>


    <!-- jQuery -->
<script src="https://7usai.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://7usai.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://7usai.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://7usai.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://7usai.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://7usai.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://7usai.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
        var allImg = $("img");
        allImg.on("contextmenu", function () {
            return false;
        });
        allImg.on("dragstart", function () {
            return false;
        });
    
</script>




</body>
</html>
