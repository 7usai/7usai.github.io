<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>7usai</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="7usai&#39;blog"/>
<meta name="keywords" content="7usai&#39;blog"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://7usai.github.io/favicon.ico">

<link rel="stylesheet" href="https://7usai.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://7usai.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://7usai.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://7usai.github.io/images/avatar.png" alt="7usai"
                 class="img-responsive">
        </figure>
        <a href="https://7usai.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>7usai</h2>
        <p>7usai&#39;blog</p>
        <ul class="fh5co-social">
            
                <li>
                    
                        <a href="https://github.com/7usai" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://7usai.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://7usai.github.io/tag/AKI9EbS9q/">杂谈</a></li>
                
                    <li><a href="https://7usai.github.io/tag/wwBiS2Ka3/">ctf</a></li>
                
                    <li><a href="https://7usai.github.io/tag/7xbgN0lBu/">二进制</a></li>
                
                    <li><a href="https://7usai.github.io/tag/htgQPxP7v/">漏洞利用</a></li>
                
                    <li><a href="https://7usai.github.io/tag/1gI_7hVyP/">知识</a></li>
                
                    <li><a href="https://7usai.github.io/tag/_wk3DR6W6/">CTF</a></li>
                
                    <li><a href="https://7usai.github.io/tag/eUcnOz4Tr/">转载</a></li>
                
                    <li><a href="https://7usai.github.io/tag/TEP_9-KfN/">C++</a></li>
                
                    <li><a href="https://7usai.github.io/tag/XKOVycb-9/">语言</a></li>
                
                    <li><a href="https://7usai.github.io/tag/lGYs_sz42/">web</a></li>
                
                    <li><a href="https://7usai.github.io/tag/dcphGguTG/">开发</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://7usai.github.io">7usai </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
                    <img src="https://7usai.github.io/post-images/jU8l_PwBM.jpg" alt="BUUCTF re部分wp_2" class="img-responsive">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
                    <div class="tag-container">
                        
                            <a href="https://7usai.github.io/tag/wwBiS2Ka3/" class="tag">ctf, </a>
                        
                            <a href="https://7usai.github.io/tag/7xbgN0lBu/" class="tag">二进制, </a>
                        
                    </div>
                
            </span>
            <h2 class="fh5co-article-title animate-box">BUUCTF re部分wp_2</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-10-10</li>
                <li>3435字</li>
                <li>19 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h2 id="gwctf-2019pyre">[GWCTF 2019]pyre</h2>
<h3 id="脚本">脚本</h3>
<pre><code>flag=''
code = [
    '\x1f',
    '\x12',
    '\x1d',
    '(',
    '0',
    '4',
    '\x01',
    '\x06',
    '\x14',
    '4',
    ',',
    '\x1b',
    'U',
    '?',
    'o',
    '6',
    '*',
    ':',
    '\x01',
    'D',
    ';',
    '%',
    '\x13']
l=len(code)+1
for i in range(l-3 ,-1, -1):
    code[i] = chr(ord(code[i])^ord(code[i + 1]))
for j in range(l-1):
    flag+=chr((ord(code[j])-j)%128)
print(flag)
</code></pre>
<h2 id="crackrtf">CrackRTF</h2>
<p>md5生成一个128bit的结果，通常用32位的16进制字符串表示<br>
sha1生成一个160bit的结果，通常用40位的16进制字符串表示</p>
<pre><code>memset(&amp;v3, 0xCCu, 0x350u);
  memset(&amp;pbData, 0, 0x104u);
  memset(&amp;String1, 0, 0x104u);
  v5 = 0;
  printf(&quot;pls input the first passwd(1): &quot;);
  scanf(&quot;%s&quot;, &amp;pbData);
  if ( strlen((const char *)&amp;pbData) != 6 )
  {
    printf(&quot;Must be 6 characters!\n&quot;);
    ExitProcess(0);
  }
  v5 = unknown_libname_1((char *)&amp;pbData);
  if ( v5 &lt; 100000 )
    ExitProcess(0);
  strcat((char *)&amp;pbData, &quot;@DBApp&quot;);
  v0 = strlen((const char *)&amp;pbData);
  sub_40100A(&amp;pbData, v0, &amp;String1);
  if ( !_strcmpi(&amp;String1, &quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;) )
  {
    printf(&quot;continue...\n\n&quot;);
    printf(&quot;pls input the first passwd(2): &quot;);
    memset(&amp;String, 0, 0x104u);
    scanf(&quot;%s&quot;, &amp;String);
    if ( strlen(&amp;String) != 6 )
    {
      printf(&quot;Must be 6 characters!\n&quot;);
      ExitProcess(0);
    }
    strcat(&amp;String, (const char *)&amp;pbData);
    memset(&amp;String1, 0, 0x104u);
    v1 = strlen(&amp;String);
    sub_401019((BYTE *)&amp;String, v1, &amp;String1);
    if ( !_strcmpi(&quot;27019e688a4e62a649fd99cadaafdb4e&quot;, &amp;String1) )
    {
      if ( !sub_40100F(&amp;String) )
      {
        printf(&quot;Error!!\n&quot;);
        ExitProcess(0);
      }
      printf(&quot;bye ~~\n&quot;);
    }
  }
  return 0;
</code></pre>
<p>主函数代码意思就是比较两次，需要输入两次密码，当密码长度不为6时退出，当密码长度为6时继续比较第二个，第一次输入后在后边添加&quot;@DBApp&quot;，第二次输入后在后边添加第一次添加&quot;@DBApp&quot;后的字符串(即12位字符串pbDate)</p>
<p>两个关键函数sub_40100A，sub_401019</p>
<h3 id="sub_40100a">sub_40100A</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x68u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8004u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>可以看出是sha1加密</p>
<h4 id="爆破脚本">爆破脚本</h4>
<pre><code>from hashlib import sha1
flag = &quot;@DBApp&quot;
for i in range(100000,999999):
   s = str(i)+flag
   x = sha1(s.encode()) #对unicode对象编码
   cnt = x.hexdigest() #产出hash值,拿到加密字符串
   if &quot;6e32d0943418c2c&quot; in cnt:
      print(cnt)
      print(str(i)+flag)
</code></pre>
<h3 id="sub_401019">sub_401019</h3>
<pre><code>  memset(&amp;v4, 0xCCu, 0x64u);
  if ( CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash) )
    {
      if ( CryptHashData(phHash, pbData, dwDataLen, 0) )
      {
        CryptGetHashParam(phHash, 2u, v7, &amp;pdwDataLen, 0);
        *lpString1 = 0;
        for ( i = 0; i &lt; pdwDataLen; ++i )
        {
          wsprintfA(&amp;String2, &quot;%02X&quot;, v7[i]);
          lstrcatA(lpString1, &amp;String2);
        }
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 1;
      }
      else
      {
        CryptDestroyHash(phHash);
        CryptReleaseContext(phProv, 0);
        result = 0;
      }
    }
    else
    {
      CryptReleaseContext(phProv, 0);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>这里的md5解密失败继续看发现sub_40100F</p>
<h3 id="sub_40100f">sub_40100F</h3>
<pre><code>  memset(&amp;v2, 0xCCu, 0x60u);
  hFile = 0;
  hResInfo = 0;
  hResData = 0;
  nNumberOfBytesToWrite = 0;
  NumberOfBytesWritten = 0;
  v5 = 0;
  lpBuffer = 0;
  v3 = 0;
  hResInfo = FindResourceA(0, (LPCSTR)0x65, &quot;AAA&quot;);// 使用FindResourceA( )查找资源，类型是&quot;AAA&quot;，名称101(0x65)
  if ( hResInfo )
  {
    nNumberOfBytesToWrite = SizeofResource(0, hResInfo);
    hResData = LoadResource(0, hResInfo);
    if ( hResData )
    {
      lpBuffer = LockResource(hResData);
      sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite);// 异或操作
      hFile = CreateFileA(&quot;dbapp.rtf&quot;, 0x10000000u, 0, 0, 2u, 0x80u, 0);// 生成一个.rtf文件
      if ( hFile == (HANDLE)-1 )
      {
        result = 0;
      }
      else if ( WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, 0) )
      {
        CloseHandle(hFile);
        result = 1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
</code></pre>
<p>用ResourceHacker查看文件中的资源</p>
<figure data-type="image" tabindex="1"><img src="https://7usai.github.io/post-images/1602344545539.png" alt="" loading="lazy"></figure>
<p>异或函数如下</p>
<pre><code>  memset(&amp;v4, 0xCCu, 0x4Cu);
  v7 = lstrlenA(lpString);
  v6 = lpString;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i &gt;= a3 )
      break;
    *(_BYTE *)(i + a2) ^= v6[i % v7];
  }
  return result;
</code></pre>
<p>这里的a2是AAA中资源的首位指针，v7是密码长度</p>
<p>脚本</p>
<pre><code>s = &quot;{\\rtf1&quot;
a = [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]
flag = &quot;&quot;
for i in range(0, len(s)):
    x = ord(s[i]) ^ a[i]
    flag += chr(x)
print(flag)
</code></pre>
<p>s是rtf文件的6位头部</p>
<p>得到两个6位密码后输入并打开生出的rtf文件，得flag=Flag{N0_M0re_Free_Bugs}</p>
<h2 id="youngter-drive">Youngter-drive</h2>
<p>发现有upx壳，在ubuntu里用upx -d脱壳后放入ida6.8里找不到main函数，放入ida7.0里正常找到</p>
<h3 id="主要函数">主要函数</h3>
<pre><code>main函数

  sub_4110FF(this);                             // input函数
  ::hObject = CreateMutexW(0, 0, 0);            // 创建一个互斥体
  j_strcpy(Dest, Source);                       // 复制到Dest里
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);// 建立新的线程
  v2 = CreateThread(0, 0, sub_41119F, 0, 0, 0); // 与上一行相比多了一个sub_41112C函数
  CloseHandle(hObject);
  CloseHandle(v2);
  while ( dword_418008 != -1 )
    ;
  sub_411190();                                 // 比较并输出函数
  CloseHandle(::hObject);
  return 0;

StartAddress函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      sub_41112C(Source, dword_418008);         // dword=1Dh
      --dword_418008;
      Sleep(0x64u);
    }
    ReleaseMutex(hObject);

sub_41119F函数
  while ( 1 )
  {
    WaitForSingleObject(hObject, 0xFFFFFFFF);
    if ( dword_418008 &gt; -1 )
    {
      Sleep(0x64u);
      --dword_418008;
    }
    ReleaseMutex(hObject);
  }

sub_411190函数
  for ( i = 0; i &lt; 29; ++i )
  {
    if ( Source[i] != off_418004[i] )           // TOiZiZtOrYaToUwPnToBsOaOapsyS
      exit(0);
  }
  return printf(&quot;\nflag{%s}\n\n&quot;, Dest);
  
sub_41112C函数（在StartAddress函数里）
  v3 = *(a2 + a1);                              // a1是source,v3是a1[a2]
  if ( (v3 &lt; 97 || v3 &gt; 122) &amp;&amp; (v3 &lt; 65 || v3 &gt; 90) )// v3不是字母时退出
    exit(0);
  if ( v3 &lt; 97 || v3 &gt; 122 )                    // v3是大写字母时
  {
    result = off_418000[0];                     // QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasd
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 38];
  }
  else                                          // v3是小写字母时
  {
    result = off_418000[0];
    *(a2 + a1) = off_418000[0][*(a2 + a1) - 96];
  }
  return result;
</code></pre>
<p>sub_41112C函数直接反编译会失败，原因是因为堆栈不平衡</p>
<pre><code>.text:00411A04 000                 retn
.text:00411A04     sub_411940      endp ; sp-analysis failed
</code></pre>
<p>这里000本来是-04，将其调成000即可光标放在上边Alt+k修改</p>
<p>线程hObject进行加密，v2就是dword_418008-1，即下标-1，他是倒叙着比较的，相当于先比较source[29]再比较souce[28],但是输出flag时是正序,当比较29时加密，28时正常输出，依次递减，即下标是偶数时直接打印off_418004中的数，是奇数时则需要变换；变换思路以及得flag的脚本如下</p>
<pre><code>off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;
off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;
flag=''
#print(len(off_418004))
for i in range(len(off_418004)):
    if i%2 == 0:
        flag += off_418004[i]
    else:
        if(off_418004[i].isupper()):#isupper判断是否为大写字母
            flag = flag + chr(off_418000.find(off_418004[i])+96)
            #对应*(a2 + a1) = off_418000[0][*(a2 + a1) - 96];思路：先找到下标数即*(a2 + a1) - 96再+96就为flag，这里*(a2 + a1)对应source，因为source与off_418004进行了比较所以相当于其字符串，即用find函数寻找off_418004中字符在off_418000中的下标
        else:
            flag = flag + chr(off_418000.find(off_418004[i])+38)
print(flag)
</code></pre>
<p>得flag为29位，因为输出函数中比较了29位，我们需要自己再加一位，但是只有加E的时候正确</p>
<h2 id="2019红帽杯easyre">[2019红帽杯]easyRE</h2>
<p>ida64位打开，shift+f12查找字符串找到“you found me&quot;，交叉引用找到主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  int result; // eax
  unsigned __int64 v5; // rax
  __int64 v6; // rax
  const __m128i *v7; // ST10_8
  const __m128i *v8; // ST18_8
  const __m128i *v9; // ST20_8
  const __m128i *v10; // ST28_8
  const __m128i *v11; // ST30_8
  const __m128i *v12; // ST38_8
  const __m128i *v13; // ST40_8
  const __m128i *v14; // ST48_8
  const __m128i *v15; // ST50_8
  __int64 v16; // ST58_8
  int i; // [rsp+Ch] [rbp-114h]
  char v18; // [rsp+60h] [rbp-C0h]
  char v19; // [rsp+61h] [rbp-BFh]
  char v20; // [rsp+62h] [rbp-BEh]
  char v21; // [rsp+63h] [rbp-BDh]
  char v22; // [rsp+64h] [rbp-BCh]
  char v23; // [rsp+65h] [rbp-BBh]
  char v24; // [rsp+66h] [rbp-BAh]
  char v25; // [rsp+67h] [rbp-B9h]
  char v26; // [rsp+68h] [rbp-B8h]
  char v27; // [rsp+69h] [rbp-B7h]
  char v28; // [rsp+6Ah] [rbp-B6h]
  char v29; // [rsp+6Bh] [rbp-B5h]
  char v30; // [rsp+6Ch] [rbp-B4h]
  char v31; // [rsp+6Dh] [rbp-B3h]
  char v32; // [rsp+6Eh] [rbp-B2h]
  char v33; // [rsp+6Fh] [rbp-B1h]
  char v34; // [rsp+70h] [rbp-B0h]
  char v35; // [rsp+71h] [rbp-AFh]
  char v36; // [rsp+72h] [rbp-AEh]
  char v37; // [rsp+73h] [rbp-ADh]
  char v38; // [rsp+74h] [rbp-ACh]
  char v39; // [rsp+75h] [rbp-ABh]
  char v40; // [rsp+76h] [rbp-AAh]
  char v41; // [rsp+77h] [rbp-A9h]
  char v42; // [rsp+78h] [rbp-A8h]
  char v43; // [rsp+79h] [rbp-A7h]
  char v44; // [rsp+7Ah] [rbp-A6h]
  char v45; // [rsp+7Bh] [rbp-A5h]
  char v46; // [rsp+7Ch] [rbp-A4h]
  char v47; // [rsp+7Dh] [rbp-A3h]
  char v48; // [rsp+7Eh] [rbp-A2h]
  char v49; // [rsp+7Fh] [rbp-A1h]
  char v50; // [rsp+80h] [rbp-A0h]
  char v51; // [rsp+81h] [rbp-9Fh]
  char v52; // [rsp+82h] [rbp-9Eh]
  char v53; // [rsp+83h] [rbp-9Dh]
  char v54[32]; // [rsp+90h] [rbp-90h]
  int v55; // [rsp+B0h] [rbp-70h]
  char v56; // [rsp+B4h] [rbp-6Ch]
  char v57; // [rsp+C0h] [rbp-60h]
  char v58; // [rsp+E7h] [rbp-39h]
  char v59; // [rsp+100h] [rbp-20h]
  unsigned __int64 v60; // [rsp+108h] [rbp-18h]

  v60 = __readfsqword(0x28u);
  v18 = 73;
  v19 = 111;
  v20 = 100;
  v21 = 108;
  v22 = 62;
  v23 = 81;
  v24 = 110;
  v25 = 98;
  v26 = 40;
  v27 = 111;
  v28 = 99;
  v29 = 121;
  v30 = 127;
  v31 = 121;
  v32 = 46;
  v33 = 105;
  v34 = 127;
  v35 = 100;
  v36 = 96;
  v37 = 51;
  v38 = 119;
  v39 = 125;
  v40 = 119;
  v41 = 101;
  v42 = 107;
  v43 = 57;
  v44 = 123;
  v45 = 105;
  v46 = 121;
  v47 = 61;
  v48 = 126;
  v49 = 121;
  v50 = 76;
  v51 = 64;
  v52 = 69;
  v53 = 67;
  memset(v54, 0, sizeof(v54));                  // 初始化v54为0
  v55 = 0;
  v56 = 0;
  sub_4406E0(0LL, v54);
  v56 = 0;
  LODWORD(v3) = sub_424BA0(v54);
  if ( v3 == 36 )
  {
    for ( i = 0; ; ++i )
    {
      LODWORD(v5) = sub_424BA0(v54);
      if ( i &gt;= v5 )
        break;
      if ( (v54[i] ^ i) != *(&amp;v18 + i) )        // v18[i],第一个关键异或，求出v54
      {
        result = -2;
        goto LABEL_13;
      }
    }
    sub_410CC0(&quot;continue!&quot;);
    memset(&amp;v57, 0, 0x40uLL);                   // v57置零
    v59 = 0;
    sub_4406E0(0LL, &amp;v57);
    v58 = 0;
    LODWORD(v6) = sub_424BA0(&amp;v57);             // 生出v6=39
    if ( v6 == 39 )
    {
      v7 = sub_400E44(&amp;v57);
      v8 = sub_400E44(v7);
      v9 = sub_400E44(v8);
      v10 = sub_400E44(v9);
      v11 = sub_400E44(v10);
      v12 = sub_400E44(v11);
      v13 = sub_400E44(v12);
      v14 = sub_400E44(v13);
      v15 = sub_400E44(v14);
      v16 = sub_400E44(v15);
      if ( !sub_400360(v16, off_6CC090) )       // off_6CC090与v16进行比较，v16是经过十次相同变化的v57
      {
        sub_410CC0(&quot;You found me!!!&quot;);
        sub_410CC0(&quot;bye bye~&quot;);
      }
      result = 0;
    }
    else
    {
      result = -3;
    }
  }
  else
  {
    result = -1;
  }
LABEL_13:
  if ( __readfsqword(0x28u) != v60 )
    sub_444020();
  return result;
}
</code></pre>
<p>一共两个关键变化，一个是异或，一个是未知的相同10次变化，进入sub_400E44函数</p>
<pre><code>__int64 __fastcall sub_400E44(const __m128i *a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  int v5; // [rsp+18h] [rbp-28h]
  int v6; // [rsp+1Ch] [rbp-24h]
  signed __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  LODWORD(v1) = sub_424BA0(a1);
  v8 = v1;
  if ( v1 == 3 * (((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63)) )
    v2 = ((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63);
  else
    v2 = ((6148914691236517206LL * v1) &gt;&gt; 64) - (v1 &gt;&gt; 63) + 1;
  v7 = 4 * v2;
  v9 = sub_41EF60(4 * v2 + 1);
  *(v7 + v9) = 0;
  v5 = 0;
  v6 = 0;
  while ( v5 &lt; v7 - 2 )
  {
    *(v9 + v5) = aAbcdefghijklmn[(*(a1-&gt;m128i_i64 + v6) &gt;&gt; 2)];
    *(v9 + v5 + 1LL) = aAbcdefghijklmn[16 * (*(a1-&gt;m128i_i64 + v6) &amp; 3) | (*(a1-&gt;m128i_i64 + v6 + 1) &gt;&gt; 4)];
    *(v9 + v5 + 2LL) = aAbcdefghijklmn[4 * (*(a1-&gt;m128i_i64 + v6 + 1) &amp; 0xF) | (*(a1-&gt;m128i_i64 + v6 + 2) &gt;&gt; 6)];
    *(v9 + v5 + 3LL) = aAbcdefghijklmn[*(a1-&gt;m128i_i64 + v6 + 2) &amp; 0x3F];
    v6 += 3;
    v5 += 4;
  }
  v3 = v8 - 3 * (((6148914691236517206LL * v8) &gt;&gt; 64) - (v8 &gt;&gt; 63));
  if ( v3 == 1 )
  {
    *(v5 - 2LL + v9) = 61;
    *(v5 - 1LL + v9) = 61;
  }
  else if ( v3 == 2 )
  {
    *(v5 - 1LL + v9) = 61;
  }
  return v9;
}
</code></pre>
<p>容易看出是base64加密，我们则需要进行10次base64解密</p>
<h3 id="异或以及base64十次解密脚本">异或以及base64十次解密脚本</h3>
<pre><code>#异或
a=[73,111,100,108,62,81,110,98,40,111,99,121,127,121,46,105,127,100,96,51,119,125,119,101,107,57,123,105,121,61,126,121,76,64,69,67]
b=''
for i in range(len(a)):
	b+=chr(a[i]^i)
print(b)

#base64十次解密
import base64
url = &quot;Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ==&quot;
for i in range(10):
    url = base64.b64decode(url)
print(url)
</code></pre>
<p>得到</p>
<pre><code>Info:The first four chars are `flag`
b'https://bbs.pediy.com/thread-254172.htm'
</code></pre>
<p>得知flag前四位为flag,进入网址没有题目相关内容，这时查看函数窗口发现main函数与base64加密函数之间还有一个函数，进入并尝试审计</p>
<figure data-type="image" tabindex="2"><img src="https://7usai.github.io/post-images/1602425912026.png" alt="" loading="lazy"></figure>
<pre><code>__int64 sub_400D35()
{
  __int64 result; // rax
  unsigned __int64 v1; // rt1
  unsigned int v2; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+10h] [rbp-20h]
  signed int j; // [rsp+14h] [rbp-1Ch]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v2 = sub_43FD20(0LL) - qword_6CEE38;
  for ( i = 0; i &lt;= 1233; ++i )
  {
    sub_40F790(v2);
    sub_40FE60(v2);
    sub_40FE60(v2);
    v2 = sub_40FE60(v2) ^ 0x98765432;
  }
  v5 = v2;                                      // v5=v2
  if ( (v2 ^ byte_6CC0A0[0]) == 'f' &amp;&amp; (HIBYTE(v5) ^ byte_6CC0A3) == 'g' )// byte_6CC0A3相当于byte_6CC0A0[3]，即v2与byte_6CC0A0数组异或后第一位为f第四位为g时进入下一个异或，又因为已知前四位为flag，所以观察并进入下一个异或
  {
    for ( j = 0; j &lt;= 24; ++j )
      sub_410E90((byte_6CC0A0[j] ^ *(&amp;v5 + j % 4)));
  }
  v1 = __readfsqword(0x28u);
  result = v1 ^ v6;
  if ( v1 != v6 )
    sub_444020();
  return result;
}
</code></pre>
<p>也是一个异或函数，脚本如下</p>
<pre><code>byte_6CC0A0=[0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F,
0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E,
0x72, 0x3C, 0x32, 0x45,0x5B]
v2=''
s='flag'
flag=''
for i in range(4):
    v2+=chr(byte_6CC0A0[i]^ord(s[i]))
for i in range(len(byte_6CC0A0)):
    flag+=chr(byte_6CC0A0[i]^ord(v2[i%4]))
print (flag)
</code></pre>
<p>得flag=flag{Act1ve_Defen5e_Test}</p>
<h2 id="actf新生赛2020easyre">[ACTF新生赛2020]easyre</h2>
<p>有upx壳，脱壳后放入ida</p>
<p>主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+12h] [ebp-2Eh]
  char v5; // [esp+13h] [ebp-2Dh]
  char v6; // [esp+14h] [ebp-2Ch]
  char v7; // [esp+15h] [ebp-2Bh]
  char v8; // [esp+16h] [ebp-2Ah]
  char v9; // [esp+17h] [ebp-29h]
  char v10; // [esp+18h] [ebp-28h]
  char v11; // [esp+19h] [ebp-27h]
  char v12; // [esp+1Ah] [ebp-26h]
  char v13; // [esp+1Bh] [ebp-25h]
  char v14; // [esp+1Ch] [ebp-24h]
  char v15; // [esp+1Dh] [ebp-23h]
  int v16; // [esp+1Eh] [ebp-22h]
  int v17; // [esp+22h] [ebp-1Eh]
  int v18; // [esp+26h] [ebp-1Ah]
  __int16 v19; // [esp+2Ah] [ebp-16h]
  char v20; // [esp+2Ch] [ebp-14h]
  char v21; // [esp+2Dh] [ebp-13h]
  char v22; // [esp+2Eh] [ebp-12h]
  int v23; // [esp+2Fh] [ebp-11h]
  int v24; // [esp+33h] [ebp-Dh]
  int v25; // [esp+37h] [ebp-9h]
  char v26; // [esp+3Bh] [ebp-5h]
  int i; // [esp+3Ch] [ebp-4h]

  sub_401A10();
  v4 = 42;
  v5 = 70;
  v6 = 39;
  v7 = 34;
  v8 = 78;
  v9 = 44;
  v10 = 34;
  v11 = 40;
  v12 = 73;
  v13 = 63;
  v14 = 43;
  v15 = 64;
  printf(&quot;Please input:&quot;);
  scanf(&quot;%s&quot;, &amp;v19);
  if ( (_BYTE)v19 != 'A' || HIBYTE(v19) != 'C' || v20 != 'T' || v21 != 'F' || v22 != '{' || v26 != '}' )
    return 0;
  v16 = v23;
  v17 = v24;
  v18 = v25;
  for ( i = 0; i &lt;= 11; ++i )
  {
    if ( *(&amp;v4 + i) != byte_402000[*((char *)&amp;v16 + i) - 1] )// v4到v15是一个十二位的数组  7Eh
      return 0;
  }
  printf(&quot;You are correct!&quot;);
  return 0;
}
</code></pre>
<p>提取byte_402000中的数值，flag为v16到v18的12位字符，flag的ascii值-1作为byte_402000的下标与v4开头v15结束的12个数做对比</p>
<p>脚本</p>
<pre><code>v4 = [42,70,39,34,78,44,34,40,73,63,43,64]
byte_402000= [0x7E, 0x7D, 0x7C, 0x7B, 0x7A, 0x79, 0x78, 0x77, 0x76, 0x75,
  0x74, 0x73, 0x72, 0x71, 0x70, 0x6F, 0x6E, 0x6D, 0x6C, 0x6B,
  0x6A, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
  0x60, 0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58, 0x57,
  0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D,
  0x4C, 0x4B, 0x4A, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43,
  0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39,
  0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2F,
  0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25,
  0x24, 0x23, 0x20, 0x21, 0x22, 0x00]
b=''
flag=''
for i in range(len(byte_402000)):
    b+=chr(byte_402000[i])
for i in range(len(v4)):
    flag+=chr(b.find(chr(v4[i]))+1)
print(flag)
</code></pre>
<h2 id="suctf2019signin">[SUCTF2019]SignIn</h2>
<h3 id="主函数">主函数</h3>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char v4; // [rsp+0h] [rbp-4A0h]
  char v5; // [rsp+10h] [rbp-490h]
  char v6; // [rsp+20h] [rbp-480h]
  char v7; // [rsp+30h] [rbp-470h]
  char v8; // [rsp+40h] [rbp-460h]
  char v9; // [rsp+B0h] [rbp-3F0h]
  unsigned __int64 v10; // [rsp+498h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  puts(&quot;[sign in]&quot;);
  printf(&quot;[input your flag]: &quot;, a2);
  __isoc99_scanf(&quot;%99s&quot;, &amp;v8);                  // 输入V8
  sub_96A(&amp;v8, (__int64)&amp;v9);
  __gmpz_init_set_str((__int64)&amp;v7, (__int64)&quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL);// 将字符数组以16进制解读成数值并写入v7所指向的内存
  __gmpz_init_set_str((__int64)&amp;v6, (__int64)&amp;v9, 16LL);
  __gmpz_init_set_str(
    (__int64)&amp;v4,
    (__int64)&quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;,
    10LL);
  __gmpz_init_set_str((__int64)&amp;v5, (__int64)&quot;65537&quot;, 10LL);
  __gmpz_powm(&amp;v6, &amp;v6, &amp;v5, &amp;v4);              // 对明文的加密函数,计算v6的v5次方，并对v4取模，最后将结果写入v6,对应于RSA算法中就是n=v4,密文c=v7,公钥e=v5,明文m=v6
  if ( (unsigned int)__gmpz_cmp(&amp;v6, &amp;v7) )     // 比较函数
    puts(&quot;GG!&quot;);
  else
    puts(&quot;TTTTTTTTTTql!&quot;);
  return 0LL;
}
</code></pre>
<p>yafu或者在线解出来p,q都可以</p>
<h3 id="脚本-2">脚本</h3>
<pre><code>import gmpy2
import binascii
c=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35
e=65537
n=103461035900816914121390101299049044413950405173712170434161686539878160984549
p=366669102002966856876605669837014229419
q=282164587459512124844245113950593348271
d = gmpy2.invert(e,(p-1)*(q-1))
m = pow(c,d,n)
#print(hex(m))
print(hex(m)[2:])#[2:]舍去0x
print(bytes.fromhex(hex(m)[2:]))
</code></pre>
<p>得flag=suctf{Pwn_@_hundred_years}</p>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://7usai.github.io/post/lgs4SdGy2/">
                                    <h3 class="post-title">
                                        CUMT校赛200923
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#gwctf-2019pyre">[GWCTF 2019]pyre</a>
<ul>
<li><a href="#%E8%84%9A%E6%9C%AC">脚本</a></li>
</ul>
</li>
<li><a href="#crackrtf">CrackRTF</a>
<ul>
<li><a href="#sub_40100a">sub_40100A</a>
<ul>
<li><a href="#%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC">爆破脚本</a></li>
</ul>
</li>
<li><a href="#sub_401019">sub_401019</a></li>
<li><a href="#sub_40100f">sub_40100F</a></li>
</ul>
</li>
<li><a href="#youngter-drive">Youngter-drive</a>
<ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0">主要函数</a></li>
</ul>
</li>
<li><a href="#2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyre">[2019红帽杯]easyRE</a>
<ul>
<li><a href="#%E5%BC%82%E6%88%96%E4%BB%A5%E5%8F%8Abase64%E5%8D%81%E6%AC%A1%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC">异或以及base64十次解密脚本</a></li>
</ul>
</li>
<li><a href="#actf%E6%96%B0%E7%94%9F%E8%B5%9B2020easyre">[ACTF新生赛2020]easyre</a></li>
<li><a href="#suctf2019signin">[SUCTF2019]SignIn</a>
<ul>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0">主函数</a></li>
<li><a href="#%E8%84%9A%E6%9C%AC-2">脚本</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></p>
</footer>


    <!-- jQuery -->
<script src="https://7usai.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://7usai.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://7usai.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://7usai.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://7usai.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://7usai.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://7usai.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
        var allImg = $("img");
        allImg.on("contextmenu", function () {
            return false;
        });
        allImg.on("dragstart", function () {
            return false;
        });
    
</script>




</body>
</html>
